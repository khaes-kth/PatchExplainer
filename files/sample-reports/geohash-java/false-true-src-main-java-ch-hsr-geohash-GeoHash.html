<!doctype html>
<html lang="en"> 
 <head> 
  <meta charset="UTF-8"> 
  <title>Execution Trace Diff</title> 
  <meta name="viewport" content="width=device-width, initial-scale=1"> 
  <style>
* {
  box-sizing: border-box;
}

/* Create two equal columns that floats next to each other */
.column {
  float: left;
  width: 50%;
  padding: 10px;
  height: 300px; /* Should be removed. Only for demonstration */
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

.test {
    border: 1px solid darkblue;
    padding-left: 10px;
}
</style> 
 </head> 
 <body> 
  <div class="row test"> 
   <h2>Differencing Test:</h2> <code> <pre>@Test <br>
public void test_main(){ <br>
    String ret = NumberAnalyzer.analyze(1); <br>
    assertThat(ret, containsString("greater")); <br>
}
        </pre> </code> 
  </div> 
  <div class="row"> 
   <div class="column"> 
    <h2>Original Code:</h2> <code> <pre id="original-trace">           1:  <span style="background-color: white">      /*</span><br>           2:  <span style="background-color: white">       * Copyright 2010, Silvio Heuberger @ IFS www.ifs.hsr.ch</span><br>           3:  <span style="background-color: white">       *</span><br>           4:  <span style="background-color: white">       * This code is release under the Apache License 2.0.</span><br>           5:  <span style="background-color: white">       * You should have received a copy of the license</span><br>           6:  <span style="background-color: white">       * in the LICENSE file. If you have not, see</span><br>           7:  <span style="background-color: white">       * http://www.apache.org/licenses/LICENSE-2.0</span><br>           8:  <span style="background-color: white">       */</span><br>           9:  <span style="background-color: white">      package ch.hsr.geohash;</span><br>          10:  <span style="background-color: white">      </span><br>          11:  <span style="background-color: white">      import java.io.Serializable;</span><br>          12:  <span style="background-color: white">      import java.util.HashMap;</span><br>          13:  <span style="background-color: white">      import java.util.Map;</span><br>          14:  <span style="background-color: white">      </span><br>          15:  <span style="background-color: white">      @SuppressWarnings("javadoc")</span><br>          16:  <span style="background-color: white">      public final class GeoHash implements Comparable
       <geohash>
        , Serializable {
       </geohash></span><br>          17:  <span style="background-color: white">      	public static final int MAX_BIT_PRECISION = 64;</span><br>          18:  <span style="background-color: white">      	public static final int MAX_CHARACTER_PRECISION = 12;</span><br>          19:  <span style="background-color: white">      	</span><br>          20:  <span style="background-color: white">      	private static final long serialVersionUID = -8553214249630252175L;</span><br>          21:  <span style="background-color: white">      	private static final int[] BITS = { 16, 8, 4, 2, 1 };</span><br>          22:  <span style="background-color: white">      	private static final int BASE32_BITS = 5;</span><br>          23:  <span style="background-color: white">      	public static final long FIRST_BIT_FLAGGED = 0x8000000000000000l;</span><br>          24:  <span style="background-color: white">      	private static final char[] base32 = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'b', 'c', 'd', 'e', 'f',</span><br>          25:  <span style="background-color: white">      			'g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };</span><br>          26:  <span style="background-color: white">      </span><br>          27:  <span style="background-color: yellow">      	private final static Map
       <character, integer>
         decodeMap = new HashMap&lt;&gt;();
       </character,></span><br>          28:  <span style="background-color: white">      </span><br>          29:  <span style="background-color: white">      	static {</span><br>          30:  <span style="background-color: white">      		int sz = base32.length;</span><br>          31:  <span style="background-color: white">      		for (int i = 0; i &lt; sz; i++) {</span><br>          32:  <span style="background-color: yellow">      			decodeMap.put(base32[i], i);</span><br>          33:  <span style="background-color: white">      		}</span><br>          34:  <span style="background-color: white">      	}</span><br>          35:  <span style="background-color: white">      </span><br>          36:  <span style="background-color: white">      	protected long bits = 0;</span><br>          37:  <span style="background-color: white">      	private WGS84Point point;</span><br>          38:  <span style="background-color: white">      </span><br>          39:  <span style="background-color: white">      	private BoundingBox boundingBox;</span><br>          40:  <span style="background-color: white">      </span><br>          41:  <span style="background-color: white">      	protected byte significantBits = 0;</span><br>          42:  <span style="background-color: white">      </span><br>          43:  <span style="background-color: white">      	protected GeoHash() {</span><br>          44:  <span style="background-color: white">      	}</span><br>          45:  <span style="background-color: white">      </span><br>          46:  <span style="background-color: white">      	/**</span><br>          47:  <span style="background-color: white">      	 * This method uses the given number of characters as the desired precision</span><br>          48:  <span style="background-color: white">      	 * value. The hash can only be 64bits long, thus a maximum precision of 12</span><br>          49:  <span style="background-color: white">      	 * characters can be achieved.</span><br>          50:  <span style="background-color: white">      	 */</span><br>          51:  <span style="background-color: red">      	public static GeoHash withCharacterPrecision(double latitude, double longitude, int numberOfCharacters) {</span><br>          52:  <span style="background-color: red">      		if (numberOfCharacters &gt; MAX_CHARACTER_PRECISION) {</span><br>          53:  <span style="background-color: white">      			throw new IllegalArgumentException("A geohash can only be " + MAX_CHARACTER_PRECISION + " character long.");</span><br>          54:  <span style="background-color: white">      		}</span><br>          55:  <span style="background-color: red">      		int desiredPrecision = (numberOfCharacters * 5 &lt;= 60) ? numberOfCharacters * 5 : 60;</span><br>          56:  <span style="background-color: red">      		return new GeoHash(latitude, longitude, desiredPrecision);</span><br>          57:  <span style="background-color: white">      	}</span><br>          58:  <span style="background-color: white">      </span><br>          59:  <span style="background-color: white">      	/**</span><br>          60:  <span style="background-color: white">      	 * create a new {@link GeoHash} with the given number of bits accuracy. This</span><br>          61:  <span style="background-color: white">      	 * at the same time defines this hash's bounding box.</span><br>          62:  <span style="background-color: white">      	 */</span><br>          63:  <span style="background-color: white">      	public static GeoHash withBitPrecision(double latitude, double longitude, int numberOfBits) {</span><br>          64:  <span style="background-color: white">      		if (numberOfBits &gt; MAX_BIT_PRECISION) {</span><br>          65:  <span style="background-color: white">      			throw new IllegalArgumentException("A Geohash can only be " + MAX_BIT_PRECISION + " bits long!");</span><br>          66:  <span style="background-color: white">      		}</span><br>          67:  <span style="background-color: white">      		if (Math.abs(latitude) &gt; 90.0 || Math.abs(longitude) &gt; 180.0) {</span><br>          68:  <span style="background-color: white">      			throw new IllegalArgumentException("Can't have lat/lon values out of (-90,90)/(-180/180)");</span><br>          69:  <span style="background-color: white">      		}</span><br>          70:  <span style="background-color: white">      		return new GeoHash(latitude, longitude, numberOfBits);</span><br>          71:  <span style="background-color: white">      	}</span><br>          72:  <span style="background-color: white">      </span><br>          73:  <span style="background-color: red">      	public static GeoHash fromBinaryString(String binaryString) {</span><br>          74:  <span style="background-color: red">      		GeoHash geohash = new GeoHash();</span><br>          75:  <span style="background-color: red">      		for (int i = 0; i &lt; binaryString.length(); i++) {</span><br>          76:  <span style="background-color: red">      			if (binaryString.charAt(i) == '1') {</span><br>          77:  <span style="background-color: cyan">      				geohash.addOnBitToEnd();</span><br>          78:  <span style="background-color: red">      			} else if (binaryString.charAt(i) == '0') {</span><br>          79:  <span style="background-color: red">      				geohash.addOffBitToEnd();</span><br>          80:  <span style="background-color: white">      			} else {</span><br>          81:  <span style="background-color: white">      				throw new IllegalArgumentException(binaryString + " is not a valid geohash as a binary string");</span><br>          82:  <span style="background-color: white">      			}</span><br>          83:  <span style="background-color: white">      		}</span><br>          84:  <span style="background-color: red">      		geohash.bits &lt;&lt;= (MAX_BIT_PRECISION - geohash.significantBits);</span><br>          85:  <span style="background-color: red">      		long[] latitudeBits = geohash.getRightAlignedLatitudeBits();</span><br>          86:  <span style="background-color: red">      		long[] longitudeBits = geohash.getRightAlignedLongitudeBits();</span><br>          87:  <span style="background-color: red">      		return geohash.recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>          88:  <span style="background-color: white">      	}</span><br>          89:  <span style="background-color: white">      </span><br>          90:  <span style="background-color: white">      	/**</span><br>          91:  <span style="background-color: white">      	 * build a new {@link GeoHash} from a base32-encoded {@link String}.<br></span><br>          92:  <span style="background-color: white">      	 * This will also set up the hashes bounding box and other values, so it can</span><br>          93:  <span style="background-color: white">      	 * also be used with functions like within().</span><br>          94:  <span style="background-color: white">      	 */</span><br>          95:  <span style="background-color: red">      	public static GeoHash fromGeohashString(String geohash) {</span><br>          96:  <span style="background-color: red">      		double[] latitudeRange = { -90.0, 90.0 };</span><br>          97:  <span style="background-color: red">      		double[] longitudeRange = { -180.0, 180.0 };</span><br>          98:  <span style="background-color: white">      </span><br>          99:  <span style="background-color: red">      		boolean isEvenBit = true;</span><br>         100:  <span style="background-color: red">      		GeoHash hash = new GeoHash();</span><br>         101:  <span style="background-color: white">      </span><br>         102:  <span style="background-color: red">      		for (int i = 0; i &lt; geohash.length(); i++) {</span><br>         103:  <span style="background-color: yellow">      			if(decodeMap.containsKey(geohash.charAt(i))) {</span><br>         104:  <span style="background-color: yellow">      				int cd = decodeMap.get(geohash.charAt(i));</span><br>         105:  <span style="background-color: yellow">      				for (int j = 0; j &lt; BASE32_BITS; j++) {</span><br>         106:  <span style="background-color: yellow">      					int mask = BITS[j];</span><br>         107:  <span style="background-color: yellow">      					if (isEvenBit) {</span><br>         108:  <span style="background-color: yellow">      						divideRangeDecode(hash, longitudeRange, (cd &amp; mask) != 0);</span><br>         109:  <span style="background-color: yellow">      					} else {</span><br>         110:  <span style="background-color: yellow">      						divideRangeDecode(hash, latitudeRange, (cd &amp; mask) != 0);</span><br>         111:  <span style="background-color: yellow">      					}</span><br>         112:  <span style="background-color: yellow">      					isEvenBit = !isEvenBit;</span><br>         113:  <span style="background-color: yellow">      				}</span><br>         114:  <span style="background-color: yellow">      			} else {</span><br>         115:  <span style="background-color: yellow">      				throw new IllegalArgumentException("Invalid character character '" + geohash.charAt(i) + "' in geohash '"+geohash+"'!");</span><br>         116:  <span style="background-color: yellow">      			}</span><br>         117:  <span style="background-color: white">      		}</span><br>         118:  <span style="background-color: white">      </span><br>         119:  <span style="background-color: red">      		double latitude = (latitudeRange[0] + latitudeRange[1]) / 2;</span><br>         120:  <span style="background-color: red">      		double longitude = (longitudeRange[0] + longitudeRange[1]) / 2;</span><br>         121:  <span style="background-color: white">      </span><br>         122:  <span style="background-color: red">      		hash.point = new WGS84Point(latitude, longitude);</span><br>         123:  <span style="background-color: red">      		setBoundingBox(hash, latitudeRange, longitudeRange);</span><br>         124:  <span style="background-color: red">      		hash.bits &lt;&lt;= (MAX_BIT_PRECISION - hash.significantBits);</span><br>         125:  <span style="background-color: red">      		return hash;</span><br>         126:  <span style="background-color: white">      	}</span><br>         127:  <span style="background-color: white">      </span><br>         128:  <span style="background-color: white">      	public static GeoHash fromLongValue(long hashVal, int significantBits) {</span><br>         129:  <span style="background-color: white">      		double[] latitudeRange = { -90.0, 90.0 };</span><br>         130:  <span style="background-color: white">      		double[] longitudeRange = { -180.0, 180.0 };</span><br>         131:  <span style="background-color: white">      </span><br>         132:  <span style="background-color: white">      		boolean isEvenBit = true;</span><br>         133:  <span style="background-color: white">      		GeoHash hash = new GeoHash();</span><br>         134:  <span style="background-color: white">      </span><br>         135:  <span style="background-color: white">      		String binaryString = Long.toBinaryString(hashVal);</span><br>         136:  <span style="background-color: white">      		while (binaryString.length() &lt; MAX_BIT_PRECISION) {</span><br>         137:  <span style="background-color: white">      			binaryString = "0" + binaryString;</span><br>         138:  <span style="background-color: white">      		}</span><br>         139:  <span style="background-color: white">      		for (int j = 0; j &lt; significantBits; j++) {</span><br>         140:  <span style="background-color: white">      			if (isEvenBit) {</span><br>         141:  <span style="background-color: white">      				divideRangeDecode(hash, longitudeRange, binaryString.charAt(j) != '0');</span><br>         142:  <span style="background-color: white">      			} else {</span><br>         143:  <span style="background-color: white">      				divideRangeDecode(hash, latitudeRange, binaryString.charAt(j) != '0');</span><br>         144:  <span style="background-color: white">      			}</span><br>         145:  <span style="background-color: white">      			isEvenBit = !isEvenBit;</span><br>         146:  <span style="background-color: white">      		}</span><br>         147:  <span style="background-color: white">      </span><br>         148:  <span style="background-color: white">      		double latitude = (latitudeRange[0] + latitudeRange[1]) / 2;</span><br>         149:  <span style="background-color: white">      		double longitude = (longitudeRange[0] + longitudeRange[1]) / 2;</span><br>         150:  <span style="background-color: white">      </span><br>         151:  <span style="background-color: white">      		hash.point = new WGS84Point(latitude, longitude);</span><br>         152:  <span style="background-color: white">      		setBoundingBox(hash, latitudeRange, longitudeRange);</span><br>         153:  <span style="background-color: white">      		hash.bits &lt;&lt;= (MAX_BIT_PRECISION - hash.significantBits);</span><br>         154:  <span style="background-color: white">      		return hash;</span><br>         155:  <span style="background-color: white">      	}</span><br>         156:  <span style="background-color: white">      </span><br>         157:  <span style="background-color: white">      	/**</span><br>         158:  <span style="background-color: white">      	 * This method uses the given number of characters as the desired precision</span><br>         159:  <span style="background-color: white">      	 * value. The hash can only be 64bits long, thus a maximum precision of 12</span><br>         160:  <span style="background-color: white">      	 * characters can be achieved.</span><br>         161:  <span style="background-color: white">      	 */</span><br>         162:  <span style="background-color: white">      	public static String geoHashStringWithCharacterPrecision(double latitude, double longitude, int numberOfCharacters) {</span><br>         163:  <span style="background-color: white">      		GeoHash hash = withCharacterPrecision(latitude, longitude, numberOfCharacters);</span><br>         164:  <span style="background-color: white">      		return hash.toBase32();</span><br>         165:  <span style="background-color: white">      	}</span><br>         166:  <span style="background-color: white">      </span><br>         167:  <span style="background-color: red">      	private GeoHash(double latitude, double longitude, int desiredPrecision) {</span><br>         168:  <span style="background-color: red">      		point = new WGS84Point(latitude, longitude);</span><br>         169:  <span style="background-color: red">      		desiredPrecision = Math.min(desiredPrecision, MAX_BIT_PRECISION);</span><br>         170:  <span style="background-color: white">      </span><br>         171:  <span style="background-color: red">      		boolean isEvenBit = true;</span><br>         172:  <span style="background-color: red">      		double[] latitudeRange = { -90, 90 };</span><br>         173:  <span style="background-color: red">      		double[] longitudeRange = { -180, 180 };</span><br>         174:  <span style="background-color: white">      </span><br>         175:  <span style="background-color: red">      		while (significantBits &lt; desiredPrecision) {</span><br>         176:  <span style="background-color: red">      			if (isEvenBit) {</span><br>         177:  <span style="background-color: red">      				divideRangeEncode(longitude, longitudeRange);</span><br>         178:  <span style="background-color: white">      			} else {</span><br>         179:  <span style="background-color: red">      				divideRangeEncode(latitude, latitudeRange);</span><br>         180:  <span style="background-color: white">      			}</span><br>         181:  <span style="background-color: red">      			isEvenBit = !isEvenBit;</span><br>         182:  <span style="background-color: white">      		}</span><br>         183:  <span style="background-color: white">      </span><br>         184:  <span style="background-color: red">      		setBoundingBox(this, latitudeRange, longitudeRange);</span><br>         185:  <span style="background-color: red">      		bits &lt;&lt;= (MAX_BIT_PRECISION - desiredPrecision);</span><br>         186:  <span style="background-color: white">      	}</span><br>         187:  <span style="background-color: white">      </span><br>         188:  <span style="background-color: red">      	private static void setBoundingBox(GeoHash hash, double[] latitudeRange, double[] longitudeRange) {</span><br>         189:  <span style="background-color: red">      		hash.boundingBox = new BoundingBox(latitudeRange[0], latitudeRange[1], longitudeRange[0], longitudeRange[1]);</span><br>         190:  <span style="background-color: white">      	}</span><br>         191:  <span style="background-color: white">      </span><br>         192:  <span style="background-color: white">      	public GeoHash next(int step) {</span><br>         193:  <span style="background-color: white">      		return fromOrd(ord() + step, significantBits);</span><br>         194:  <span style="background-color: white">      	}</span><br>         195:  <span style="background-color: white">      </span><br>         196:  <span style="background-color: white">      	public GeoHash next() {</span><br>         197:  <span style="background-color: white">      		return next(1);</span><br>         198:  <span style="background-color: white">      	}</span><br>         199:  <span style="background-color: white">      </span><br>         200:  <span style="background-color: white">      	public GeoHash prev() {</span><br>         201:  <span style="background-color: white">      		return next(-1);</span><br>         202:  <span style="background-color: white">      	}</span><br>         203:  <span style="background-color: white">      </span><br>         204:  <span style="background-color: white">      	public long ord() {</span><br>         205:  <span style="background-color: white">      		int insignificantBits = MAX_BIT_PRECISION - significantBits;</span><br>         206:  <span style="background-color: white">      		return bits &gt;&gt;&gt; insignificantBits;</span><br>         207:  <span style="background-color: white">      	}</span><br>         208:  <span style="background-color: white">      </span><br>         209:  <span style="background-color: white">      	/**</span><br>         210:  <span style="background-color: white">      	 * Returns the number of characters that represent this hash.</span><br>         211:  <span style="background-color: white">      	 * </span><br>         212:  <span style="background-color: white">      	 * @throws IllegalStateException</span><br>         213:  <span style="background-color: white">      	 *             when the hash cannot be encoded in base32, i.e. when the</span><br>         214:  <span style="background-color: white">      	 *             precision is not a multiple of 5.</span><br>         215:  <span style="background-color: white">      	 */</span><br>         216:  <span style="background-color: white">      	public int getCharacterPrecision() {</span><br>         217:  <span style="background-color: white">      		if (significantBits % 5 != 0) {</span><br>         218:  <span style="background-color: white">      			throw new IllegalStateException(</span><br>         219:  <span style="background-color: white">      					"precision of GeoHash is not divisble by 5: " + this);</span><br>         220:  <span style="background-color: white">      		}</span><br>         221:  <span style="background-color: white">      		return significantBits / 5;</span><br>         222:  <span style="background-color: white">      	}</span><br>         223:  <span style="background-color: white">      </span><br>         224:  <span style="background-color: white">      	public static GeoHash fromOrd(long ord, int significantBits) {</span><br>         225:  <span style="background-color: white">      		int insignificantBits = MAX_BIT_PRECISION - significantBits;</span><br>         226:  <span style="background-color: white">      		return fromLongValue(ord &lt;&lt; insignificantBits, significantBits);</span><br>         227:  <span style="background-color: white">      	}</span><br>         228:  <span style="background-color: white">      </span><br>         229:  <span style="background-color: white">      	/**</span><br>         230:  <span style="background-color: white">      	 * Counts the number of geohashes contained between the two (ie how many</span><br>         231:  <span style="background-color: white">      	 * times next() is called to increment from one to two) This value depends</span><br>         232:  <span style="background-color: white">      	 * on the number of significant bits.</span><br>         233:  <span style="background-color: white">      	 * </span><br>         234:  <span style="background-color: white">      	 * @param one</span><br>         235:  <span style="background-color: white">      	 * @param two</span><br>         236:  <span style="background-color: white">      	 * @return number of steps</span><br>         237:  <span style="background-color: white">      	 */</span><br>         238:  <span style="background-color: white">      	public static long stepsBetween(GeoHash one, GeoHash two) {</span><br>         239:  <span style="background-color: white">      		if (one.significantBits() != two.significantBits()) {</span><br>         240:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>         241:  <span style="background-color: white">      					"It is only valid to compare the number of steps between two hashes if they have the same number of significant bits");</span><br>         242:  <span style="background-color: white">      		}</span><br>         243:  <span style="background-color: white">      		return two.ord() - one.ord();</span><br>         244:  <span style="background-color: white">      	}</span><br>         245:  <span style="background-color: white">      </span><br>         246:  <span style="background-color: red">      	private void divideRangeEncode(double value, double[] range) {</span><br>         247:  <span style="background-color: red">      		double mid = (range[0] + range[1]) / 2;</span><br>         248:  <span style="background-color: red">      		if (value &gt;= mid) {</span><br>         249:  <span style="background-color: white">      			addOnBitToEnd();</span><br>         250:  <span style="background-color: red">      			range[0] = mid;</span><br>         251:  <span style="background-color: white">      		} else {</span><br>         252:  <span style="background-color: white">      			addOffBitToEnd();</span><br>         253:  <span style="background-color: red">      			range[1] = mid;</span><br>         254:  <span style="background-color: white">      		}</span><br>         255:  <span style="background-color: white">      	}</span><br>         256:  <span style="background-color: white">      </span><br>         257:  <span style="background-color: red">      	private static void divideRangeDecode(GeoHash hash, double[] range, boolean b) {</span><br>         258:  <span style="background-color: red">      		double mid = (range[0] + range[1]) / 2;</span><br>         259:  <span style="background-color: red">      		if (b) {</span><br>         260:  <span style="background-color: red">      			hash.addOnBitToEnd();</span><br>         261:  <span style="background-color: red">      			range[0] = mid;</span><br>         262:  <span style="background-color: white">      		} else {</span><br>         263:  <span style="background-color: red">      			hash.addOffBitToEnd();</span><br>         264:  <span style="background-color: red">      			range[1] = mid;</span><br>         265:  <span style="background-color: white">      		}</span><br>         266:  <span style="background-color: white">      	}</span><br>         267:  <span style="background-color: white">      </span><br>         268:  <span style="background-color: white">      	/**</span><br>         269:  <span style="background-color: white">      	 * returns the 8 adjacent hashes for this one. They are in the following</span><br>         270:  <span style="background-color: white">      	 * order:<br></span><br>         271:  <span style="background-color: white">      	 * N, NE, E, SE, S, SW, W, NW</span><br>         272:  <span style="background-color: white">      	 */</span><br>         273:  <span style="background-color: white">      	public GeoHash[] getAdjacent() {</span><br>         274:  <span style="background-color: white">      		GeoHash northern = getNorthernNeighbour();</span><br>         275:  <span style="background-color: white">      		GeoHash eastern = getEasternNeighbour();</span><br>         276:  <span style="background-color: white">      		GeoHash southern = getSouthernNeighbour();</span><br>         277:  <span style="background-color: white">      		GeoHash western = getWesternNeighbour();</span><br>         278:  <span style="background-color: white">      		return new GeoHash[] { northern, northern.getEasternNeighbour(), eastern, southern.getEasternNeighbour(),</span><br>         279:  <span style="background-color: white">      				southern,</span><br>         280:  <span style="background-color: white">      				southern.getWesternNeighbour(), western, northern.getWesternNeighbour() };</span><br>         281:  <span style="background-color: white">      	}</span><br>         282:  <span style="background-color: white">      </span><br>         283:  <span style="background-color: white">      	/**</span><br>         284:  <span style="background-color: white">      	 * how many significant bits are there in this {@link GeoHash}?</span><br>         285:  <span style="background-color: white">      	 */</span><br>         286:  <span style="background-color: white">      	public int significantBits() {</span><br>         287:  <span style="background-color: white">      		return significantBits;</span><br>         288:  <span style="background-color: white">      	}</span><br>         289:  <span style="background-color: white">      </span><br>         290:  <span style="background-color: white">      	public long longValue() {</span><br>         291:  <span style="background-color: white">      		return bits;</span><br>         292:  <span style="background-color: white">      	}</span><br>         293:  <span style="background-color: white">      </span><br>         294:  <span style="background-color: white">      	/**</span><br>         295:  <span style="background-color: white">      	 * get the base32 string for this {@link GeoHash}.<br></span><br>         296:  <span style="background-color: white">      	 * this method only makes sense, if this hash has a multiple of 5</span><br>         297:  <span style="background-color: white">      	 * significant bits.</span><br>         298:  <span style="background-color: white">      	 * </span><br>         299:  <span style="background-color: white">      	 * @throws IllegalStateException</span><br>         300:  <span style="background-color: white">      	 *             when the number of significant bits is not a multiple of 5.</span><br>         301:  <span style="background-color: white">      	 */</span><br>         302:  <span style="background-color: red">      	public String toBase32() {</span><br>         303:  <span style="background-color: red">      		if (significantBits % 5 != 0) {</span><br>         304:  <span style="background-color: white">      			throw new IllegalStateException("Cannot convert a geohash to base32 if the precision is not a multiple of 5.");</span><br>         305:  <span style="background-color: white">      		}</span><br>         306:  <span style="background-color: red">      		StringBuilder buf = new StringBuilder();</span><br>         307:  <span style="background-color: white">      </span><br>         308:  <span style="background-color: red">      		long firstFiveBitsMask = 0xf800000000000000l;</span><br>         309:  <span style="background-color: red">      		long bitsCopy = bits;</span><br>         310:  <span style="background-color: red">      		int partialChunks = (int) Math.ceil(((double) significantBits / 5));</span><br>         311:  <span style="background-color: white">      </span><br>         312:  <span style="background-color: red">      		for (int i = 0; i &lt; partialChunks; i++) {</span><br>         313:  <span style="background-color: red">      			int pointer = (int) ((bitsCopy &amp; firstFiveBitsMask) &gt;&gt;&gt; 59);</span><br>         314:  <span style="background-color: red">      			buf.append(base32[pointer]);</span><br>         315:  <span style="background-color: red">      			bitsCopy &lt;&lt;= 5;</span><br>         316:  <span style="background-color: white">      		}</span><br>         317:  <span style="background-color: red">      		return buf.toString();</span><br>         318:  <span style="background-color: white">      	}</span><br>         319:  <span style="background-color: white">      </span><br>         320:  <span style="background-color: white">      	/**</span><br>         321:  <span style="background-color: white">      	 * returns true iff this is within the given geohash bounding box.</span><br>         322:  <span style="background-color: white">      	 */</span><br>         323:  <span style="background-color: white">      	public boolean within(GeoHash boundingBox) {</span><br>         324:  <span style="background-color: white">      		return (bits &amp; boundingBox.mask()) == boundingBox.bits;</span><br>         325:  <span style="background-color: white">      	}</span><br>         326:  <span style="background-color: white">      </span><br>         327:  <span style="background-color: white">      	/**</span><br>         328:  <span style="background-color: white">      	 * find out if the given point lies within this hashes bounding box.<br></span><br>         329:  <span style="background-color: white">      	 * <i>Note: this operation checks the bounding boxes coordinates, i.e. does</i></span><br>         330:  <span style="background-color: white">      	 * not use the {@link GeoHash}s special abilities.s</span><br>         331:  <span style="background-color: white">      	 */</span><br>         332:  <span style="background-color: white">      	public boolean contains(WGS84Point point) {</span><br>         333:  <span style="background-color: white">      		return boundingBox.contains(point);</span><br>         334:  <span style="background-color: white">      	}</span><br>         335:  <span style="background-color: white">      </span><br>         336:  <span style="background-color: white">      	/**</span><br>         337:  <span style="background-color: white">      	 * returns the {@link WGS84Point} that was originally used to set up this.<br></span><br>         338:  <span style="background-color: white">      	 * If it was built from a base32-{@link String}, this is the center point of</span><br>         339:  <span style="background-color: white">      	 * the bounding box.</span><br>         340:  <span style="background-color: white">      	 */</span><br>         341:  <span style="background-color: white">      	public WGS84Point getOriginatingPoint() {</span><br>         342:  <span style="background-color: white">      		return point;</span><br>         343:  <span style="background-color: white">      	}</span><br>         344:  <span style="background-color: white">      </span><br>         345:  <span style="background-color: white">      	/**</span><br>         346:  <span style="background-color: white">      	 * return the center of this {@link GeoHash}s bounding box. this is rarely</span><br>         347:  <span style="background-color: white">      	 * the same point that was used to build the hash.</span><br>         348:  <span style="background-color: white">      	 */</span><br>         349:  <span style="background-color: white">      	// TODO: make sure this method works as intented for corner cases!</span><br>         350:  <span style="background-color: red">      	public WGS84Point getBoundingBoxCenter() {</span><br>         351:  <span style="background-color: white">      		return boundingBox.getCenter();</span><br>         352:  <span style="background-color: white">      	}</span><br>         353:  <span style="background-color: white">      </span><br>         354:  <span style="background-color: red">      	public BoundingBox getBoundingBox() {</span><br>         355:  <span style="background-color: white">      		return boundingBox;</span><br>         356:  <span style="background-color: white">      	}</span><br>         357:  <span style="background-color: white">      </span><br>         358:  <span style="background-color: white">      	public boolean enclosesCircleAroundPoint(WGS84Point point, double radius) {</span><br>         359:  <span style="background-color: white">      		return false;</span><br>         360:  <span style="background-color: white">      	}</span><br>         361:  <span style="background-color: white">      </span><br>         362:  <span style="background-color: red">      	protected GeoHash recombineLatLonBitsToHash(long[] latBits, long[] lonBits) {</span><br>         363:  <span style="background-color: red">      		GeoHash hash = new GeoHash();</span><br>         364:  <span style="background-color: red">      		boolean isEvenBit = false;</span><br>         365:  <span style="background-color: red">      		latBits[0] &lt;&lt;= (MAX_BIT_PRECISION - latBits[1]);</span><br>         366:  <span style="background-color: red">      		lonBits[0] &lt;&lt;= (MAX_BIT_PRECISION - lonBits[1]);</span><br>         367:  <span style="background-color: red">      		double[] latitudeRange = { -90.0, 90.0 };</span><br>         368:  <span style="background-color: red">      		double[] longitudeRange = { -180.0, 180.0 };</span><br>         369:  <span style="background-color: white">      </span><br>         370:  <span style="background-color: red">      		for (int i = 0; i &lt; latBits[1] + lonBits[1]; i++) {</span><br>         371:  <span style="background-color: red">      			if (isEvenBit) {</span><br>         372:  <span style="background-color: red">      				divideRangeDecode(hash, latitudeRange, (latBits[0] &amp; FIRST_BIT_FLAGGED) == FIRST_BIT_FLAGGED);</span><br>         373:  <span style="background-color: red">      				latBits[0] &lt;&lt;= 1;</span><br>         374:  <span style="background-color: white">      			} else {</span><br>         375:  <span style="background-color: red">      				divideRangeDecode(hash, longitudeRange, (lonBits[0] &amp; FIRST_BIT_FLAGGED) == FIRST_BIT_FLAGGED);</span><br>         376:  <span style="background-color: red">      				lonBits[0] &lt;&lt;= 1;</span><br>         377:  <span style="background-color: white">      			}</span><br>         378:  <span style="background-color: red">      			isEvenBit = !isEvenBit;</span><br>         379:  <span style="background-color: white">      		}</span><br>         380:  <span style="background-color: red">      		hash.bits &lt;&lt;= (MAX_BIT_PRECISION - hash.significantBits);</span><br>         381:  <span style="background-color: red">      		setBoundingBox(hash, latitudeRange, longitudeRange);</span><br>         382:  <span style="background-color: red">      		hash.point = hash.boundingBox.getCenter();</span><br>         383:  <span style="background-color: red">      		return hash;</span><br>         384:  <span style="background-color: white">      	}</span><br>         385:  <span style="background-color: white">      </span><br>         386:  <span style="background-color: white">      	public GeoHash getNorthernNeighbour() {</span><br>         387:  <span style="background-color: white">      		long[] latitudeBits = getRightAlignedLatitudeBits();</span><br>         388:  <span style="background-color: white">      		long[] longitudeBits = getRightAlignedLongitudeBits();</span><br>         389:  <span style="background-color: white">      		latitudeBits[0] += 1;</span><br>         390:  <span style="background-color: white">      		latitudeBits[0] = maskLastNBits(latitudeBits[0], latitudeBits[1]);</span><br>         391:  <span style="background-color: white">      		return recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>         392:  <span style="background-color: white">      	}</span><br>         393:  <span style="background-color: white">      </span><br>         394:  <span style="background-color: white">      	public GeoHash getSouthernNeighbour() {</span><br>         395:  <span style="background-color: white">      		long[] latitudeBits = getRightAlignedLatitudeBits();</span><br>         396:  <span style="background-color: white">      		long[] longitudeBits = getRightAlignedLongitudeBits();</span><br>         397:  <span style="background-color: white">      		latitudeBits[0] -= 1;</span><br>         398:  <span style="background-color: white">      		latitudeBits[0] = maskLastNBits(latitudeBits[0], latitudeBits[1]);</span><br>         399:  <span style="background-color: white">      		return recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>         400:  <span style="background-color: white">      	}</span><br>         401:  <span style="background-color: white">      </span><br>         402:  <span style="background-color: white">      	public GeoHash getEasternNeighbour() {</span><br>         403:  <span style="background-color: white">      		long[] latitudeBits = getRightAlignedLatitudeBits();</span><br>         404:  <span style="background-color: white">      		long[] longitudeBits = getRightAlignedLongitudeBits();</span><br>         405:  <span style="background-color: white">      		longitudeBits[0] += 1;</span><br>         406:  <span style="background-color: white">      		longitudeBits[0] = maskLastNBits(longitudeBits[0], longitudeBits[1]);</span><br>         407:  <span style="background-color: white">      		return recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>         408:  <span style="background-color: white">      	}</span><br>         409:  <span style="background-color: white">      </span><br>         410:  <span style="background-color: white">      	public GeoHash getWesternNeighbour() {</span><br>         411:  <span style="background-color: white">      		long[] latitudeBits = getRightAlignedLatitudeBits();</span><br>         412:  <span style="background-color: white">      		long[] longitudeBits = getRightAlignedLongitudeBits();</span><br>         413:  <span style="background-color: white">      		longitudeBits[0] -= 1;</span><br>         414:  <span style="background-color: white">      		longitudeBits[0] = maskLastNBits(longitudeBits[0], longitudeBits[1]);</span><br>         415:  <span style="background-color: white">      		return recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>         416:  <span style="background-color: white">      	}</span><br>         417:  <span style="background-color: white">      </span><br>         418:  <span style="background-color: red">      	protected long[] getRightAlignedLatitudeBits() {</span><br>         419:  <span style="background-color: red">      		long copyOfBits = bits &lt;&lt; 1;</span><br>         420:  <span style="background-color: red">      		long value = extractEverySecondBit(copyOfBits, getNumberOfLatLonBits()[0]);</span><br>         421:  <span style="background-color: red">      		return new long[] { value, getNumberOfLatLonBits()[0] };</span><br>         422:  <span style="background-color: white">      	}</span><br>         423:  <span style="background-color: white">      </span><br>         424:  <span style="background-color: red">      	protected long[] getRightAlignedLongitudeBits() {</span><br>         425:  <span style="background-color: red">      		long copyOfBits = bits;</span><br>         426:  <span style="background-color: red">      		long value = extractEverySecondBit(copyOfBits, getNumberOfLatLonBits()[1]);</span><br>         427:  <span style="background-color: red">      		return new long[] { value, getNumberOfLatLonBits()[1] };</span><br>         428:  <span style="background-color: white">      	}</span><br>         429:  <span style="background-color: white">      </span><br>         430:  <span style="background-color: red">      	private long extractEverySecondBit(long copyOfBits, int numberOfBits) {</span><br>         431:  <span style="background-color: red">      		long value = 0;</span><br>         432:  <span style="background-color: red">      		for (int i = 0; i &lt; numberOfBits; i++) {</span><br>         433:  <span style="background-color: red">      			if ((copyOfBits &amp; FIRST_BIT_FLAGGED) == FIRST_BIT_FLAGGED) {</span><br>         434:  <span style="background-color: cyan">      				value |= 0x1;</span><br>         435:  <span style="background-color: white">      			}</span><br>         436:  <span style="background-color: red">      			value &lt;&lt;= 1;</span><br>         437:  <span style="background-color: red">      			copyOfBits &lt;&lt;= 2;</span><br>         438:  <span style="background-color: white">      		}</span><br>         439:  <span style="background-color: red">      		value &gt;&gt;&gt;= 1;</span><br>         440:  <span style="background-color: red">      		return value;</span><br>         441:  <span style="background-color: white">      	}</span><br>         442:  <span style="background-color: white">      </span><br>         443:  <span style="background-color: red">      	protected int[] getNumberOfLatLonBits() {</span><br>         444:  <span style="background-color: red">      		if (significantBits % 2 == 0) {</span><br>         445:  <span style="background-color: red">      			return new int[] { significantBits / 2, significantBits / 2 };</span><br>         446:  <span style="background-color: white">      		} else {</span><br>         447:  <span style="background-color: red">      			return new int[] { significantBits / 2, significantBits / 2 + 1 };</span><br>         448:  <span style="background-color: white">      		}</span><br>         449:  <span style="background-color: white">      	}</span><br>         450:  <span style="background-color: white">      </span><br>         451:  <span style="background-color: red">      	protected final void addOnBitToEnd() {</span><br>         452:  <span style="background-color: white">      		significantBits++;</span><br>         453:  <span style="background-color: red">      		bits &lt;&lt;= 1;</span><br>         454:  <span style="background-color: red">      		bits = bits | 0x1;</span><br>         455:  <span style="background-color: white">      	}</span><br>         456:  <span style="background-color: white">      </span><br>         457:  <span style="background-color: red">      	protected final void addOffBitToEnd() {</span><br>         458:  <span style="background-color: white">      		significantBits++;</span><br>         459:  <span style="background-color: red">      		bits &lt;&lt;= 1;</span><br>         460:  <span style="background-color: white">      	}</span><br>         461:  <span style="background-color: white">      </span><br>         462:  <span style="background-color: white">      	@Override</span><br>         463:  <span style="background-color: white">      	public String toString() {</span><br>         464:  <span style="background-color: white">      		if (significantBits % 5 == 0) {</span><br>         465:  <span style="background-color: white">      			return String.format("%s -&gt; %s -&gt; %s", padLeft(Long.toBinaryString(bits), 64, "0"), boundingBox, toBase32());</span><br>         466:  <span style="background-color: white">      		} else {</span><br>         467:  <span style="background-color: white">      			return String.format("%s -&gt; %s, bits: %d", padLeft(Long.toBinaryString(bits), 64, "0"), boundingBox, significantBits);</span><br>         468:  <span style="background-color: white">      		}</span><br>         469:  <span style="background-color: white">      	}</span><br>         470:  <span style="background-color: white">      </span><br>         471:  <span style="background-color: white">      	private static String padLeft(String s, int n, String pad) {</span><br>         472:  <span style="background-color: white">      		return String.format("%" + n + "s", s).replace(" ", pad);</span><br>         473:  <span style="background-color: white">      	}</span><br>         474:  <span style="background-color: white">      </span><br>         475:  <span style="background-color: red">      	public String toBinaryString() {</span><br>         476:  <span style="background-color: red">      		StringBuilder bui = new StringBuilder();</span><br>         477:  <span style="background-color: red">      		long bitsCopy = bits;</span><br>         478:  <span style="background-color: red">      		for (int i = 0; i &lt; significantBits; i++) {</span><br>         479:  <span style="background-color: red">      			if ((bitsCopy &amp; FIRST_BIT_FLAGGED) == FIRST_BIT_FLAGGED) {</span><br>         480:  <span style="background-color: cyan">      				bui.append('1');</span><br>         481:  <span style="background-color: white">      			} else {</span><br>         482:  <span style="background-color: red">      				bui.append('0');</span><br>         483:  <span style="background-color: white">      			}</span><br>         484:  <span style="background-color: red">      			bitsCopy &lt;&lt;= 1;</span><br>         485:  <span style="background-color: white">      		}</span><br>         486:  <span style="background-color: red">      		return bui.toString();</span><br>         487:  <span style="background-color: white">      	}</span><br>         488:  <span style="background-color: white">      </span><br>         489:  <span style="background-color: red">      	@Override</span><br>         490:  <span style="background-color: white">      	public boolean equals(Object obj) {</span><br>         491:  <span style="background-color: red">      		if (obj == this) {</span><br>         492:  <span style="background-color: white">      			return true;</span><br>         493:  <span style="background-color: white">      		}</span><br>         494:  <span style="background-color: red">      		if (obj instanceof GeoHash) {</span><br>         495:  <span style="background-color: red">      			GeoHash other = (GeoHash) obj;</span><br>         496:  <span style="background-color: red">      			if (other.significantBits == significantBits &amp;&amp; other.bits == bits) {</span><br>         497:  <span style="background-color: red">      				return true;</span><br>         498:  <span style="background-color: white">      			}</span><br>         499:  <span style="background-color: white">      		}</span><br>         500:  <span style="background-color: white">      		return false;</span><br>         501:  <span style="background-color: white">      	}</span><br>         502:  <span style="background-color: white">      </span><br>         503:  <span style="background-color: white">      	@Override</span><br>         504:  <span style="background-color: white">      	public int hashCode() {</span><br>         505:  <span style="background-color: white">      		int f = 17;</span><br>         506:  <span style="background-color: white">      		f = 31 * f + (int) (bits ^ (bits &gt;&gt;&gt; 32));</span><br>         507:  <span style="background-color: white">      		f = 31 * f + significantBits;</span><br>         508:  <span style="background-color: white">      		return f;</span><br>         509:  <span style="background-color: white">      	}</span><br>         510:  <span style="background-color: white">      </span><br>         511:  <span style="background-color: white">      	/**</span><br>         512:  <span style="background-color: white">      	 * return a long mask for this hashes significant bits.</span><br>         513:  <span style="background-color: white">      	 */</span><br>         514:  <span style="background-color: white">      	private long mask() {</span><br>         515:  <span style="background-color: white">      		if (significantBits == 0) {</span><br>         516:  <span style="background-color: white">      			return 0;</span><br>         517:  <span style="background-color: white">      		} else {</span><br>         518:  <span style="background-color: white">      			long value = FIRST_BIT_FLAGGED;</span><br>         519:  <span style="background-color: white">      			value &gt;&gt;= (significantBits - 1);</span><br>         520:  <span style="background-color: white">      			return value;</span><br>         521:  <span style="background-color: white">      		}</span><br>         522:  <span style="background-color: white">      	}</span><br>         523:  <span style="background-color: white">      </span><br>         524:  <span style="background-color: white">      	private long maskLastNBits(long value, long n) {</span><br>         525:  <span style="background-color: white">      		long mask = 0xffffffffffffffffl;</span><br>         526:  <span style="background-color: white">      		mask &gt;&gt;&gt;= (MAX_BIT_PRECISION - n);</span><br>         527:  <span style="background-color: white">      		return value &amp; mask;</span><br>         528:  <span style="background-color: white">      	}</span><br>         529:  <span style="background-color: white">      </span><br>         530:  <span style="background-color: white">      	@Override</span><br>         531:  <span style="background-color: white">      	public int compareTo(GeoHash o) {</span><br>         532:  <span style="background-color: white">      		int bitsCmp = Long.compare(bits ^ FIRST_BIT_FLAGGED, o.bits ^ FIRST_BIT_FLAGGED);</span><br>         533:  <span style="background-color: white">      		if (bitsCmp != 0) {</span><br>         534:  <span style="background-color: white">      			return bitsCmp;</span><br>         535:  <span style="background-color: white">      		} else {</span><br>         536:  <span style="background-color: white">      			return Integer.compare(significantBits, o.significantBits);</span><br>         537:  <span style="background-color: white">      		}</span><br>         538:  <span style="background-color: white">      	}</span><br>         539:  <span style="background-color: white">      }</span><br></pre> </code> 
   </div> 
   <div class="column"> 
    <h2>Patched Code:</h2> <code> <pre id="patched-trace">        1-&gt;N:  <span style="background-color: white">      /*</span><br>        2-&gt;N:  <span style="background-color: white">       * Copyright 2010, Silvio Heuberger @ IFS www.ifs.hsr.ch</span><br>        3-&gt;N:  <span style="background-color: white">       *</span><br>        4-&gt;N:  <span style="background-color: white">       * This code is release under the Apache License 2.0.</span><br>        5-&gt;N:  <span style="background-color: white">       * You should have received a copy of the license</span><br>        6-&gt;N:  <span style="background-color: white">       * in the LICENSE file. If you have not, see</span><br>        7-&gt;N:  <span style="background-color: white">       * http://www.apache.org/licenses/LICENSE-2.0</span><br>        8-&gt;N:  <span style="background-color: white">       */</span><br>        9-&gt;N:  <span style="background-color: white">      package ch.hsr.geohash;</span><br>       10-&gt;N:  <span style="background-color: white">      </span><br>       11-&gt;N:  <span style="background-color: white">      import java.io.Serializable;</span><br>       12-&gt;N:  <span style="background-color: white">      import java.util.Arrays;</span><br>       13-&gt;N:  <span style="background-color: white">      </span><br>      14-&gt;15:  <span style="background-color: white">      @SuppressWarnings("javadoc")</span><br>       15-&gt;N:  <span style="background-color: white">      public final class GeoHash implements Comparable
       <geohash>
        , Serializable {
       </geohash></span><br>      16-&gt;17:  <span style="background-color: white">      	public static final int MAX_BIT_PRECISION = 64;</span><br>      17-&gt;18:  <span style="background-color: white">      	public static final int MAX_CHARACTER_PRECISION = 12;</span><br>       18-&gt;N:  <span style="background-color: white">      	</span><br>      19-&gt;20:  <span style="background-color: white">      	private static final long serialVersionUID = -8553214249630252175L;</span><br>      20-&gt;21:  <span style="background-color: white">      	private static final int[] BITS = { 16, 8, 4, 2, 1 };</span><br>      21-&gt;22:  <span style="background-color: white">      	private static final int BASE32_BITS = 5;</span><br>      22-&gt;23:  <span style="background-color: white">      	public static final long FIRST_BIT_FLAGGED = 0x8000000000000000l;</span><br>      23-&gt;24:  <span style="background-color: white">      	private static final char[] base32 = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'b', 'c', 'd', 'e', 'f',</span><br>      24-&gt;25:  <span style="background-color: white">      			'g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };</span><br>       25-&gt;N:  <span style="background-color: white">      </span><br>       26-&gt;U:  <span style="background-color: yellow">      	private static final int[] decodeArray = new int['z' + 1];</span><br>       27-&gt;N:  <span style="background-color: white">      </span><br>       28-&gt;N:  <span style="background-color: white">      	static {</span><br>       29-&gt;U:  <span style="background-color: yellow">      		Arrays.fill(decodeArray, -1);</span><br>      30-&gt;30:  <span style="background-color: white">      		int sz = base32.length;</span><br>      31-&gt;31:  <span style="background-color: white">      		for (int i = 0; i &lt; sz; i++) {</span><br>       32-&gt;U:  <span style="background-color: yellow">      			decodeArray[base32[i]] = i;</span><br>       33-&gt;N:  <span style="background-color: white">      		}</span><br>       34-&gt;N:  <span style="background-color: white">      	}</span><br>       35-&gt;N:  <span style="background-color: white">      </span><br>      36-&gt;36:  <span style="background-color: white">      	protected long bits = 0;</span><br>      37-&gt;37:  <span style="background-color: white">      	private WGS84Point point;</span><br>       38-&gt;N:  <span style="background-color: white">      </span><br>      39-&gt;39:  <span style="background-color: white">      	private BoundingBox boundingBox;</span><br>       40-&gt;N:  <span style="background-color: white">      </span><br>      41-&gt;41:  <span style="background-color: white">      	protected byte significantBits = 0;</span><br>       42-&gt;N:  <span style="background-color: white">      </span><br>       43-&gt;N:  <span style="background-color: white">      	protected GeoHash() {</span><br>       44-&gt;N:  <span style="background-color: white">      	}</span><br>       45-&gt;N:  <span style="background-color: white">      </span><br>       46-&gt;N:  <span style="background-color: white">      	/**</span><br>       47-&gt;N:  <span style="background-color: white">      	 * This method uses the given number of characters as the desired precision</span><br>       48-&gt;N:  <span style="background-color: white">      	 * value. The hash can only be 64bits long, thus a maximum precision of 12</span><br>       49-&gt;N:  <span style="background-color: white">      	 * characters can be achieved.</span><br>       50-&gt;N:  <span style="background-color: white">      	 */</span><br>      51-&gt;51:  <span style="background-color: cyan">      	public static GeoHash withCharacterPrecision(double latitude, double longitude, int numberOfCharacters) {</span><br>      52-&gt;52:  <span style="background-color: cyan">      		if (numberOfCharacters &gt; MAX_CHARACTER_PRECISION) {</span><br>      53-&gt;53:  <span style="background-color: white">      			throw new IllegalArgumentException("A geohash can only be " + MAX_CHARACTER_PRECISION + " character long.");</span><br>       54-&gt;N:  <span style="background-color: white">      		}</span><br>      55-&gt;55:  <span style="background-color: cyan">      		int desiredPrecision = (numberOfCharacters * 5 &lt;= 60) ? numberOfCharacters * 5 : 60;</span><br>      56-&gt;56:  <span style="background-color: cyan">      		return new GeoHash(latitude, longitude, desiredPrecision);</span><br>       57-&gt;N:  <span style="background-color: white">      	}</span><br>       58-&gt;N:  <span style="background-color: white">      </span><br>       59-&gt;N:  <span style="background-color: white">      	/**</span><br>       60-&gt;N:  <span style="background-color: white">      	 * create a new {@link GeoHash} with the given number of bits accuracy. This</span><br>       61-&gt;N:  <span style="background-color: white">      	 * at the same time defines this hash's bounding box.</span><br>       62-&gt;N:  <span style="background-color: white">      	 */</span><br>      63-&gt;63:  <span style="background-color: white">      	public static GeoHash withBitPrecision(double latitude, double longitude, int numberOfBits) {</span><br>      64-&gt;64:  <span style="background-color: white">      		if (numberOfBits &gt; MAX_BIT_PRECISION) {</span><br>      65-&gt;65:  <span style="background-color: white">      			throw new IllegalArgumentException("A Geohash can only be " + MAX_BIT_PRECISION + " bits long!");</span><br>       66-&gt;N:  <span style="background-color: white">      		}</span><br>      67-&gt;67:  <span style="background-color: white">      		if (Math.abs(latitude) &gt; 90.0 || Math.abs(longitude) &gt; 180.0) {</span><br>      68-&gt;68:  <span style="background-color: white">      			throw new IllegalArgumentException("Can't have lat/lon values out of (-90,90)/(-180/180)");</span><br>       69-&gt;N:  <span style="background-color: white">      		}</span><br>      70-&gt;70:  <span style="background-color: white">      		return new GeoHash(latitude, longitude, numberOfBits);</span><br>       71-&gt;N:  <span style="background-color: white">      	}</span><br>       72-&gt;N:  <span style="background-color: white">      </span><br>      73-&gt;73:  <span style="background-color: cyan">      	public static GeoHash fromBinaryString(String binaryString) {</span><br>      74-&gt;74:  <span style="background-color: cyan">      		GeoHash geohash = new GeoHash();</span><br>      75-&gt;75:  <span style="background-color: cyan">      		for (int i = 0; i &lt; binaryString.length(); i++) {</span><br>      76-&gt;76:  <span style="background-color: cyan">      			if (binaryString.charAt(i) == '1') {</span><br>      77-&gt;77:  <span style="background-color: red">      				geohash.addOnBitToEnd();</span><br>      78-&gt;78:  <span style="background-color: cyan">      			} else if (binaryString.charAt(i) == '0') {</span><br>      79-&gt;79:  <span style="background-color: cyan">      				geohash.addOffBitToEnd();</span><br>       80-&gt;N:  <span style="background-color: white">      			} else {</span><br>      81-&gt;81:  <span style="background-color: white">      				throw new IllegalArgumentException(binaryString + " is not a valid geohash as a binary string");</span><br>       82-&gt;N:  <span style="background-color: white">      			}</span><br>       83-&gt;N:  <span style="background-color: white">      		}</span><br>      84-&gt;84:  <span style="background-color: cyan">      		geohash.bits &lt;&lt;= (MAX_BIT_PRECISION - geohash.significantBits);</span><br>      85-&gt;85:  <span style="background-color: cyan">      		long[] latitudeBits = geohash.getRightAlignedLatitudeBits();</span><br>      86-&gt;86:  <span style="background-color: cyan">      		long[] longitudeBits = geohash.getRightAlignedLongitudeBits();</span><br>      87-&gt;87:  <span style="background-color: cyan">      		return geohash.recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>       88-&gt;N:  <span style="background-color: white">      	}</span><br>       89-&gt;N:  <span style="background-color: white">      </span><br>       90-&gt;N:  <span style="background-color: white">      	/**</span><br>       91-&gt;N:  <span style="background-color: white">      	 * build a new {@link GeoHash} from a base32-encoded {@link String}.<br></span><br>       92-&gt;N:  <span style="background-color: white">      	 * This will also set up the hashes bounding box and other values, so it can</span><br>       93-&gt;N:  <span style="background-color: white">      	 * also be used with functions like within().</span><br>       94-&gt;N:  <span style="background-color: white">      	 */</span><br>      95-&gt;95:  <span style="background-color: cyan">      	public static GeoHash fromGeohashString(String geohash) {</span><br>      96-&gt;96:  <span style="background-color: cyan">      		double[] latitudeRange = { -90.0, 90.0 };</span><br>      97-&gt;97:  <span style="background-color: cyan">      		double[] longitudeRange = { -180.0, 180.0 };</span><br>       98-&gt;N:  <span style="background-color: white">      </span><br>      99-&gt;99:  <span style="background-color: cyan">      		boolean isEvenBit = true;</span><br>    100-&gt;100:  <span style="background-color: cyan">      		GeoHash hash = new GeoHash();</span><br>      101-&gt;N:  <span style="background-color: white">      </span><br>    102-&gt;102:  <span style="background-color: cyan">      		for (int i = 0; i &lt; geohash.length(); i++) {</span><br>      103-&gt;U:  <span style="background-color: yellow">      			char c = geohash.charAt(i);</span><br>      104-&gt;U:  <span style="background-color: yellow">      			int cd;</span><br>      105-&gt;U:  <span style="background-color: yellow">      			if (c &gt;= decodeArray.length || (cd = decodeArray[c]) &lt; 0) {</span><br>      106-&gt;U:  <span style="background-color: yellow">      				throw new IllegalArgumentException("Invalid character character '" + c + "' in geohash '"+geohash+"'!");</span><br>      107-&gt;U:  <span style="background-color: yellow">      			}</span><br>      108-&gt;U:  <span style="background-color: yellow">      			for (int j = 0; j &lt; BASE32_BITS; j++) {</span><br>      109-&gt;U:  <span style="background-color: yellow">      				int mask = BITS[j];</span><br>      110-&gt;U:  <span style="background-color: yellow">      				if (isEvenBit) {</span><br>      111-&gt;U:  <span style="background-color: yellow">      					divideRangeDecode(hash, longitudeRange, (cd &amp; mask) != 0);</span><br>      112-&gt;U:  <span style="background-color: yellow">      				} else {</span><br>      113-&gt;U:  <span style="background-color: yellow">      					divideRangeDecode(hash, latitudeRange, (cd &amp; mask) != 0);</span><br>      114-&gt;U:  <span style="background-color: yellow">      				}</span><br>      115-&gt;U:  <span style="background-color: yellow">      				isEvenBit = !isEvenBit;</span><br>      116-&gt;U:  <span style="background-color: yellow">      			}</span><br>      117-&gt;N:  <span style="background-color: white">      		}</span><br>      118-&gt;N:  <span style="background-color: white">      </span><br>    119-&gt;119:  <span style="background-color: cyan">      		double latitude = (latitudeRange[0] + latitudeRange[1]) / 2;</span><br>    120-&gt;120:  <span style="background-color: cyan">      		double longitude = (longitudeRange[0] + longitudeRange[1]) / 2;</span><br>      121-&gt;N:  <span style="background-color: white">      </span><br>    122-&gt;122:  <span style="background-color: cyan">      		hash.point = new WGS84Point(latitude, longitude);</span><br>    123-&gt;123:  <span style="background-color: cyan">      		setBoundingBox(hash, latitudeRange, longitudeRange);</span><br>    124-&gt;124:  <span style="background-color: cyan">      		hash.bits &lt;&lt;= (MAX_BIT_PRECISION - hash.significantBits);</span><br>    125-&gt;125:  <span style="background-color: cyan">      		return hash;</span><br>      126-&gt;N:  <span style="background-color: white">      	}</span><br>      127-&gt;N:  <span style="background-color: white">      </span><br>    128-&gt;128:  <span style="background-color: white">      	public static GeoHash fromLongValue(long hashVal, int significantBits) {</span><br>    129-&gt;129:  <span style="background-color: white">      		double[] latitudeRange = { -90.0, 90.0 };</span><br>    130-&gt;130:  <span style="background-color: white">      		double[] longitudeRange = { -180.0, 180.0 };</span><br>      131-&gt;N:  <span style="background-color: white">      </span><br>    132-&gt;132:  <span style="background-color: white">      		boolean isEvenBit = true;</span><br>    133-&gt;133:  <span style="background-color: white">      		GeoHash hash = new GeoHash();</span><br>      134-&gt;N:  <span style="background-color: white">      </span><br>    135-&gt;135:  <span style="background-color: white">      		String binaryString = Long.toBinaryString(hashVal);</span><br>    136-&gt;136:  <span style="background-color: white">      		while (binaryString.length() &lt; MAX_BIT_PRECISION) {</span><br>    137-&gt;137:  <span style="background-color: white">      			binaryString = "0" + binaryString;</span><br>      138-&gt;N:  <span style="background-color: white">      		}</span><br>    139-&gt;139:  <span style="background-color: white">      		for (int j = 0; j &lt; significantBits; j++) {</span><br>    140-&gt;140:  <span style="background-color: white">      			if (isEvenBit) {</span><br>    141-&gt;141:  <span style="background-color: white">      				divideRangeDecode(hash, longitudeRange, binaryString.charAt(j) != '0');</span><br>      142-&gt;N:  <span style="background-color: white">      			} else {</span><br>    143-&gt;143:  <span style="background-color: white">      				divideRangeDecode(hash, latitudeRange, binaryString.charAt(j) != '0');</span><br>      144-&gt;N:  <span style="background-color: white">      			}</span><br>    145-&gt;145:  <span style="background-color: white">      			isEvenBit = !isEvenBit;</span><br>      146-&gt;N:  <span style="background-color: white">      		}</span><br>      147-&gt;N:  <span style="background-color: white">      </span><br>    148-&gt;148:  <span style="background-color: white">      		double latitude = (latitudeRange[0] + latitudeRange[1]) / 2;</span><br>    149-&gt;149:  <span style="background-color: white">      		double longitude = (longitudeRange[0] + longitudeRange[1]) / 2;</span><br>      150-&gt;N:  <span style="background-color: white">      </span><br>    151-&gt;151:  <span style="background-color: white">      		hash.point = new WGS84Point(latitude, longitude);</span><br>    152-&gt;152:  <span style="background-color: white">      		setBoundingBox(hash, latitudeRange, longitudeRange);</span><br>    153-&gt;153:  <span style="background-color: white">      		hash.bits &lt;&lt;= (MAX_BIT_PRECISION - hash.significantBits);</span><br>    154-&gt;154:  <span style="background-color: white">      		return hash;</span><br>      155-&gt;N:  <span style="background-color: white">      	}</span><br>      156-&gt;N:  <span style="background-color: white">      </span><br>      157-&gt;N:  <span style="background-color: white">      	/**</span><br>      158-&gt;N:  <span style="background-color: white">      	 * This method uses the given number of characters as the desired precision</span><br>      159-&gt;N:  <span style="background-color: white">      	 * value. The hash can only be 64bits long, thus a maximum precision of 12</span><br>      160-&gt;N:  <span style="background-color: white">      	 * characters can be achieved.</span><br>      161-&gt;N:  <span style="background-color: white">      	 */</span><br>    162-&gt;162:  <span style="background-color: white">      	public static String geoHashStringWithCharacterPrecision(double latitude, double longitude, int numberOfCharacters) {</span><br>    163-&gt;163:  <span style="background-color: white">      		GeoHash hash = withCharacterPrecision(latitude, longitude, numberOfCharacters);</span><br>    164-&gt;164:  <span style="background-color: white">      		return hash.toBase32();</span><br>      165-&gt;N:  <span style="background-color: white">      	}</span><br>      166-&gt;N:  <span style="background-color: white">      </span><br>    167-&gt;167:  <span style="background-color: cyan">      	private GeoHash(double latitude, double longitude, int desiredPrecision) {</span><br>    168-&gt;168:  <span style="background-color: cyan">      		point = new WGS84Point(latitude, longitude);</span><br>    169-&gt;169:  <span style="background-color: cyan">      		desiredPrecision = Math.min(desiredPrecision, MAX_BIT_PRECISION);</span><br>      170-&gt;N:  <span style="background-color: white">      </span><br>    171-&gt;171:  <span style="background-color: cyan">      		boolean isEvenBit = true;</span><br>    172-&gt;172:  <span style="background-color: cyan">      		double[] latitudeRange = { -90, 90 };</span><br>    173-&gt;173:  <span style="background-color: cyan">      		double[] longitudeRange = { -180, 180 };</span><br>      174-&gt;N:  <span style="background-color: white">      </span><br>    175-&gt;175:  <span style="background-color: cyan">      		while (significantBits &lt; desiredPrecision) {</span><br>    176-&gt;176:  <span style="background-color: cyan">      			if (isEvenBit) {</span><br>    177-&gt;177:  <span style="background-color: cyan">      				divideRangeEncode(longitude, longitudeRange);</span><br>      178-&gt;N:  <span style="background-color: white">      			} else {</span><br>    179-&gt;179:  <span style="background-color: cyan">      				divideRangeEncode(latitude, latitudeRange);</span><br>      180-&gt;N:  <span style="background-color: white">      			}</span><br>    181-&gt;181:  <span style="background-color: cyan">      			isEvenBit = !isEvenBit;</span><br>      182-&gt;N:  <span style="background-color: white">      		}</span><br>      183-&gt;N:  <span style="background-color: white">      </span><br>    184-&gt;184:  <span style="background-color: cyan">      		setBoundingBox(this, latitudeRange, longitudeRange);</span><br>    185-&gt;185:  <span style="background-color: cyan">      		bits &lt;&lt;= (MAX_BIT_PRECISION - desiredPrecision);</span><br>      186-&gt;N:  <span style="background-color: white">      	}</span><br>      187-&gt;N:  <span style="background-color: white">      </span><br>    188-&gt;188:  <span style="background-color: cyan">      	private static void setBoundingBox(GeoHash hash, double[] latitudeRange, double[] longitudeRange) {</span><br>    189-&gt;189:  <span style="background-color: cyan">      		hash.boundingBox = new BoundingBox(latitudeRange[0], latitudeRange[1], longitudeRange[0], longitudeRange[1]);</span><br>      190-&gt;N:  <span style="background-color: white">      	}</span><br>      191-&gt;N:  <span style="background-color: white">      </span><br>    192-&gt;192:  <span style="background-color: white">      	public GeoHash next(int step) {</span><br>    193-&gt;193:  <span style="background-color: white">      		return fromOrd(ord() + step, significantBits);</span><br>      194-&gt;N:  <span style="background-color: white">      	}</span><br>      195-&gt;N:  <span style="background-color: white">      </span><br>    196-&gt;196:  <span style="background-color: white">      	public GeoHash next() {</span><br>    197-&gt;197:  <span style="background-color: white">      		return next(1);</span><br>      198-&gt;N:  <span style="background-color: white">      	}</span><br>      199-&gt;N:  <span style="background-color: white">      </span><br>    200-&gt;200:  <span style="background-color: white">      	public GeoHash prev() {</span><br>    201-&gt;201:  <span style="background-color: white">      		return next(-1);</span><br>      202-&gt;N:  <span style="background-color: white">      	}</span><br>      203-&gt;N:  <span style="background-color: white">      </span><br>    204-&gt;204:  <span style="background-color: white">      	public long ord() {</span><br>    205-&gt;205:  <span style="background-color: white">      		int insignificantBits = MAX_BIT_PRECISION - significantBits;</span><br>    206-&gt;206:  <span style="background-color: white">      		return bits &gt;&gt;&gt; insignificantBits;</span><br>      207-&gt;N:  <span style="background-color: white">      	}</span><br>      208-&gt;N:  <span style="background-color: white">      </span><br>      209-&gt;N:  <span style="background-color: white">      	/**</span><br>      210-&gt;N:  <span style="background-color: white">      	 * Returns the number of characters that represent this hash.</span><br>      211-&gt;N:  <span style="background-color: white">      	 * </span><br>      212-&gt;N:  <span style="background-color: white">      	 * @throws IllegalStateException</span><br>      213-&gt;N:  <span style="background-color: white">      	 *             when the hash cannot be encoded in base32, i.e. when the</span><br>      214-&gt;N:  <span style="background-color: white">      	 *             precision is not a multiple of 5.</span><br>      215-&gt;N:  <span style="background-color: white">      	 */</span><br>    216-&gt;216:  <span style="background-color: white">      	public int getCharacterPrecision() {</span><br>    217-&gt;217:  <span style="background-color: white">      		if (significantBits % 5 != 0) {</span><br>      218-&gt;N:  <span style="background-color: white">      			throw new IllegalStateException(</span><br>    219-&gt;219:  <span style="background-color: white">      					"precision of GeoHash is not divisble by 5: " + this);</span><br>      220-&gt;N:  <span style="background-color: white">      		}</span><br>    221-&gt;221:  <span style="background-color: white">      		return significantBits / 5;</span><br>      222-&gt;N:  <span style="background-color: white">      	}</span><br>      223-&gt;N:  <span style="background-color: white">      </span><br>    224-&gt;224:  <span style="background-color: white">      	public static GeoHash fromOrd(long ord, int significantBits) {</span><br>    225-&gt;225:  <span style="background-color: white">      		int insignificantBits = MAX_BIT_PRECISION - significantBits;</span><br>    226-&gt;226:  <span style="background-color: white">      		return fromLongValue(ord &lt;&lt; insignificantBits, significantBits);</span><br>      227-&gt;N:  <span style="background-color: white">      	}</span><br>      228-&gt;N:  <span style="background-color: white">      </span><br>      229-&gt;N:  <span style="background-color: white">      	/**</span><br>      230-&gt;N:  <span style="background-color: white">      	 * Counts the number of geohashes contained between the two (ie how many</span><br>      231-&gt;N:  <span style="background-color: white">      	 * times next() is called to increment from one to two) This value depends</span><br>      232-&gt;N:  <span style="background-color: white">      	 * on the number of significant bits.</span><br>      233-&gt;N:  <span style="background-color: white">      	 * </span><br>      234-&gt;N:  <span style="background-color: white">      	 * @param one</span><br>      235-&gt;N:  <span style="background-color: white">      	 * @param two</span><br>      236-&gt;N:  <span style="background-color: white">      	 * @return number of steps</span><br>      237-&gt;N:  <span style="background-color: white">      	 */</span><br>    238-&gt;238:  <span style="background-color: white">      	public static long stepsBetween(GeoHash one, GeoHash two) {</span><br>    239-&gt;239:  <span style="background-color: white">      		if (one.significantBits() != two.significantBits()) {</span><br>      240-&gt;N:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>    241-&gt;241:  <span style="background-color: white">      					"It is only valid to compare the number of steps between two hashes if they have the same number of significant bits");</span><br>      242-&gt;N:  <span style="background-color: white">      		}</span><br>    243-&gt;243:  <span style="background-color: white">      		return two.ord() - one.ord();</span><br>      244-&gt;N:  <span style="background-color: white">      	}</span><br>      245-&gt;N:  <span style="background-color: white">      </span><br>    246-&gt;246:  <span style="background-color: cyan">      	private void divideRangeEncode(double value, double[] range) {</span><br>    247-&gt;247:  <span style="background-color: cyan">      		double mid = (range[0] + range[1]) / 2;</span><br>    248-&gt;248:  <span style="background-color: cyan">      		if (value &gt;= mid) {</span><br>      249-&gt;N:  <span style="background-color: white">      			addOnBitToEnd();</span><br>    250-&gt;250:  <span style="background-color: cyan">      			range[0] = mid;</span><br>      251-&gt;N:  <span style="background-color: white">      		} else {</span><br>      252-&gt;N:  <span style="background-color: white">      			addOffBitToEnd();</span><br>    253-&gt;253:  <span style="background-color: cyan">      			range[1] = mid;</span><br>      254-&gt;N:  <span style="background-color: white">      		}</span><br>      255-&gt;N:  <span style="background-color: white">      	}</span><br>      256-&gt;N:  <span style="background-color: white">      </span><br>    257-&gt;257:  <span style="background-color: cyan">      	private static void divideRangeDecode(GeoHash hash, double[] range, boolean b) {</span><br>    258-&gt;258:  <span style="background-color: cyan">      		double mid = (range[0] + range[1]) / 2;</span><br>    259-&gt;259:  <span style="background-color: cyan">      		if (b) {</span><br>    260-&gt;260:  <span style="background-color: cyan">      			hash.addOnBitToEnd();</span><br>    261-&gt;261:  <span style="background-color: cyan">      			range[0] = mid;</span><br>      262-&gt;N:  <span style="background-color: white">      		} else {</span><br>    263-&gt;263:  <span style="background-color: cyan">      			hash.addOffBitToEnd();</span><br>    264-&gt;264:  <span style="background-color: cyan">      			range[1] = mid;</span><br>      265-&gt;N:  <span style="background-color: white">      		}</span><br>      266-&gt;N:  <span style="background-color: white">      	}</span><br>      267-&gt;N:  <span style="background-color: white">      </span><br>      268-&gt;N:  <span style="background-color: white">      	/**</span><br>      269-&gt;N:  <span style="background-color: white">      	 * returns the 8 adjacent hashes for this one. They are in the following</span><br>      270-&gt;N:  <span style="background-color: white">      	 * order:<br></span><br>      271-&gt;N:  <span style="background-color: white">      	 * N, NE, E, SE, S, SW, W, NW</span><br>      272-&gt;N:  <span style="background-color: white">      	 */</span><br>    273-&gt;273:  <span style="background-color: white">      	public GeoHash[] getAdjacent() {</span><br>    274-&gt;274:  <span style="background-color: white">      		GeoHash northern = getNorthernNeighbour();</span><br>    275-&gt;275:  <span style="background-color: white">      		GeoHash eastern = getEasternNeighbour();</span><br>    276-&gt;276:  <span style="background-color: white">      		GeoHash southern = getSouthernNeighbour();</span><br>    277-&gt;277:  <span style="background-color: white">      		GeoHash western = getWesternNeighbour();</span><br>    278-&gt;278:  <span style="background-color: white">      		return new GeoHash[] { northern, northern.getEasternNeighbour(), eastern, southern.getEasternNeighbour(),</span><br>    279-&gt;279:  <span style="background-color: white">      				southern,</span><br>    280-&gt;280:  <span style="background-color: white">      				southern.getWesternNeighbour(), western, northern.getWesternNeighbour() };</span><br>      281-&gt;N:  <span style="background-color: white">      	}</span><br>      282-&gt;N:  <span style="background-color: white">      </span><br>      283-&gt;N:  <span style="background-color: white">      	/**</span><br>      284-&gt;N:  <span style="background-color: white">      	 * how many significant bits are there in this {@link GeoHash}?</span><br>      285-&gt;N:  <span style="background-color: white">      	 */</span><br>    286-&gt;286:  <span style="background-color: white">      	public int significantBits() {</span><br>      287-&gt;N:  <span style="background-color: white">      		return significantBits;</span><br>      288-&gt;N:  <span style="background-color: white">      	}</span><br>      289-&gt;N:  <span style="background-color: white">      </span><br>    290-&gt;290:  <span style="background-color: white">      	public long longValue() {</span><br>      291-&gt;N:  <span style="background-color: white">      		return bits;</span><br>      292-&gt;N:  <span style="background-color: white">      	}</span><br>      293-&gt;N:  <span style="background-color: white">      </span><br>      294-&gt;N:  <span style="background-color: white">      	/**</span><br>      295-&gt;N:  <span style="background-color: white">      	 * get the base32 string for this {@link GeoHash}.<br></span><br>      296-&gt;N:  <span style="background-color: white">      	 * this method only makes sense, if this hash has a multiple of 5</span><br>      297-&gt;N:  <span style="background-color: white">      	 * significant bits.</span><br>      298-&gt;N:  <span style="background-color: white">      	 * </span><br>      299-&gt;N:  <span style="background-color: white">      	 * @throws IllegalStateException</span><br>      300-&gt;N:  <span style="background-color: white">      	 *             when the number of significant bits is not a multiple of 5.</span><br>      301-&gt;N:  <span style="background-color: white">      	 */</span><br>    302-&gt;302:  <span style="background-color: cyan">      	public String toBase32() {</span><br>    303-&gt;303:  <span style="background-color: cyan">      		if (significantBits % 5 != 0) {</span><br>    304-&gt;304:  <span style="background-color: white">      			throw new IllegalStateException("Cannot convert a geohash to base32 if the precision is not a multiple of 5.");</span><br>      305-&gt;N:  <span style="background-color: white">      		}</span><br>    306-&gt;306:  <span style="background-color: cyan">      		StringBuilder buf = new StringBuilder();</span><br>      307-&gt;N:  <span style="background-color: white">      </span><br>    308-&gt;308:  <span style="background-color: cyan">      		long firstFiveBitsMask = 0xf800000000000000l;</span><br>    309-&gt;309:  <span style="background-color: cyan">      		long bitsCopy = bits;</span><br>    310-&gt;310:  <span style="background-color: cyan">      		int partialChunks = (int) Math.ceil(((double) significantBits / 5));</span><br>      311-&gt;N:  <span style="background-color: white">      </span><br>    312-&gt;312:  <span style="background-color: cyan">      		for (int i = 0; i &lt; partialChunks; i++) {</span><br>    313-&gt;313:  <span style="background-color: cyan">      			int pointer = (int) ((bitsCopy &amp; firstFiveBitsMask) &gt;&gt;&gt; 59);</span><br>    314-&gt;314:  <span style="background-color: cyan">      			buf.append(base32[pointer]);</span><br>    315-&gt;315:  <span style="background-color: cyan">      			bitsCopy &lt;&lt;= 5;</span><br>      316-&gt;N:  <span style="background-color: white">      		}</span><br>    317-&gt;317:  <span style="background-color: cyan">      		return buf.toString();</span><br>      318-&gt;N:  <span style="background-color: white">      	}</span><br>      319-&gt;N:  <span style="background-color: white">      </span><br>      320-&gt;N:  <span style="background-color: white">      	/**</span><br>      321-&gt;N:  <span style="background-color: white">      	 * returns true iff this is within the given geohash bounding box.</span><br>      322-&gt;N:  <span style="background-color: white">      	 */</span><br>    323-&gt;323:  <span style="background-color: white">      	public boolean within(GeoHash boundingBox) {</span><br>    324-&gt;324:  <span style="background-color: white">      		return (bits &amp; boundingBox.mask()) == boundingBox.bits;</span><br>      325-&gt;N:  <span style="background-color: white">      	}</span><br>      326-&gt;N:  <span style="background-color: white">      </span><br>      327-&gt;N:  <span style="background-color: white">      	/**</span><br>      328-&gt;N:  <span style="background-color: white">      	 * find out if the given point lies within this hashes bounding box.<br></span><br>      329-&gt;N:  <span style="background-color: white">      	 * <i>Note: this operation checks the bounding boxes coordinates, i.e. does</i></span><br>      330-&gt;N:  <span style="background-color: white">      	 * not use the {@link GeoHash}s special abilities.s</span><br>      331-&gt;N:  <span style="background-color: white">      	 */</span><br>    332-&gt;332:  <span style="background-color: white">      	public boolean contains(WGS84Point point) {</span><br>    333-&gt;333:  <span style="background-color: white">      		return boundingBox.contains(point);</span><br>      334-&gt;N:  <span style="background-color: white">      	}</span><br>      335-&gt;N:  <span style="background-color: white">      </span><br>      336-&gt;N:  <span style="background-color: white">      	/**</span><br>      337-&gt;N:  <span style="background-color: white">      	 * returns the {@link WGS84Point} that was originally used to set up this.<br></span><br>      338-&gt;N:  <span style="background-color: white">      	 * If it was built from a base32-{@link String}, this is the center point of</span><br>      339-&gt;N:  <span style="background-color: white">      	 * the bounding box.</span><br>      340-&gt;N:  <span style="background-color: white">      	 */</span><br>    341-&gt;341:  <span style="background-color: white">      	public WGS84Point getOriginatingPoint() {</span><br>      342-&gt;N:  <span style="background-color: white">      		return point;</span><br>      343-&gt;N:  <span style="background-color: white">      	}</span><br>      344-&gt;N:  <span style="background-color: white">      </span><br>      345-&gt;N:  <span style="background-color: white">      	/**</span><br>      346-&gt;N:  <span style="background-color: white">      	 * return the center of this {@link GeoHash}s bounding box. this is rarely</span><br>      347-&gt;N:  <span style="background-color: white">      	 * the same point that was used to build the hash.</span><br>      348-&gt;N:  <span style="background-color: white">      	 */</span><br>      349-&gt;N:  <span style="background-color: white">      	// TODO: make sure this method works as intented for corner cases!</span><br>    350-&gt;350:  <span style="background-color: cyan">      	public WGS84Point getBoundingBoxCenter() {</span><br>      351-&gt;N:  <span style="background-color: white">      		return boundingBox.getCenter();</span><br>      352-&gt;N:  <span style="background-color: white">      	}</span><br>      353-&gt;N:  <span style="background-color: white">      </span><br>    354-&gt;354:  <span style="background-color: cyan">      	public BoundingBox getBoundingBox() {</span><br>      355-&gt;N:  <span style="background-color: white">      		return boundingBox;</span><br>      356-&gt;N:  <span style="background-color: white">      	}</span><br>      357-&gt;N:  <span style="background-color: white">      </span><br>    358-&gt;358:  <span style="background-color: white">      	public boolean enclosesCircleAroundPoint(WGS84Point point, double radius) {</span><br>    359-&gt;359:  <span style="background-color: white">      		return false;</span><br>      360-&gt;N:  <span style="background-color: white">      	}</span><br>      361-&gt;N:  <span style="background-color: white">      </span><br>    362-&gt;362:  <span style="background-color: cyan">      	protected GeoHash recombineLatLonBitsToHash(long[] latBits, long[] lonBits) {</span><br>    363-&gt;363:  <span style="background-color: cyan">      		GeoHash hash = new GeoHash();</span><br>    364-&gt;364:  <span style="background-color: cyan">      		boolean isEvenBit = false;</span><br>    365-&gt;365:  <span style="background-color: cyan">      		latBits[0] &lt;&lt;= (MAX_BIT_PRECISION - latBits[1]);</span><br>    366-&gt;366:  <span style="background-color: cyan">      		lonBits[0] &lt;&lt;= (MAX_BIT_PRECISION - lonBits[1]);</span><br>    367-&gt;367:  <span style="background-color: cyan">      		double[] latitudeRange = { -90.0, 90.0 };</span><br>    368-&gt;368:  <span style="background-color: cyan">      		double[] longitudeRange = { -180.0, 180.0 };</span><br>      369-&gt;N:  <span style="background-color: white">      </span><br>    370-&gt;370:  <span style="background-color: cyan">      		for (int i = 0; i &lt; latBits[1] + lonBits[1]; i++) {</span><br>    371-&gt;371:  <span style="background-color: cyan">      			if (isEvenBit) {</span><br>    372-&gt;372:  <span style="background-color: cyan">      				divideRangeDecode(hash, latitudeRange, (latBits[0] &amp; FIRST_BIT_FLAGGED) == FIRST_BIT_FLAGGED);</span><br>    373-&gt;373:  <span style="background-color: cyan">      				latBits[0] &lt;&lt;= 1;</span><br>      374-&gt;N:  <span style="background-color: white">      			} else {</span><br>    375-&gt;375:  <span style="background-color: cyan">      				divideRangeDecode(hash, longitudeRange, (lonBits[0] &amp; FIRST_BIT_FLAGGED) == FIRST_BIT_FLAGGED);</span><br>    376-&gt;376:  <span style="background-color: cyan">      				lonBits[0] &lt;&lt;= 1;</span><br>      377-&gt;N:  <span style="background-color: white">      			}</span><br>    378-&gt;378:  <span style="background-color: cyan">      			isEvenBit = !isEvenBit;</span><br>      379-&gt;N:  <span style="background-color: white">      		}</span><br>    380-&gt;380:  <span style="background-color: cyan">      		hash.bits &lt;&lt;= (MAX_BIT_PRECISION - hash.significantBits);</span><br>    381-&gt;381:  <span style="background-color: cyan">      		setBoundingBox(hash, latitudeRange, longitudeRange);</span><br>    382-&gt;382:  <span style="background-color: cyan">      		hash.point = hash.boundingBox.getCenter();</span><br>    383-&gt;383:  <span style="background-color: cyan">      		return hash;</span><br>      384-&gt;N:  <span style="background-color: white">      	}</span><br>      385-&gt;N:  <span style="background-color: white">      </span><br>    386-&gt;386:  <span style="background-color: white">      	public GeoHash getNorthernNeighbour() {</span><br>    387-&gt;387:  <span style="background-color: white">      		long[] latitudeBits = getRightAlignedLatitudeBits();</span><br>    388-&gt;388:  <span style="background-color: white">      		long[] longitudeBits = getRightAlignedLongitudeBits();</span><br>    389-&gt;389:  <span style="background-color: white">      		latitudeBits[0] += 1;</span><br>    390-&gt;390:  <span style="background-color: white">      		latitudeBits[0] = maskLastNBits(latitudeBits[0], latitudeBits[1]);</span><br>    391-&gt;391:  <span style="background-color: white">      		return recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>      392-&gt;N:  <span style="background-color: white">      	}</span><br>      393-&gt;N:  <span style="background-color: white">      </span><br>    394-&gt;394:  <span style="background-color: white">      	public GeoHash getSouthernNeighbour() {</span><br>    395-&gt;395:  <span style="background-color: white">      		long[] latitudeBits = getRightAlignedLatitudeBits();</span><br>    396-&gt;396:  <span style="background-color: white">      		long[] longitudeBits = getRightAlignedLongitudeBits();</span><br>    397-&gt;397:  <span style="background-color: white">      		latitudeBits[0] -= 1;</span><br>    398-&gt;398:  <span style="background-color: white">      		latitudeBits[0] = maskLastNBits(latitudeBits[0], latitudeBits[1]);</span><br>    399-&gt;399:  <span style="background-color: white">      		return recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>      400-&gt;N:  <span style="background-color: white">      	}</span><br>      401-&gt;N:  <span style="background-color: white">      </span><br>    402-&gt;402:  <span style="background-color: white">      	public GeoHash getEasternNeighbour() {</span><br>    403-&gt;403:  <span style="background-color: white">      		long[] latitudeBits = getRightAlignedLatitudeBits();</span><br>    404-&gt;404:  <span style="background-color: white">      		long[] longitudeBits = getRightAlignedLongitudeBits();</span><br>    405-&gt;405:  <span style="background-color: white">      		longitudeBits[0] += 1;</span><br>    406-&gt;406:  <span style="background-color: white">      		longitudeBits[0] = maskLastNBits(longitudeBits[0], longitudeBits[1]);</span><br>    407-&gt;407:  <span style="background-color: white">      		return recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>      408-&gt;N:  <span style="background-color: white">      	}</span><br>      409-&gt;N:  <span style="background-color: white">      </span><br>    410-&gt;410:  <span style="background-color: white">      	public GeoHash getWesternNeighbour() {</span><br>    411-&gt;411:  <span style="background-color: white">      		long[] latitudeBits = getRightAlignedLatitudeBits();</span><br>    412-&gt;412:  <span style="background-color: white">      		long[] longitudeBits = getRightAlignedLongitudeBits();</span><br>    413-&gt;413:  <span style="background-color: white">      		longitudeBits[0] -= 1;</span><br>    414-&gt;414:  <span style="background-color: white">      		longitudeBits[0] = maskLastNBits(longitudeBits[0], longitudeBits[1]);</span><br>    415-&gt;415:  <span style="background-color: white">      		return recombineLatLonBitsToHash(latitudeBits, longitudeBits);</span><br>      416-&gt;N:  <span style="background-color: white">      	}</span><br>      417-&gt;N:  <span style="background-color: white">      </span><br>    418-&gt;418:  <span style="background-color: cyan">      	protected long[] getRightAlignedLatitudeBits() {</span><br>    419-&gt;419:  <span style="background-color: cyan">      		long copyOfBits = bits &lt;&lt; 1;</span><br>    420-&gt;420:  <span style="background-color: cyan">      		long value = extractEverySecondBit(copyOfBits, getNumberOfLatLonBits()[0]);</span><br>    421-&gt;421:  <span style="background-color: cyan">      		return new long[] { value, getNumberOfLatLonBits()[0] };</span><br>      422-&gt;N:  <span style="background-color: white">      	}</span><br>      423-&gt;N:  <span style="background-color: white">      </span><br>    424-&gt;424:  <span style="background-color: cyan">      	protected long[] getRightAlignedLongitudeBits() {</span><br>    425-&gt;425:  <span style="background-color: cyan">      		long copyOfBits = bits;</span><br>    426-&gt;426:  <span style="background-color: cyan">      		long value = extractEverySecondBit(copyOfBits, getNumberOfLatLonBits()[1]);</span><br>    427-&gt;427:  <span style="background-color: cyan">      		return new long[] { value, getNumberOfLatLonBits()[1] };</span><br>      428-&gt;N:  <span style="background-color: white">      	}</span><br>      429-&gt;N:  <span style="background-color: white">      </span><br>    430-&gt;430:  <span style="background-color: cyan">      	private long extractEverySecondBit(long copyOfBits, int numberOfBits) {</span><br>    431-&gt;431:  <span style="background-color: cyan">      		long value = 0;</span><br>    432-&gt;432:  <span style="background-color: cyan">      		for (int i = 0; i &lt; numberOfBits; i++) {</span><br>    433-&gt;433:  <span style="background-color: cyan">      			if ((copyOfBits &amp; FIRST_BIT_FLAGGED) == FIRST_BIT_FLAGGED) {</span><br>    434-&gt;434:  <span style="background-color: red">      				value |= 0x1;</span><br>      435-&gt;N:  <span style="background-color: white">      			}</span><br>    436-&gt;436:  <span style="background-color: cyan">      			value &lt;&lt;= 1;</span><br>    437-&gt;437:  <span style="background-color: cyan">      			copyOfBits &lt;&lt;= 2;</span><br>      438-&gt;N:  <span style="background-color: white">      		}</span><br>    439-&gt;439:  <span style="background-color: cyan">      		value &gt;&gt;&gt;= 1;</span><br>    440-&gt;440:  <span style="background-color: cyan">      		return value;</span><br>      441-&gt;N:  <span style="background-color: white">      	}</span><br>      442-&gt;N:  <span style="background-color: white">      </span><br>    443-&gt;443:  <span style="background-color: cyan">      	protected int[] getNumberOfLatLonBits() {</span><br>    444-&gt;444:  <span style="background-color: cyan">      		if (significantBits % 2 == 0) {</span><br>    445-&gt;445:  <span style="background-color: cyan">      			return new int[] { significantBits / 2, significantBits / 2 };</span><br>      446-&gt;N:  <span style="background-color: white">      		} else {</span><br>    447-&gt;447:  <span style="background-color: cyan">      			return new int[] { significantBits / 2, significantBits / 2 + 1 };</span><br>      448-&gt;N:  <span style="background-color: white">      		}</span><br>      449-&gt;N:  <span style="background-color: white">      	}</span><br>      450-&gt;N:  <span style="background-color: white">      </span><br>    451-&gt;451:  <span style="background-color: cyan">      	protected final void addOnBitToEnd() {</span><br>      452-&gt;N:  <span style="background-color: white">      		significantBits++;</span><br>    453-&gt;453:  <span style="background-color: cyan">      		bits &lt;&lt;= 1;</span><br>    454-&gt;454:  <span style="background-color: cyan">      		bits = bits | 0x1;</span><br>      455-&gt;N:  <span style="background-color: white">      	}</span><br>      456-&gt;N:  <span style="background-color: white">      </span><br>    457-&gt;457:  <span style="background-color: cyan">      	protected final void addOffBitToEnd() {</span><br>      458-&gt;N:  <span style="background-color: white">      		significantBits++;</span><br>    459-&gt;459:  <span style="background-color: cyan">      		bits &lt;&lt;= 1;</span><br>      460-&gt;N:  <span style="background-color: white">      	}</span><br>      461-&gt;N:  <span style="background-color: white">      </span><br>    462-&gt;462:  <span style="background-color: white">      	@Override</span><br>    463-&gt;463:  <span style="background-color: white">      	public String toString() {</span><br>    464-&gt;464:  <span style="background-color: white">      		if (significantBits % 5 == 0) {</span><br>    465-&gt;465:  <span style="background-color: white">      			return String.format("%s -&gt; %s -&gt; %s", padLeft(Long.toBinaryString(bits), 64, "0"), boundingBox, toBase32());</span><br>      466-&gt;N:  <span style="background-color: white">      		} else {</span><br>    467-&gt;467:  <span style="background-color: white">      			return String.format("%s -&gt; %s, bits: %d", padLeft(Long.toBinaryString(bits), 64, "0"), boundingBox, significantBits);</span><br>      468-&gt;N:  <span style="background-color: white">      		}</span><br>      469-&gt;N:  <span style="background-color: white">      	}</span><br>      470-&gt;N:  <span style="background-color: white">      </span><br>    471-&gt;471:  <span style="background-color: white">      	private static String padLeft(String s, int n, String pad) {</span><br>    472-&gt;472:  <span style="background-color: white">      		return String.format("%" + n + "s", s).replace(" ", pad);</span><br>      473-&gt;N:  <span style="background-color: white">      	}</span><br>      474-&gt;N:  <span style="background-color: white">      </span><br>    475-&gt;475:  <span style="background-color: cyan">      	public String toBinaryString() {</span><br>    476-&gt;476:  <span style="background-color: cyan">      		StringBuilder bui = new StringBuilder();</span><br>    477-&gt;477:  <span style="background-color: cyan">      		long bitsCopy = bits;</span><br>    478-&gt;478:  <span style="background-color: cyan">      		for (int i = 0; i &lt; significantBits; i++) {</span><br>    479-&gt;479:  <span style="background-color: cyan">      			if ((bitsCopy &amp; FIRST_BIT_FLAGGED) == FIRST_BIT_FLAGGED) {</span><br>    480-&gt;480:  <span style="background-color: red">      				bui.append('1');</span><br>      481-&gt;N:  <span style="background-color: white">      			} else {</span><br>    482-&gt;482:  <span style="background-color: cyan">      				bui.append('0');</span><br>      483-&gt;N:  <span style="background-color: white">      			}</span><br>    484-&gt;484:  <span style="background-color: cyan">      			bitsCopy &lt;&lt;= 1;</span><br>      485-&gt;N:  <span style="background-color: white">      		}</span><br>    486-&gt;486:  <span style="background-color: cyan">      		return bui.toString();</span><br>      487-&gt;N:  <span style="background-color: white">      	}</span><br>      488-&gt;N:  <span style="background-color: white">      </span><br>    489-&gt;489:  <span style="background-color: cyan">      	@Override</span><br>    490-&gt;490:  <span style="background-color: white">      	public boolean equals(Object obj) {</span><br>    491-&gt;491:  <span style="background-color: cyan">      		if (obj == this) {</span><br>    492-&gt;492:  <span style="background-color: white">      			return true;</span><br>      493-&gt;N:  <span style="background-color: white">      		}</span><br>    494-&gt;494:  <span style="background-color: cyan">      		if (obj instanceof GeoHash) {</span><br>    495-&gt;495:  <span style="background-color: cyan">      			GeoHash other = (GeoHash) obj;</span><br>    496-&gt;496:  <span style="background-color: cyan">      			if (other.significantBits == significantBits &amp;&amp; other.bits == bits) {</span><br>    497-&gt;497:  <span style="background-color: cyan">      				return true;</span><br>      498-&gt;N:  <span style="background-color: white">      			}</span><br>      499-&gt;N:  <span style="background-color: white">      		}</span><br>    500-&gt;500:  <span style="background-color: white">      		return false;</span><br>      501-&gt;N:  <span style="background-color: white">      	}</span><br>      502-&gt;N:  <span style="background-color: white">      </span><br>    503-&gt;503:  <span style="background-color: white">      	@Override</span><br>    504-&gt;504:  <span style="background-color: white">      	public int hashCode() {</span><br>    505-&gt;505:  <span style="background-color: white">      		int f = 17;</span><br>    506-&gt;506:  <span style="background-color: white">      		f = 31 * f + (int) (bits ^ (bits &gt;&gt;&gt; 32));</span><br>    507-&gt;507:  <span style="background-color: white">      		f = 31 * f + significantBits;</span><br>    508-&gt;508:  <span style="background-color: white">      		return f;</span><br>      509-&gt;N:  <span style="background-color: white">      	}</span><br>      510-&gt;N:  <span style="background-color: white">      </span><br>      511-&gt;N:  <span style="background-color: white">      	/**</span><br>      512-&gt;N:  <span style="background-color: white">      	 * return a long mask for this hashes significant bits.</span><br>      513-&gt;N:  <span style="background-color: white">      	 */</span><br>    514-&gt;514:  <span style="background-color: white">      	private long mask() {</span><br>    515-&gt;515:  <span style="background-color: white">      		if (significantBits == 0) {</span><br>    516-&gt;516:  <span style="background-color: white">      			return 0;</span><br>      517-&gt;N:  <span style="background-color: white">      		} else {</span><br>    518-&gt;518:  <span style="background-color: white">      			long value = FIRST_BIT_FLAGGED;</span><br>    519-&gt;519:  <span style="background-color: white">      			value &gt;&gt;= (significantBits - 1);</span><br>    520-&gt;520:  <span style="background-color: white">      			return value;</span><br>      521-&gt;N:  <span style="background-color: white">      		}</span><br>      522-&gt;N:  <span style="background-color: white">      	}</span><br>      523-&gt;N:  <span style="background-color: white">      </span><br>    524-&gt;524:  <span style="background-color: white">      	private long maskLastNBits(long value, long n) {</span><br>    525-&gt;525:  <span style="background-color: white">      		long mask = 0xffffffffffffffffl;</span><br>    526-&gt;526:  <span style="background-color: white">      		mask &gt;&gt;&gt;= (MAX_BIT_PRECISION - n);</span><br>    527-&gt;527:  <span style="background-color: white">      		return value &amp; mask;</span><br>      528-&gt;N:  <span style="background-color: white">      	}</span><br>      529-&gt;N:  <span style="background-color: white">      </span><br>    530-&gt;530:  <span style="background-color: white">      	@Override</span><br>    531-&gt;531:  <span style="background-color: white">      	public int compareTo(GeoHash o) {</span><br>    532-&gt;532:  <span style="background-color: white">      		int bitsCmp = Long.compare(bits ^ FIRST_BIT_FLAGGED, o.bits ^ FIRST_BIT_FLAGGED);</span><br>    533-&gt;533:  <span style="background-color: white">      		if (bitsCmp != 0) {</span><br>    534-&gt;534:  <span style="background-color: white">      			return bitsCmp;</span><br>      535-&gt;N:  <span style="background-color: white">      		} else {</span><br>    536-&gt;536:  <span style="background-color: white">      			return Integer.compare(significantBits, o.significantBits);</span><br>      537-&gt;N:  <span style="background-color: white">      		}</span><br>      538-&gt;N:  <span style="background-color: white">      	}</span><br>      539-&gt;N:  <span style="background-color: white">      }</span><br></pre> </code> 
   </div> 
  </div>  
 </body>
</html>