<!doctype html>
<html lang="en"> 
 <head> 
  <meta charset="UTF-8"> 
  <title>Execution Trace Diff</title> 
  <meta name="viewport" content="width=device-width, initial-scale=1"> 
  <style>
* {
  box-sizing: border-box;
}

/* Create two equal columns that floats next to each other */
.column {
  float: left;
  width: 50%;
  padding: 10px;
  height: 300px; /* Should be removed. Only for demonstration */
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

.test {
    border: 1px solid darkblue;
    padding-left: 10px;
}
</style> 
 </head> 
 <body> 
  <div class="row test"> 
   <h2>Differencing Test:</h2> <code> <pre>@Test <br>
public void test_main(){ <br>
    String ret = NumberAnalyzer.analyze(1); <br>
    assertThat(ret, containsString("greater")); <br>
}
        </pre> </code> 
  </div> 
  <div class="row"> 
   <div class="column"> 
    <h2>Original Code:</h2> <code> <pre id="original-trace">           1:  <span style="background-color: white">      /*</span><br>           2:  <span style="background-color: white">       Copyright 1995-2015 Esri</span><br>           3:  <span style="background-color: white">      </span><br>           4:  <span style="background-color: white">         Licensed under the Apache License, Version 2.0 (the "License");</span><br>           5:  <span style="background-color: white">         you may not use this file except in compliance with the License.</span><br>           6:  <span style="background-color: white">         You may obtain a copy of the License at</span><br>           7:  <span style="background-color: white">      </span><br>           8:  <span style="background-color: white">             http://www.apache.org/licenses/LICENSE-2.0</span><br>           9:  <span style="background-color: white">      </span><br>          10:  <span style="background-color: white">         Unless required by applicable law or agreed to in writing, software</span><br>          11:  <span style="background-color: white">         distributed under the License is distributed on an "AS IS" BASIS,</span><br>          12:  <span style="background-color: white">         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br>          13:  <span style="background-color: white">         See the License for the specific language governing permissions and</span><br>          14:  <span style="background-color: white">         limitations under the License.</span><br>          15:  <span style="background-color: white">      </span><br>          16:  <span style="background-color: white">       For additional information, contact:</span><br>          17:  <span style="background-color: white">       Environmental Systems Research Institute, Inc.</span><br>          18:  <span style="background-color: white">       Attn: Contracts Dept</span><br>          19:  <span style="background-color: white">       380 New York Street</span><br>          20:  <span style="background-color: white">       Redlands, California, USA 92373</span><br>          21:  <span style="background-color: white">      </span><br>          22:  <span style="background-color: white">       email: contracts@esri.com</span><br>          23:  <span style="background-color: white">       */</span><br>          24:  <span style="background-color: white">      </span><br>          25:  <span style="background-color: white">      </span><br>          26:  <span style="background-color: white">      package com.esri.core.geometry;</span><br>          27:  <span style="background-color: white">      </span><br>          28:  <span style="background-color: white">      import static com.esri.core.geometry.SizeOf.SIZE_OF_MULTI_PATH_IMPL;</span><br>          29:  <span style="background-color: white">      </span><br>          30:  <span style="background-color: white">      final class MultiPathImpl extends MultiVertexGeometryImpl {</span><br>          31:  <span style="background-color: white">      	protected boolean m_bPolygon;</span><br>          32:  <span style="background-color: white">      	protected Point m_moveToPoint;</span><br>          33:  <span style="background-color: white">      	protected double m_cachedLength2D;</span><br>          34:  <span style="background-color: white">      	protected double m_cachedArea2D;</span><br>          35:  <span style="background-color: white">      </span><br>          36:  <span style="background-color: white">      	protected AttributeStreamOfDbl m_cachedRingAreas2D;</span><br>          37:  <span style="background-color: white">      	protected boolean m_bPathStarted;</span><br>          38:  <span style="background-color: white">      </span><br>          39:  <span style="background-color: white">      	// Contains starting points of the parts. The size is getPartCount() + 1.</span><br>          40:  <span style="background-color: white">      	// First element is 0, last element is equal to the getPointCount().</span><br>          41:  <span style="background-color: white">      	protected AttributeStreamOfInt32 m_paths;</span><br>          42:  <span style="background-color: white">      	// same size as m_parts. Holds flags for each part (whether the part is</span><br>          43:  <span style="background-color: white">      	// closed, etc. See PathFlags)</span><br>          44:  <span style="background-color: white">      	protected AttributeStreamOfInt8 m_pathFlags;</span><br>          45:  <span style="background-color: white">      	// The segment flags. Size is getPointCount(). This is not a vertex</span><br>          46:  <span style="background-color: white">      	// attribute, because we may want to use indexed access later (via an index</span><br>          47:  <span style="background-color: white">      	// buffer).</span><br>          48:  <span style="background-color: white">      	// Can be NULL if the MultiPathImpl contains straight lines only.</span><br>          49:  <span style="background-color: white">      	protected AttributeStreamOfInt8 m_segmentFlags;</span><br>          50:  <span style="background-color: white">      	// An index into the m_segmentParams stream. Size is getPointCount(). Can be</span><br>          51:  <span style="background-color: white">      	// NULL if the MultiPathImpl contains straight lines only.</span><br>          52:  <span style="background-color: white">      	protected AttributeStreamOfInt32 m_segmentParamIndex;</span><br>          53:  <span style="background-color: white">      	protected AttributeStreamOfDbl m_segmentParams;</span><br>          54:  <span style="background-color: white">      	protected int m_curveParamwritePoint;</span><br>          55:  <span style="background-color: white">      	private int m_currentPathIndex;</span><br>          56:  <span style="background-color: white">      	private int m_fill_rule = Polygon.FillRule.enumFillRuleOddEven;</span><br>          57:  <span style="background-color: white">      </span><br>          58:  <span style="background-color: white">      	static int[] _segmentParamSizes = { 0, 0, 6, 0, 8, 0 }; // None, Line,</span><br>          59:  <span style="background-color: white">      															// Bezier, XXX, Arc,</span><br>          60:  <span style="background-color: white">      															// XXX;</span><br>          61:  <span style="background-color: white">      </span><br>          62:  <span style="background-color: white">      	@Override</span><br>          63:  <span style="background-color: white">      	public long estimateMemorySize()</span><br>          64:  <span style="background-color: white">      	{</span><br>          65:  <span style="background-color: white">      		long size = SIZE_OF_MULTI_PATH_IMPL +</span><br>          66:  <span style="background-color: white">      			+ (m_envelope != null ? m_envelope.estimateMemorySize() : 0)</span><br>          67:  <span style="background-color: white">      			+ (m_moveToPoint != null ? m_moveToPoint.estimateMemorySize() : 0)</span><br>          68:  <span style="background-color: white">      			+ (m_cachedRingAreas2D != null ? m_cachedRingAreas2D.estimateMemorySize() : 0)</span><br>          69:  <span style="background-color: white">      			+ (m_paths != null ? m_paths.estimateMemorySize() : 0)</span><br>          70:  <span style="background-color: white">      			+ (m_pathFlags != null ? m_pathFlags.estimateMemorySize() : 0)</span><br>          71:  <span style="background-color: white">      			+ (m_segmentFlags != null ? m_segmentFlags.estimateMemorySize() : 0)</span><br>          72:  <span style="background-color: white">      			+ (m_segmentParamIndex != null ? m_segmentParamIndex.estimateMemorySize() : 0)</span><br>          73:  <span style="background-color: white">      			+ (m_segmentParams != null ? m_segmentParams.estimateMemorySize() : 0);</span><br>          74:  <span style="background-color: white">      </span><br>          75:  <span style="background-color: white">      		if (m_vertexAttributes != null) {</span><br>          76:  <span style="background-color: white">      			for (int i = 0; i &lt; m_vertexAttributes.length; i++) {</span><br>          77:  <span style="background-color: white">      				size += m_vertexAttributes[i].estimateMemorySize();</span><br>          78:  <span style="background-color: white">      			}</span><br>          79:  <span style="background-color: white">      		}</span><br>          80:  <span style="background-color: white">      </span><br>          81:  <span style="background-color: white">      		if (m_accelerators != null) {</span><br>          82:  <span style="background-color: white">      			size += m_accelerators.estimateMemorySize();</span><br>          83:  <span style="background-color: white">      		}</span><br>          84:  <span style="background-color: white">      </span><br>          85:  <span style="background-color: white">      		return size;</span><br>          86:  <span style="background-color: white">      	}</span><br>          87:  <span style="background-color: white">      </span><br>          88:  <span style="background-color: white">      	public boolean hasNonLinearSegments() {</span><br>          89:  <span style="background-color: white">      		return m_curveParamwritePoint &gt; 0;</span><br>          90:  <span style="background-color: white">      	}</span><br>          91:  <span style="background-color: white">      </span><br>          92:  <span style="background-color: white">      	// / Cpp ///</span><br>          93:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>          94:  <span style="background-color: red">      	public MultiPathImpl(boolean bPolygon) {</span><br>          95:  <span style="background-color: red">      		m_bPolygon = bPolygon;</span><br>          96:  <span style="background-color: white">      </span><br>          97:  <span style="background-color: red">      		m_bPathStarted = false;</span><br>          98:  <span style="background-color: red">      		m_curveParamwritePoint = 0;</span><br>          99:  <span style="background-color: red">      		m_cachedLength2D = 0;</span><br>         100:  <span style="background-color: red">      		m_cachedArea2D = 0;</span><br>         101:  <span style="background-color: red">      		m_pointCount = 0;</span><br>         102:  <span style="background-color: red">      		m_description = VertexDescriptionDesignerImpl.getDefaultDescriptor2D();</span><br>         103:  <span style="background-color: red">      		m_cachedRingAreas2D = null;</span><br>         104:  <span style="background-color: red">      		m_currentPathIndex = 0;</span><br>         105:  <span style="background-color: white">      	}</span><br>         106:  <span style="background-color: white">      </span><br>         107:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         108:  <span style="background-color: white">      	public MultiPathImpl(boolean bPolygon, VertexDescription description) {</span><br>         109:  <span style="background-color: white">      		if (description == null)</span><br>         110:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>         111:  <span style="background-color: white">      </span><br>         112:  <span style="background-color: white">      		m_bPolygon = bPolygon;</span><br>         113:  <span style="background-color: white">      </span><br>         114:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>         115:  <span style="background-color: white">      		m_curveParamwritePoint = 0;</span><br>         116:  <span style="background-color: white">      		m_cachedLength2D = 0;</span><br>         117:  <span style="background-color: white">      		m_cachedArea2D = 0;</span><br>         118:  <span style="background-color: white">      		m_pointCount = 0;</span><br>         119:  <span style="background-color: white">      		m_description = description;</span><br>         120:  <span style="background-color: white">      		m_cachedRingAreas2D = null;</span><br>         121:  <span style="background-color: white">      		m_currentPathIndex = 0;</span><br>         122:  <span style="background-color: white">      	}</span><br>         123:  <span style="background-color: white">      </span><br>         124:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         125:  <span style="background-color: red">      	protected void _initPathStartPoint() {</span><br>         126:  <span style="background-color: white">      		_touch();</span><br>         127:  <span style="background-color: red">      		if (m_moveToPoint == null)</span><br>         128:  <span style="background-color: red">      			m_moveToPoint = new Point(m_description);</span><br>         129:  <span style="background-color: white">      		else</span><br>         130:  <span style="background-color: red">      			m_moveToPoint.assignVertexDescription(m_description);</span><br>         131:  <span style="background-color: white">      	}</span><br>         132:  <span style="background-color: white">      </span><br>         133:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         134:  <span style="background-color: white">      	/**</span><br>         135:  <span style="background-color: white">      	 * Starts a new Path at the Point.</span><br>         136:  <span style="background-color: white">      	 */</span><br>         137:  <span style="background-color: red">      	public void startPath(double x, double y) {</span><br>         138:  <span style="background-color: red">      		Point2D endPoint = new Point2D();</span><br>         139:  <span style="background-color: red">      		endPoint.x = x;</span><br>         140:  <span style="background-color: red">      		endPoint.y = y;</span><br>         141:  <span style="background-color: red">      		startPath(endPoint);</span><br>         142:  <span style="background-color: white">      	}</span><br>         143:  <span style="background-color: white">      </span><br>         144:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         145:  <span style="background-color: red">      	public void startPath(Point2D point) {</span><br>         146:  <span style="background-color: white">      		_initPathStartPoint();</span><br>         147:  <span style="background-color: red">      		m_moveToPoint.setXY(point);</span><br>         148:  <span style="background-color: red">      		m_bPathStarted = true;</span><br>         149:  <span style="background-color: white">      	}</span><br>         150:  <span style="background-color: white">      </span><br>         151:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         152:  <span style="background-color: white">      	public void startPath(Point3D point) {</span><br>         153:  <span style="background-color: white">      		_initPathStartPoint();</span><br>         154:  <span style="background-color: white">      		m_moveToPoint.setXYZ(point);</span><br>         155:  <span style="background-color: white">      		assignVertexDescription(m_moveToPoint.getDescription());</span><br>         156:  <span style="background-color: white">      		m_bPathStarted = true;</span><br>         157:  <span style="background-color: white">      	}</span><br>         158:  <span style="background-color: white">      </span><br>         159:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         160:  <span style="background-color: red">      	public void startPath(Point point) {</span><br>         161:  <span style="background-color: red">      		if (point.isEmpty())</span><br>         162:  <span style="background-color: white">      			throw new IllegalArgumentException();// throw new</span><br>         163:  <span style="background-color: white">      													// IllegalArgumentException();</span><br>         164:  <span style="background-color: white">      </span><br>         165:  <span style="background-color: red">      		mergeVertexDescription(point.getDescription());</span><br>         166:  <span style="background-color: white">      		_initPathStartPoint();</span><br>         167:  <span style="background-color: red">      		point.copyTo(m_moveToPoint);</span><br>         168:  <span style="background-color: white">      </span><br>         169:  <span style="background-color: white">      		// TODO check MultiPathImpl.cpp comment</span><br>         170:  <span style="background-color: white">      		// "//the description will be merged later"</span><br>         171:  <span style="background-color: white">      		// assignVertexDescription(m_moveToPoint.getDescription());</span><br>         172:  <span style="background-color: red">      		m_bPathStarted = true;</span><br>         173:  <span style="background-color: white">      	}</span><br>         174:  <span style="background-color: white">      </span><br>         175:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         176:  <span style="background-color: red">      	protected void _beforeNewSegment(int resizeBy) {</span><br>         177:  <span style="background-color: white">      		// Called for each new segment being added.</span><br>         178:  <span style="background-color: white">      		if (m_bPathStarted) {</span><br>         179:  <span style="background-color: white">      			_initPathStartPoint();// make sure the m_movetoPoint exists and has</span><br>         180:  <span style="background-color: white">      									// right vertex description</span><br>         181:  <span style="background-color: white">      </span><br>         182:  <span style="background-color: white">      			// The new path is started. Need to grow m_parts and m_pathFlags.</span><br>         183:  <span style="background-color: red">      			if (m_paths == null) {</span><br>         184:  <span style="background-color: red">      				m_paths = (AttributeStreamOfInt32) AttributeStreamBase</span><br>         185:  <span style="background-color: white">      						.createIndexStream(2);</span><br>         186:  <span style="background-color: red">      				m_paths.write(0, 0);</span><br>         187:  <span style="background-color: red">      				m_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase</span><br>         188:  <span style="background-color: white">      						.createByteStream(2, (byte) 0);</span><br>         189:  <span style="background-color: white">      			} else {</span><br>         190:  <span style="background-color: white">      				// _ASSERT(m_parts.size() &gt;= 2);</span><br>         191:  <span style="background-color: red">      				m_paths.resize(m_paths.size() + 1, 0);</span><br>         192:  <span style="background-color: red">      				m_pathFlags.resize(m_pathFlags.size() + 1, 0);</span><br>         193:  <span style="background-color: white">      			}</span><br>         194:  <span style="background-color: white">      </span><br>         195:  <span style="background-color: white">      			if (m_bPolygon) {</span><br>         196:  <span style="background-color: white">      				// Mark the path as closed</span><br>         197:  <span style="background-color: red">      				m_pathFlags.write(m_pathFlags.size() - 2,</span><br>         198:  <span style="background-color: white">      						(byte) PathFlags.enumClosed);</span><br>         199:  <span style="background-color: white">      			}</span><br>         200:  <span style="background-color: white">      </span><br>         201:  <span style="background-color: red">      			resizeBy++; // +1 for the StartPath point.</span><br>         202:  <span style="background-color: white">      		}</span><br>         203:  <span style="background-color: white">      </span><br>         204:  <span style="background-color: red">      		int oldcount = m_pointCount;</span><br>         205:  <span style="background-color: red">      		m_paths.write(m_paths.size() - 1, m_pointCount + resizeBy); // The</span><br>         206:  <span style="background-color: white">      																	// NotifyModified</span><br>         207:  <span style="background-color: white">      																	// will</span><br>         208:  <span style="background-color: white">      																	// update</span><br>         209:  <span style="background-color: white">      																	// the</span><br>         210:  <span style="background-color: white">      																	// m_pointCount</span><br>         211:  <span style="background-color: white">      																	// with this</span><br>         212:  <span style="background-color: white">      																	// value.</span><br>         213:  <span style="background-color: red">      		_resizeImpl(oldcount + resizeBy);</span><br>         214:  <span style="background-color: red">      		m_pathFlags.write(m_paths.size() - 1, (byte) 0);</span><br>         215:  <span style="background-color: white">      </span><br>         216:  <span style="background-color: white">      		if (m_bPathStarted) {</span><br>         217:  <span style="background-color: red">      			setPointByVal(oldcount, m_moveToPoint);// setPoint(oldcount,</span><br>         218:  <span style="background-color: white">      													// m_moveToPoint); //finally</span><br>         219:  <span style="background-color: white">      													// set the start point to</span><br>         220:  <span style="background-color: white">      													// the geometry</span><br>         221:  <span style="background-color: red">      			m_bPathStarted = false;</span><br>         222:  <span style="background-color: white">      		}</span><br>         223:  <span style="background-color: white">      	}</span><br>         224:  <span style="background-color: white">      </span><br>         225:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         226:  <span style="background-color: red">      	protected void _finishLineTo() {</span><br>         227:  <span style="background-color: white">      	}</span><br>         228:  <span style="background-color: white">      </span><br>         229:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         230:  <span style="background-color: white">      	/**</span><br>         231:  <span style="background-color: white">      	 * adds a Line Segment from the last Point to the given endPoint.</span><br>         232:  <span style="background-color: white">      	 */</span><br>         233:  <span style="background-color: red">      	public void lineTo(double x, double y) {</span><br>         234:  <span style="background-color: red">      		_beforeNewSegment(1);</span><br>         235:  <span style="background-color: red">      		setXY(m_pointCount - 1, x, y);</span><br>         236:  <span style="background-color: white">      		_finishLineTo();</span><br>         237:  <span style="background-color: white">      		// Point2D endPoint = new Point2D();</span><br>         238:  <span style="background-color: white">      		// endPoint.x = x; endPoint.y = y;</span><br>         239:  <span style="background-color: white">      		// lineTo(endPoint);</span><br>         240:  <span style="background-color: white">      	}</span><br>         241:  <span style="background-color: white">      </span><br>         242:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         243:  <span style="background-color: white">      	public void lineTo(Point2D endPoint) {</span><br>         244:  <span style="background-color: white">      		_beforeNewSegment(1);</span><br>         245:  <span style="background-color: white">      		setXY(m_pointCount - 1, endPoint);</span><br>         246:  <span style="background-color: white">      		_finishLineTo();</span><br>         247:  <span style="background-color: white">      	}</span><br>         248:  <span style="background-color: white">      </span><br>         249:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         250:  <span style="background-color: white">      	public void lineTo(Point3D endPoint) {</span><br>         251:  <span style="background-color: white">      		_beforeNewSegment(1);</span><br>         252:  <span style="background-color: white">      		setXYZ(m_pointCount - 1, endPoint);</span><br>         253:  <span style="background-color: white">      		_finishLineTo();</span><br>         254:  <span style="background-color: white">      	}</span><br>         255:  <span style="background-color: white">      </span><br>         256:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         257:  <span style="background-color: red">      	public void lineTo(Point endPoint) {</span><br>         258:  <span style="background-color: red">      		_beforeNewSegment(1);</span><br>         259:  <span style="background-color: red">      		setPointByVal(m_pointCount - 1, endPoint);</span><br>         260:  <span style="background-color: white">      		_finishLineTo();</span><br>         261:  <span style="background-color: white">      	}</span><br>         262:  <span style="background-color: white">      </span><br>         263:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         264:  <span style="background-color: white">      	protected void _initSegmentData(int sz) {</span><br>         265:  <span style="background-color: white">      		if (m_segmentParamIndex == null) {</span><br>         266:  <span style="background-color: white">      			m_segmentFlags = (AttributeStreamOfInt8) AttributeStreamBase</span><br>         267:  <span style="background-color: white">      					.createByteStream(m_pointCount,</span><br>         268:  <span style="background-color: white">      							(byte) SegmentFlags.enumLineSeg);</span><br>         269:  <span style="background-color: white">      			m_segmentParamIndex = (AttributeStreamOfInt32) AttributeStreamBase</span><br>         270:  <span style="background-color: white">      					.createIndexStream(m_pointCount, -1);</span><br>         271:  <span style="background-color: white">      		}</span><br>         272:  <span style="background-color: white">      </span><br>         273:  <span style="background-color: white">      		int size = m_curveParamwritePoint + sz;</span><br>         274:  <span style="background-color: white">      		if (m_segmentParams == null) {</span><br>         275:  <span style="background-color: white">      			m_segmentParams = (AttributeStreamOfDbl) AttributeStreamBase</span><br>         276:  <span style="background-color: white">      					.createAttributeStreamWithPersistence(</span><br>         277:  <span style="background-color: white">      							VertexDescription.Persistence.enumDouble, size);</span><br>         278:  <span style="background-color: white">      		} else {</span><br>         279:  <span style="background-color: white">      			m_segmentParams.resize(size, 0);</span><br>         280:  <span style="background-color: white">      		}</span><br>         281:  <span style="background-color: white">      	}</span><br>         282:  <span style="background-color: white">      </span><br>         283:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         284:  <span style="background-color: white">      	protected void _finishBezierTo() {</span><br>         285:  <span style="background-color: white">      		// _ASSERT(m_segmentFlags != null);</span><br>         286:  <span style="background-color: white">      		// _ASSERT(m_segmentParamIndex != null);</span><br>         287:  <span style="background-color: white">      </span><br>         288:  <span style="background-color: white">      		m_segmentFlags.write(m_pointCount - 2,</span><br>         289:  <span style="background-color: white">      				(byte) SegmentFlags.enumBezierSeg);</span><br>         290:  <span style="background-color: white">      	}</span><br>         291:  <span style="background-color: white">      </span><br>         292:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         293:  <span style="background-color: white">      	/**</span><br>         294:  <span style="background-color: white">      	 * adds a Cubic Bezier Segment to the current Path. The Bezier Segment</span><br>         295:  <span style="background-color: white">      	 * connects the current last Point and the given endPoint.</span><br>         296:  <span style="background-color: white">      	 */</span><br>         297:  <span style="background-color: white">      	public void bezierTo(Point2D controlPoint1, Point2D controlPoint2,</span><br>         298:  <span style="background-color: white">      			Point2D endPoint) {</span><br>         299:  <span style="background-color: white">      		_beforeNewSegment(1);</span><br>         300:  <span style="background-color: white">      		setXY(m_pointCount - 1, endPoint);</span><br>         301:  <span style="background-color: white">      		double z;</span><br>         302:  <span style="background-color: white">      		_initSegmentData(6);</span><br>         303:  <span style="background-color: white">      		m_pathFlags.setBits(m_pathFlags.size() - 1,</span><br>         304:  <span style="background-color: white">      				(byte) PathFlags.enumHasNonlinearSegments);</span><br>         305:  <span style="background-color: white">      		m_segmentParamIndex.write(m_pointCount - 2, m_curveParamwritePoint);</span><br>         306:  <span style="background-color: white">      		m_curveParamwritePoint += 6;</span><br>         307:  <span style="background-color: white">      		int curveIndex = m_curveParamwritePoint;</span><br>         308:  <span style="background-color: white">      		m_segmentParams.write(curveIndex, controlPoint1.x);</span><br>         309:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 1, controlPoint1.y);</span><br>         310:  <span style="background-color: white">      		z = 0;// TODO: calculate me.</span><br>         311:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 2, z);</span><br>         312:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 3, controlPoint2.x);</span><br>         313:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 4, controlPoint2.y);</span><br>         314:  <span style="background-color: white">      		z = 0;// TODO: calculate me.</span><br>         315:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 5, z);</span><br>         316:  <span style="background-color: white">      		_finishBezierTo();</span><br>         317:  <span style="background-color: white">      	}</span><br>         318:  <span style="background-color: white">      </span><br>         319:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         320:  <span style="background-color: white">      	public void openPath(int pathIndex) {</span><br>         321:  <span style="background-color: white">      		_touch();</span><br>         322:  <span style="background-color: white">      		if (m_bPolygon)</span><br>         323:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();// do not call this</span><br>         324:  <span style="background-color: white">      															// method on a</span><br>         325:  <span style="background-color: white">      															// polygon</span><br>         326:  <span style="background-color: white">      </span><br>         327:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>         328:  <span style="background-color: white">      		if (pathIndex &gt; getPathCount())</span><br>         329:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>         330:  <span style="background-color: white">      </span><br>         331:  <span style="background-color: white">      		if (m_pathFlags == null)</span><br>         332:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>         333:  <span style="background-color: white">      </span><br>         334:  <span style="background-color: white">      		m_pathFlags.clearBits(pathIndex, (byte) PathFlags.enumClosed);</span><br>         335:  <span style="background-color: white">      	}</span><br>         336:  <span style="background-color: white">      </span><br>         337:  <span style="background-color: white">      	public void openPathAndDuplicateStartVertex(int pathIndex) {</span><br>         338:  <span style="background-color: white">      		_touch();</span><br>         339:  <span style="background-color: white">      		if (m_bPolygon)</span><br>         340:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();// do not call this</span><br>         341:  <span style="background-color: white">      															// method on a</span><br>         342:  <span style="background-color: white">      															// polygon</span><br>         343:  <span style="background-color: white">      </span><br>         344:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>         345:  <span style="background-color: white">      		if (pathIndex &gt; pathCount)</span><br>         346:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>         347:  <span style="background-color: white">      </span><br>         348:  <span style="background-color: white">      		if (!isClosedPath(pathIndex))</span><br>         349:  <span style="background-color: white">      			return;// do not open if open</span><br>         350:  <span style="background-color: white">      </span><br>         351:  <span style="background-color: white">      		if (m_pathFlags == null)// if (!m_pathFlags)</span><br>         352:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>         353:  <span style="background-color: white">      </span><br>         354:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>         355:  <span style="background-color: white">      		int pathIndexStart = getPathStart(pathIndex);</span><br>         356:  <span style="background-color: white">      		int pathIndexEnd = getPathEnd(pathIndex);</span><br>         357:  <span style="background-color: white">      		_resizeImpl(m_pointCount + 1); // resize does not write into m_paths</span><br>         358:  <span style="background-color: white">      										// anymore!</span><br>         359:  <span style="background-color: white">      		_verifyAllStreams();</span><br>         360:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>         361:  <span style="background-color: white">      			if (m_vertexAttributes[iattr] != null)// if</span><br>         362:  <span style="background-color: white">      													// (m_vertexAttributes[iattr])</span><br>         363:  <span style="background-color: white">      			{</span><br>         364:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>         365:  <span style="background-color: white">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>         366:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(comp * pathIndexEnd,</span><br>         367:  <span style="background-color: white">      						m_vertexAttributes[iattr], comp * pathIndexStart, comp,</span><br>         368:  <span style="background-color: white">      						true, 1, comp * oldPointCount);</span><br>         369:  <span style="background-color: white">      			}</span><br>         370:  <span style="background-color: white">      		}</span><br>         371:  <span style="background-color: white">      </span><br>         372:  <span style="background-color: white">      		for (int ipath = pathCount; ipath &gt; pathIndex; ipath--) {</span><br>         373:  <span style="background-color: white">      			int iend = m_paths.read(ipath);</span><br>         374:  <span style="background-color: white">      			m_paths.write(ipath, iend + 1);</span><br>         375:  <span style="background-color: white">      		}</span><br>         376:  <span style="background-color: white">      </span><br>         377:  <span style="background-color: white">      		m_pathFlags.clearBits(pathIndex, (byte) PathFlags.enumClosed);</span><br>         378:  <span style="background-color: white">      	}</span><br>         379:  <span style="background-color: white">      </span><br>         380:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         381:  <span style="background-color: white">      	// Major Changes on 16th of January</span><br>         382:  <span style="background-color: white">      	public void openAllPathsAndDuplicateStartVertex() {</span><br>         383:  <span style="background-color: white">      		_touch();</span><br>         384:  <span style="background-color: white">      		if (m_bPolygon)</span><br>         385:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();// do not call this</span><br>         386:  <span style="background-color: white">      															// method on a</span><br>         387:  <span style="background-color: white">      															// polygon</span><br>         388:  <span style="background-color: white">      </span><br>         389:  <span style="background-color: white">      		if (m_pathFlags == null)// if (!m_pathFlags)</span><br>         390:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>         391:  <span style="background-color: white">      </span><br>         392:  <span style="background-color: white">      		_verifyAllStreams();</span><br>         393:  <span style="background-color: white">      </span><br>         394:  <span style="background-color: white">      		int closedPathCount = 0;</span><br>         395:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>         396:  <span style="background-color: white">      		for (int i = 0; i &lt; pathCount; i++) {</span><br>         397:  <span style="background-color: white">      			if (m_pathFlags.read(i) == (byte) PathFlags.enumClosed) {</span><br>         398:  <span style="background-color: white">      				closedPathCount++;</span><br>         399:  <span style="background-color: white">      			}</span><br>         400:  <span style="background-color: white">      		}</span><br>         401:  <span style="background-color: white">      </span><br>         402:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>         403:  <span style="background-color: white">      			if (m_vertexAttributes[iattr] != null) {</span><br>         404:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);// int</span><br>         405:  <span style="background-color: white">      																		// semantics</span><br>         406:  <span style="background-color: white">      																		// =</span><br>         407:  <span style="background-color: white">      																		// m_description._getSemanticsImpl(iattr);</span><br>         408:  <span style="background-color: white">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>         409:  <span style="background-color: white">      				int newSize = comp * (m_pointCount + closedPathCount);</span><br>         410:  <span style="background-color: white">      				m_vertexAttributes[iattr].resize(newSize);</span><br>         411:  <span style="background-color: white">      </span><br>         412:  <span style="background-color: white">      				int offset = closedPathCount;</span><br>         413:  <span style="background-color: white">      				int ipath = pathCount;</span><br>         414:  <span style="background-color: white">      				for (int i = m_pointCount - 1; i &gt;= 0; i--) {</span><br>         415:  <span style="background-color: white">      					if (i + 1 == m_paths.read(ipath)) {</span><br>         416:  <span style="background-color: white">      						ipath--;</span><br>         417:  <span style="background-color: white">      						if (m_pathFlags.read(ipath) == (byte) PathFlags.enumClosed) {</span><br>         418:  <span style="background-color: white">      							int istart = m_paths.read(ipath);</span><br>         419:  <span style="background-color: white">      </span><br>         420:  <span style="background-color: white">      							for (int c = 0; c &lt; comp; c++) {</span><br>         421:  <span style="background-color: white">      								double v = m_vertexAttributes[iattr]</span><br>         422:  <span style="background-color: white">      										.readAsDbl(comp * istart + c);</span><br>         423:  <span style="background-color: white">      								m_vertexAttributes[iattr].writeAsDbl(comp</span><br>         424:  <span style="background-color: white">      										* (offset + i) + c, v);</span><br>         425:  <span style="background-color: white">      							}</span><br>         426:  <span style="background-color: white">      </span><br>         427:  <span style="background-color: white">      							if (--offset == 0)</span><br>         428:  <span style="background-color: white">      								break;</span><br>         429:  <span style="background-color: white">      						}</span><br>         430:  <span style="background-color: white">      					}</span><br>         431:  <span style="background-color: white">      </span><br>         432:  <span style="background-color: white">      					for (int c = 0; c &lt; comp; c++) {</span><br>         433:  <span style="background-color: white">      						double v = m_vertexAttributes[iattr].readAsDbl(comp * i</span><br>         434:  <span style="background-color: white">      								+ c);</span><br>         435:  <span style="background-color: white">      						m_vertexAttributes[iattr].writeAsDbl(comp</span><br>         436:  <span style="background-color: white">      								* (offset + i) + c, v);</span><br>         437:  <span style="background-color: white">      					}</span><br>         438:  <span style="background-color: white">      				}</span><br>         439:  <span style="background-color: white">      			}</span><br>         440:  <span style="background-color: white">      		}</span><br>         441:  <span style="background-color: white">      </span><br>         442:  <span style="background-color: white">      		int offset = closedPathCount;</span><br>         443:  <span style="background-color: white">      		for (int ipath = pathCount; ipath &gt; 0; ipath--) {</span><br>         444:  <span style="background-color: white">      			int iend = m_paths.read(ipath);</span><br>         445:  <span style="background-color: white">      			m_paths.write(ipath, iend + offset);</span><br>         446:  <span style="background-color: white">      </span><br>         447:  <span style="background-color: white">      			if (m_pathFlags.read(ipath - 1) == (byte) PathFlags.enumClosed) {</span><br>         448:  <span style="background-color: white">      				m_pathFlags.clearBits(ipath - 1, (byte) PathFlags.enumClosed);</span><br>         449:  <span style="background-color: white">      </span><br>         450:  <span style="background-color: white">      				if (--offset == 0) {</span><br>         451:  <span style="background-color: white">      					break;</span><br>         452:  <span style="background-color: white">      				}</span><br>         453:  <span style="background-color: white">      			}</span><br>         454:  <span style="background-color: white">      		}</span><br>         455:  <span style="background-color: white">      </span><br>         456:  <span style="background-color: white">      		m_pointCount += closedPathCount;</span><br>         457:  <span style="background-color: white">      	}</span><br>         458:  <span style="background-color: white">      </span><br>         459:  <span style="background-color: red">      	void closePathWithLine(int path_index) {</span><br>         460:  <span style="background-color: white">      		// touch_();</span><br>         461:  <span style="background-color: white">      		throwIfEmpty();</span><br>         462:  <span style="background-color: white">      </span><br>         463:  <span style="background-color: red">      		byte pf = m_pathFlags.read(path_index);</span><br>         464:  <span style="background-color: red">      		m_pathFlags.write(path_index, (byte) (pf | PathFlags.enumClosed));</span><br>         465:  <span style="background-color: red">      		if (m_segmentFlags != null) {</span><br>         466:  <span style="background-color: white">      			int vindex = getPathEnd(path_index) - 1;</span><br>         467:  <span style="background-color: white">      			m_segmentFlags.write(vindex, (byte) SegmentFlags.enumLineSeg);</span><br>         468:  <span style="background-color: white">      			m_segmentParamIndex.write(vindex, -1);</span><br>         469:  <span style="background-color: white">      		}</span><br>         470:  <span style="background-color: white">      	}</span><br>         471:  <span style="background-color: white">      </span><br>         472:  <span style="background-color: red">      	void closePathWithLine() {</span><br>         473:  <span style="background-color: white">      		throwIfEmpty();</span><br>         474:  <span style="background-color: red">      		m_bPathStarted = false;</span><br>         475:  <span style="background-color: red">      		closePathWithLine(getPathCount() - 1);</span><br>         476:  <span style="background-color: white">      	}</span><br>         477:  <span style="background-color: white">      </span><br>         478:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         479:  <span style="background-color: white">      	/**</span><br>         480:  <span style="background-color: white">      	 * Closes all open curves by adding an implicit line segment from the end</span><br>         481:  <span style="background-color: white">      	 * point to the start point.</span><br>         482:  <span style="background-color: white">      	 */</span><br>         483:  <span style="background-color: white">      	public void closeAllPaths() {</span><br>         484:  <span style="background-color: white">      		_touch();</span><br>         485:  <span style="background-color: white">      		if (m_bPolygon || isEmptyImpl())</span><br>         486:  <span style="background-color: white">      			return;</span><br>         487:  <span style="background-color: white">      </span><br>         488:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>         489:  <span style="background-color: white">      </span><br>         490:  <span style="background-color: white">      		for (int ipath = 0, npart = m_paths.size() - 1; ipath &lt; npart; ipath++) {</span><br>         491:  <span style="background-color: white">      			if (isClosedPath(ipath))</span><br>         492:  <span style="background-color: white">      				continue;</span><br>         493:  <span style="background-color: white">      </span><br>         494:  <span style="background-color: white">      			byte pf = m_pathFlags.read(ipath);</span><br>         495:  <span style="background-color: white">      			m_pathFlags.write(ipath, (byte) (pf | PathFlags.enumClosed));</span><br>         496:  <span style="background-color: white">      			// if (m_segmentFlags)</span><br>         497:  <span style="background-color: white">      			// {</span><br>         498:  <span style="background-color: white">      			// m_segmentFlags.write(m_pointCount - 1,</span><br>         499:  <span style="background-color: white">      			// (byte)SegmentFlags.LineSeg));</span><br>         500:  <span style="background-color: white">      			// m_segmentParamIndex.write(m_pointCount - 1, -1);</span><br>         501:  <span style="background-color: white">      			// }</span><br>         502:  <span style="background-color: white">      		}</span><br>         503:  <span style="background-color: white">      	}</span><br>         504:  <span style="background-color: white">      </span><br>         505:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         506:  <span style="background-color: white">      	/**</span><br>         507:  <span style="background-color: white">      	 * Returns the size of the segment data for the given segment type.</span><br>         508:  <span style="background-color: white">      	 * </span><br>         509:  <span style="background-color: white">      	 * @param flag</span><br>         510:  <span style="background-color: white">      	 *            is one of the segment flags from the SegmentFlags enum.</span><br>         511:  <span style="background-color: white">      	 * @return the size of the segment params as the number of doubles.</span><br>         512:  <span style="background-color: white">      	 */</span><br>         513:  <span style="background-color: white">      	public static int getSegmentDataSize(byte flag) {</span><br>         514:  <span style="background-color: white">      		return _segmentParamSizes[flag];</span><br>         515:  <span style="background-color: white">      	}</span><br>         516:  <span style="background-color: white">      </span><br>         517:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         518:  <span style="background-color: white">      	/**</span><br>         519:  <span style="background-color: white">      	 * Closes last path of the MultiPathImpl with the Bezier Segment.</span><br>         520:  <span style="background-color: white">      	 * </span><br>         521:  <span style="background-color: white">      	 * The start point of the Bezier is the last point of the path and the last</span><br>         522:  <span style="background-color: white">      	 * point of the bezier is the first point of the path.</span><br>         523:  <span style="background-color: white">      	 */</span><br>         524:  <span style="background-color: white">      	public void closePathWithBezier(Point2D controlPoint1, Point2D controlPoint2) {</span><br>         525:  <span style="background-color: white">      		_touch();</span><br>         526:  <span style="background-color: white">      		if (isEmptyImpl())</span><br>         527:  <span style="background-color: white">      			throw new GeometryException(</span><br>         528:  <span style="background-color: white">      					"Invalid call. This operation cannot be performed on an empty geometry.");</span><br>         529:  <span style="background-color: white">      </span><br>         530:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>         531:  <span style="background-color: white">      </span><br>         532:  <span style="background-color: white">      		int pathIndex = m_paths.size() - 2;</span><br>         533:  <span style="background-color: white">      		byte pf = m_pathFlags.read(pathIndex);</span><br>         534:  <span style="background-color: white">      		m_pathFlags</span><br>         535:  <span style="background-color: white">      				.write(pathIndex,</span><br>         536:  <span style="background-color: white">      						(byte) (pf | PathFlags.enumClosed | PathFlags.enumHasNonlinearSegments));</span><br>         537:  <span style="background-color: white">      		_initSegmentData(6);</span><br>         538:  <span style="background-color: white">      </span><br>         539:  <span style="background-color: white">      		byte oldType = m_segmentFlags</span><br>         540:  <span style="background-color: white">      				.read((byte) ((m_pointCount - 1) &amp; SegmentFlags.enumSegmentMask));</span><br>         541:  <span style="background-color: white">      		m_segmentFlags.write(m_pointCount - 1,</span><br>         542:  <span style="background-color: white">      				(byte) (SegmentFlags.enumBezierSeg));</span><br>         543:  <span style="background-color: white">      </span><br>         544:  <span style="background-color: white">      		int curveIndex = m_curveParamwritePoint;</span><br>         545:  <span style="background-color: white">      		if (getSegmentDataSize(oldType) &lt; getSegmentDataSize((byte) SegmentFlags.enumBezierSeg)) {</span><br>         546:  <span style="background-color: white">      			m_segmentParamIndex.write(m_pointCount - 1, m_curveParamwritePoint);</span><br>         547:  <span style="background-color: white">      			m_curveParamwritePoint += 6;</span><br>         548:  <span style="background-color: white">      		} else {</span><br>         549:  <span style="background-color: white">      			// there was a closing bezier curve or an arc here. We can reuse the</span><br>         550:  <span style="background-color: white">      			// storage.</span><br>         551:  <span style="background-color: white">      			curveIndex = m_segmentParamIndex.read(m_pointCount - 1);</span><br>         552:  <span style="background-color: white">      		}</span><br>         553:  <span style="background-color: white">      </span><br>         554:  <span style="background-color: white">      		double z;</span><br>         555:  <span style="background-color: white">      		m_segmentParams.write(curveIndex, controlPoint1.x);</span><br>         556:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 1, controlPoint1.y);</span><br>         557:  <span style="background-color: white">      		z = 0;// TODO: calculate me.</span><br>         558:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 2, z);</span><br>         559:  <span style="background-color: white">      </span><br>         560:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 3, controlPoint2.x);</span><br>         561:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 4, controlPoint2.y);</span><br>         562:  <span style="background-color: white">      		z = 0;// TODO: calculate me.</span><br>         563:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 5, z);</span><br>         564:  <span style="background-color: white">      	}</span><br>         565:  <span style="background-color: white">      </span><br>         566:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         567:  <span style="background-color: white">      	/**</span><br>         568:  <span style="background-color: white">      	 * Returns True if the given path is closed (represents a Ring).</span><br>         569:  <span style="background-color: white">      	 */</span><br>         570:  <span style="background-color: red">      	public boolean isClosedPath(int ipath) {</span><br>         571:  <span style="background-color: white">      		// Should we make a function called _UpdateClosedPathFlags and call it</span><br>         572:  <span style="background-color: white">      		// here?</span><br>         573:  <span style="background-color: red">      		return ((byte) (m_pathFlags.read(ipath) &amp; PathFlags.enumClosed)) != 0;</span><br>         574:  <span style="background-color: white">      	}</span><br>         575:  <span style="background-color: white">      </span><br>         576:  <span style="background-color: white">      	public boolean isClosedPathInXYPlane(int path_index) {</span><br>         577:  <span style="background-color: white">      		if (isClosedPath(path_index))</span><br>         578:  <span style="background-color: white">      			return true;</span><br>         579:  <span style="background-color: white">      		int istart = getPathStart(path_index);</span><br>         580:  <span style="background-color: white">      		int iend = getPathEnd(path_index) - 1;</span><br>         581:  <span style="background-color: white">      		if (istart &gt; iend)</span><br>         582:  <span style="background-color: white">      			return false;</span><br>         583:  <span style="background-color: white">      		Point2D ptS = getXY(istart);</span><br>         584:  <span style="background-color: white">      		Point2D ptE = getXY(iend);</span><br>         585:  <span style="background-color: white">      		return ptS.isEqual(ptE);</span><br>         586:  <span style="background-color: white">      	}</span><br>         587:  <span style="background-color: white">      </span><br>         588:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         589:  <span style="background-color: white">      	/**</span><br>         590:  <span style="background-color: white">      	 * Returns True if the given path might have non-linear segments.</span><br>         591:  <span style="background-color: white">      	 */</span><br>         592:  <span style="background-color: white">      	public boolean hasNonLinearSegments(int ipath) {</span><br>         593:  <span style="background-color: white">      		// Should we make a function called _UpdateHasNonLinearSegmentsFlags and</span><br>         594:  <span style="background-color: white">      		// call it here?</span><br>         595:  <span style="background-color: white">      		return (m_pathFlags.read(ipath) &amp; PathFlags.enumHasNonlinearSegments) != 0;</span><br>         596:  <span style="background-color: white">      	}</span><br>         597:  <span style="background-color: white">      </span><br>         598:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         599:  <span style="background-color: white">      	public void addSegment(Segment segment, boolean bStartNewPath) {</span><br>         600:  <span style="background-color: white">      		mergeVertexDescription(segment.getDescription());</span><br>         601:  <span style="background-color: white">      		if (segment.getType() == Type.Line) {</span><br>         602:  <span style="background-color: white">      			Point point = new Point();</span><br>         603:  <span style="background-color: white">      			if (bStartNewPath || isEmpty()) {</span><br>         604:  <span style="background-color: white">      				segment.queryStart(point);</span><br>         605:  <span style="background-color: white">      				startPath(point);</span><br>         606:  <span style="background-color: white">      			}</span><br>         607:  <span style="background-color: white">      </span><br>         608:  <span style="background-color: white">      			segment.queryEnd(point);</span><br>         609:  <span style="background-color: white">      			lineTo(point);</span><br>         610:  <span style="background-color: white">      		} else {</span><br>         611:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>         612:  <span style="background-color: white">      		}</span><br>         613:  <span style="background-color: white">      	}</span><br>         614:  <span style="background-color: white">      </span><br>         615:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         616:  <span style="background-color: white">      	/**</span><br>         617:  <span style="background-color: white">      	 * adds a rectangular closed Path to the MultiPathImpl.</span><br>         618:  <span style="background-color: white">      	 * </span><br>         619:  <span style="background-color: white">      	 * @param envSrc</span><br>         620:  <span style="background-color: white">      	 *            is the source rectangle.</span><br>         621:  <span style="background-color: white">      	 * @param bReverse</span><br>         622:  <span style="background-color: white">      	 *            Creates reversed path.</span><br>         623:  <span style="background-color: white">      	 */</span><br>         624:  <span style="background-color: white">      	public void addEnvelope(Envelope2D envSrc, boolean bReverse) {</span><br>         625:  <span style="background-color: white">      		boolean bWasEmpty = m_pointCount == 0;</span><br>         626:  <span style="background-color: white">      </span><br>         627:  <span style="background-color: white">      		startPath(envSrc.xmin, envSrc.ymin);</span><br>         628:  <span style="background-color: white">      		if (bReverse) {</span><br>         629:  <span style="background-color: white">      			lineTo(envSrc.xmax, envSrc.ymin);</span><br>         630:  <span style="background-color: white">      			lineTo(envSrc.xmax, envSrc.ymax);</span><br>         631:  <span style="background-color: white">      			lineTo(envSrc.xmin, envSrc.ymax);</span><br>         632:  <span style="background-color: white">      		} else {</span><br>         633:  <span style="background-color: white">      			lineTo(envSrc.xmin, envSrc.ymax);</span><br>         634:  <span style="background-color: white">      			lineTo(envSrc.xmax, envSrc.ymax);</span><br>         635:  <span style="background-color: white">      			lineTo(envSrc.xmax, envSrc.ymin);</span><br>         636:  <span style="background-color: white">      		}</span><br>         637:  <span style="background-color: white">      </span><br>         638:  <span style="background-color: white">      		closePathWithLine();</span><br>         639:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>         640:  <span style="background-color: white">      </span><br>         641:  <span style="background-color: white">      		if (bWasEmpty &amp;&amp; !bReverse) {</span><br>         642:  <span style="background-color: white">      			_setDirtyFlag(DirtyFlags.DirtyIsEnvelope, false);// now we no(sic?)</span><br>         643:  <span style="background-color: white">      																// the polypath</span><br>         644:  <span style="background-color: white">      																// is envelope</span><br>         645:  <span style="background-color: white">      		}</span><br>         646:  <span style="background-color: white">      	}</span><br>         647:  <span style="background-color: white">      </span><br>         648:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         649:  <span style="background-color: white">      	/**</span><br>         650:  <span style="background-color: white">      	 * adds a rectangular closed Path to the MultiPathImpl.</span><br>         651:  <span style="background-color: white">      	 * </span><br>         652:  <span style="background-color: white">      	 * @param envSrc</span><br>         653:  <span style="background-color: white">      	 *            is the source rectangle.</span><br>         654:  <span style="background-color: white">      	 * @param bReverse</span><br>         655:  <span style="background-color: white">      	 *            Creates reversed path.</span><br>         656:  <span style="background-color: white">      	 */</span><br>         657:  <span style="background-color: red">      	public void addEnvelope(Envelope envSrc, boolean bReverse) {</span><br>         658:  <span style="background-color: red">      		if (envSrc.isEmpty())</span><br>         659:  <span style="background-color: white">      			return;</span><br>         660:  <span style="background-color: white">      </span><br>         661:  <span style="background-color: red">      		boolean bWasEmpty = m_pointCount == 0;</span><br>         662:  <span style="background-color: red">      		Point pt = new Point(m_description);// getDescription());</span><br>         663:  <span style="background-color: red">      		for (int i = 0, n = 4; i &lt; n; i++) {</span><br>         664:  <span style="background-color: red">      			int j = bReverse ? n - i - 1 : i;</span><br>         665:  <span style="background-color: white">      </span><br>         666:  <span style="background-color: red">      			envSrc.queryCornerByVal(j, pt);</span><br>         667:  <span style="background-color: red">      			if (i == 0)</span><br>         668:  <span style="background-color: red">      				startPath(pt);</span><br>         669:  <span style="background-color: white">      			else</span><br>         670:  <span style="background-color: red">      				lineTo(pt);</span><br>         671:  <span style="background-color: white">      		}</span><br>         672:  <span style="background-color: white">      </span><br>         673:  <span style="background-color: white">      		closePathWithLine();</span><br>         674:  <span style="background-color: red">      		m_bPathStarted = false;</span><br>         675:  <span style="background-color: white">      </span><br>         676:  <span style="background-color: red">      		if (bWasEmpty &amp;&amp; !bReverse)</span><br>         677:  <span style="background-color: white">      			_setDirtyFlag(DirtyFlags.DirtyIsEnvelope, false);// now we know the</span><br>         678:  <span style="background-color: white">      																// polypath is</span><br>         679:  <span style="background-color: white">      																// envelope</span><br>         680:  <span style="background-color: white">      	}</span><br>         681:  <span style="background-color: white">      </span><br>         682:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         683:  <span style="background-color: white">      	public void add(MultiPathImpl src, boolean bReversePaths) {</span><br>         684:  <span style="background-color: white">      		for (int i = 0; i &lt; src.getPathCount(); i++)</span><br>         685:  <span style="background-color: white">      			addPath(src, i, !bReversePaths);</span><br>         686:  <span style="background-color: white">      	}</span><br>         687:  <span style="background-color: white">      </span><br>         688:  <span style="background-color: white">      	public void addPath(MultiPathImpl src, int srcPathIndex, boolean bForward) {</span><br>         689:  <span style="background-color: white">      		insertPath(-1, src, srcPathIndex, bForward);</span><br>         690:  <span style="background-color: white">      	}</span><br>         691:  <span style="background-color: white">      </span><br>         692:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011 Significant changes to last for loop</span><br>         693:  <span style="background-color: white">      	public void addPath(Point2D[] _points, int count, boolean bForward) {</span><br>         694:  <span style="background-color: white">      		insertPath(-1, _points, 0, count, bForward);</span><br>         695:  <span style="background-color: white">      	}</span><br>         696:  <span style="background-color: white">      </span><br>         697:  <span style="background-color: white">      	public void addSegmentsFromPath(MultiPathImpl src, int src_path_index,</span><br>         698:  <span style="background-color: white">      			int src_segment_from, int src_segment_count,</span><br>         699:  <span style="background-color: white">      			boolean b_start_new_path) {</span><br>         700:  <span style="background-color: white">      		if (!b_start_new_path &amp;&amp; getPathCount() == 0)</span><br>         701:  <span style="background-color: white">      			b_start_new_path = true;</span><br>         702:  <span style="background-color: white">      </span><br>         703:  <span style="background-color: white">      		if (src_path_index &lt; 0)</span><br>         704:  <span style="background-color: white">      			src_path_index = src.getPathCount() - 1;</span><br>         705:  <span style="background-color: white">      </span><br>         706:  <span style="background-color: white">      		if (src_path_index &gt;= src.getPathCount() || src_segment_from &lt; 0</span><br>         707:  <span style="background-color: white">      				|| src_segment_count &lt; 0</span><br>         708:  <span style="background-color: white">      				|| src_segment_count &gt; src.getSegmentCount(src_path_index))</span><br>         709:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>         710:  <span style="background-color: white">      </span><br>         711:  <span style="background-color: white">      		if (src_segment_count == 0)</span><br>         712:  <span style="background-color: white">      			return;</span><br>         713:  <span style="background-color: white">      </span><br>         714:  <span style="background-color: white">      		boolean bIncludesClosingSegment = src.isClosedPath(src_path_index)</span><br>         715:  <span style="background-color: white">      				&amp;&amp; src_segment_from + src_segment_count == src</span><br>         716:  <span style="background-color: white">      						.getSegmentCount(src_path_index);</span><br>         717:  <span style="background-color: white">      </span><br>         718:  <span style="background-color: white">      		if (bIncludesClosingSegment &amp;&amp; src_segment_count == 1)</span><br>         719:  <span style="background-color: white">      			return;// cannot add a closing segment alone.</span><br>         720:  <span style="background-color: white">      </span><br>         721:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>         722:  <span style="background-color: white">      </span><br>         723:  <span style="background-color: white">      		mergeVertexDescription(src.getDescription());</span><br>         724:  <span style="background-color: white">      		int src_point_count = src_segment_count;</span><br>         725:  <span style="background-color: white">      		int srcFromPoint = src.getPathStart(src_path_index) + src_segment_from</span><br>         726:  <span style="background-color: white">      				+ 1;</span><br>         727:  <span style="background-color: white">      		if (b_start_new_path)// adding a new path.</span><br>         728:  <span style="background-color: white">      		{</span><br>         729:  <span style="background-color: white">      			src_point_count++;// add start point.</span><br>         730:  <span style="background-color: white">      			srcFromPoint--;</span><br>         731:  <span style="background-color: white">      		}</span><br>         732:  <span style="background-color: white">      </span><br>         733:  <span style="background-color: white">      		if (bIncludesClosingSegment) {</span><br>         734:  <span style="background-color: white">      			src_point_count--;</span><br>         735:  <span style="background-color: white">      		}</span><br>         736:  <span style="background-color: white">      </span><br>         737:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>         738:  <span style="background-color: white">      		_resizeImpl(m_pointCount + src_point_count);</span><br>         739:  <span style="background-color: white">      		_verifyAllStreams();</span><br>         740:  <span style="background-color: white">      </span><br>         741:  <span style="background-color: white">      		if (b_start_new_path) {</span><br>         742:  <span style="background-color: white">      			if (src_point_count == 0)</span><br>         743:  <span style="background-color: white">      				return;// happens when adding a single closing segment to the</span><br>         744:  <span style="background-color: white">      						// new path</span><br>         745:  <span style="background-color: white">      </span><br>         746:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>         747:  <span style="background-color: white">      </span><br>         748:  <span style="background-color: white">      			byte flags = src.m_pathFlags.read(src_path_index);</span><br>         749:  <span style="background-color: white">      			flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>         750:  <span style="background-color: white">      </span><br>         751:  <span style="background-color: white">      			if (m_bPolygon)</span><br>         752:  <span style="background-color: white">      				flags |= (byte) PathFlags.enumClosed;</span><br>         753:  <span style="background-color: white">      </span><br>         754:  <span style="background-color: white">      			m_pathFlags.write(m_pathFlags.size() - 1, flags);</span><br>         755:  <span style="background-color: white">      			m_pathFlags.add((byte) 0);</span><br>         756:  <span style="background-color: white">      		} else {</span><br>         757:  <span style="background-color: white">      			m_paths.write(m_pathFlags.size() - 1, m_pointCount);</span><br>         758:  <span style="background-color: white">      		}</span><br>         759:  <span style="background-color: white">      </span><br>         760:  <span style="background-color: white">      		// Index_type absoluteIndex = pathStart + before_point_index;</span><br>         761:  <span style="background-color: white">      </span><br>         762:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>         763:  <span style="background-color: white">      			int semantics = m_description.getSemantics(iattr);</span><br>         764:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>         765:  <span style="background-color: white">      </span><br>         766:  <span style="background-color: white">      			int isrcAttr = src.m_description.getAttributeIndex(semantics);</span><br>         767:  <span style="background-color: white">      			if (isrcAttr &lt; 0 || src.m_vertexAttributes[isrcAttr] == null) {// The</span><br>         768:  <span style="background-color: white">      																			// source</span><br>         769:  <span style="background-color: white">      																			// does</span><br>         770:  <span style="background-color: white">      																			// not</span><br>         771:  <span style="background-color: white">      																			// have</span><br>         772:  <span style="background-color: white">      																			// the</span><br>         773:  <span style="background-color: white">      																			// attribute.</span><br>         774:  <span style="background-color: white">      																			// insert</span><br>         775:  <span style="background-color: white">      																			// default</span><br>         776:  <span style="background-color: white">      																			// value</span><br>         777:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>         778:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(comp * oldPointCount, v,</span><br>         779:  <span style="background-color: white">      						src_point_count * comp, comp * oldPointCount);</span><br>         780:  <span style="background-color: white">      				continue;</span><br>         781:  <span style="background-color: white">      			}</span><br>         782:  <span style="background-color: white">      </span><br>         783:  <span style="background-color: white">      			// add vertices to the given stream</span><br>         784:  <span style="background-color: white">      			boolean b_forward = true;</span><br>         785:  <span style="background-color: white">      			m_vertexAttributes[iattr].insertRange(comp * oldPointCount,</span><br>         786:  <span style="background-color: white">      					src.m_vertexAttributes[isrcAttr], comp * srcFromPoint,</span><br>         787:  <span style="background-color: white">      					src_point_count * comp, b_forward, comp, comp</span><br>         788:  <span style="background-color: white">      							* oldPointCount);</span><br>         789:  <span style="background-color: white">      		}</span><br>         790:  <span style="background-color: white">      </span><br>         791:  <span style="background-color: white">      		if (hasNonLinearSegments()) {</span><br>         792:  <span style="background-color: white">      			// TODO: implement me. For example as a while loop over all curves.</span><br>         793:  <span style="background-color: white">      			// Replace, calling ReplaceSegment</span><br>         794:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>         795:  <span style="background-color: white">      			// m_segment_flags-&gt;write_range((get_path_start(path_index) +</span><br>         796:  <span style="background-color: white">      			// before_point_index + src_point_count), (oldPointCount -</span><br>         797:  <span style="background-color: white">      			// get_path_start(path_index) - before_point_index),</span><br>         798:  <span style="background-color: white">      			// m_segment_flags, (get_path_start(path_index) +</span><br>         799:  <span style="background-color: white">      			// before_point_index), true, 1);</span><br>         800:  <span style="background-color: white">      			// m_segment_param_index-&gt;write_range((get_path_start(path_index) +</span><br>         801:  <span style="background-color: white">      			// before_point_index + src_point_count), (oldPointCount -</span><br>         802:  <span style="background-color: white">      			// get_path_start(path_index) - before_point_index),</span><br>         803:  <span style="background-color: white">      			// m_segment_param_index, (get_path_start(path_index) +</span><br>         804:  <span style="background-color: white">      			// before_point_index), true, 1);</span><br>         805:  <span style="background-color: white">      			// for (Index_type i = get_path_start(path_index) +</span><br>         806:  <span style="background-color: white">      			// before_point_index, n = get_path_start(path_index) +</span><br>         807:  <span style="background-color: white">      			// before_point_index + src_point_count; i &lt; n; i++)</span><br>         808:  <span style="background-color: white">      			// {</span><br>         809:  <span style="background-color: white">      			// m_segment_flags-&gt;write(i, (int8_t)enum_value1(Segment_flags,</span><br>         810:  <span style="background-color: white">      			// enum_line_seg));</span><br>         811:  <span style="background-color: white">      			// m_segment_param_index-&gt;write(i, -1);</span><br>         812:  <span style="background-color: white">      			// }</span><br>         813:  <span style="background-color: white">      		}</span><br>         814:  <span style="background-color: white">      </span><br>         815:  <span style="background-color: white">      		if (src.hasNonLinearSegments(src_path_index)) {</span><br>         816:  <span style="background-color: white">      			// TODO: implement me. For example as a while loop over all curves.</span><br>         817:  <span style="background-color: white">      			// Replace, calling ReplaceSegment</span><br>         818:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>         819:  <span style="background-color: white">      		}</span><br>         820:  <span style="background-color: white">      </span><br>         821:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>         822:  <span style="background-color: white">      	}</span><br>         823:  <span style="background-color: white">      </span><br>         824:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         825:  <span style="background-color: white">      	public void reverseAllPaths() {</span><br>         826:  <span style="background-color: white">      		for (int i = 0, n = getPathCount(); i &lt; n; i++) {</span><br>         827:  <span style="background-color: white">      			reversePath(i);</span><br>         828:  <span style="background-color: white">      		}</span><br>         829:  <span style="background-color: white">      	}</span><br>         830:  <span style="background-color: white">      </span><br>         831:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         832:  <span style="background-color: red">      	public void reversePath(int pathIndex) {</span><br>         833:  <span style="background-color: white">      		_verifyAllStreams();</span><br>         834:  <span style="background-color: red">      		int pathCount = getPathCount();</span><br>         835:  <span style="background-color: red">      		if (pathIndex &gt;= pathCount)</span><br>         836:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>         837:  <span style="background-color: white">      </span><br>         838:  <span style="background-color: red">      		int reversedPathStart = getPathStart(pathIndex);</span><br>         839:  <span style="background-color: red">      		int reversedPathSize = getPathSize(pathIndex);</span><br>         840:  <span style="background-color: red">      		int offset = isClosedPath(pathIndex) ? 1 : 0;</span><br>         841:  <span style="background-color: white">      </span><br>         842:  <span style="background-color: white">      		// TODO: a bug for the non linear segments here.</span><br>         843:  <span style="background-color: white">      		// There could be an issue here if someone explicity closes the path</span><br>         844:  <span style="background-color: white">      		// with the same start/end point.</span><br>         845:  <span style="background-color: red">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>         846:  <span style="background-color: red">      			if (m_vertexAttributes[iattr] != null) {</span><br>         847:  <span style="background-color: red">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>         848:  <span style="background-color: red">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>         849:  <span style="background-color: red">      				m_vertexAttributes[iattr].reverseRange(comp</span><br>         850:  <span style="background-color: white">      						* (reversedPathStart + offset), comp</span><br>         851:  <span style="background-color: white">      						* (reversedPathSize - offset), comp);</span><br>         852:  <span style="background-color: white">      			}</span><br>         853:  <span style="background-color: white">      		}</span><br>         854:  <span style="background-color: white">      </span><br>         855:  <span style="background-color: red">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>         856:  <span style="background-color: white">      	}</span><br>         857:  <span style="background-color: white">      </span><br>         858:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>         859:  <span style="background-color: white">      	// TODO: Nonlinearsegments</span><br>         860:  <span style="background-color: white">      	public void removePath(int pathIndex) {</span><br>         861:  <span style="background-color: white">      		_verifyAllStreams();</span><br>         862:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>         863:  <span style="background-color: white">      </span><br>         864:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>         865:  <span style="background-color: white">      			pathIndex = pathCount - 1;</span><br>         866:  <span style="background-color: white">      </span><br>         867:  <span style="background-color: white">      		if (pathIndex &gt;= pathCount)</span><br>         868:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>         869:  <span style="background-color: white">      </span><br>         870:  <span style="background-color: white">      		boolean bDirtyRingAreas2D = _hasDirtyFlag(DirtyFlags.DirtyRingAreas2D);</span><br>         871:  <span style="background-color: white">      </span><br>         872:  <span style="background-color: white">      		int removedPathStart = getPathStart(pathIndex);</span><br>         873:  <span style="background-color: white">      		int removedPathSize = getPathSize(pathIndex);</span><br>         874:  <span style="background-color: white">      </span><br>         875:  <span style="background-color: white">      		// Remove the attribute values for the path</span><br>         876:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>         877:  <span style="background-color: white">      			if (m_vertexAttributes[iattr] != null) {</span><br>         878:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>         879:  <span style="background-color: white">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>         880:  <span style="background-color: white">      				m_vertexAttributes[iattr].eraseRange(comp * removedPathStart,</span><br>         881:  <span style="background-color: white">      						comp * removedPathSize, comp * m_pointCount);</span><br>         882:  <span style="background-color: white">      			}</span><br>         883:  <span style="background-color: white">      		}</span><br>         884:  <span style="background-color: white">      </span><br>         885:  <span style="background-color: white">      		// Change the start of each path after the removed path</span><br>         886:  <span style="background-color: white">      		for (int i = pathIndex + 1; i &lt;= pathCount; i++) {</span><br>         887:  <span style="background-color: white">      			int istart = m_paths.read(i);</span><br>         888:  <span style="background-color: white">      			m_paths.write(i - 1, istart - removedPathSize);</span><br>         889:  <span style="background-color: white">      		}</span><br>         890:  <span style="background-color: white">      </span><br>         891:  <span style="background-color: white">      		if (m_pathFlags == null) {</span><br>         892:  <span style="background-color: white">      			for (int i = pathIndex + 1; i &lt;= pathCount; i++) {</span><br>         893:  <span style="background-color: white">      				byte flags = m_pathFlags.read(i);</span><br>         894:  <span style="background-color: white">      				m_pathFlags.write(i - 1, flags);</span><br>         895:  <span style="background-color: white">      			}</span><br>         896:  <span style="background-color: white">      		}</span><br>         897:  <span style="background-color: white">      </span><br>         898:  <span style="background-color: white">      		m_paths.resize(pathCount);</span><br>         899:  <span style="background-color: white">      		m_pathFlags.resize(pathCount);</span><br>         900:  <span style="background-color: white">      		m_pointCount -= removedPathSize;</span><br>         901:  <span style="background-color: white">      		m_reservedPointCount -= removedPathSize;</span><br>         902:  <span style="background-color: white">      </span><br>         903:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>         904:  <span style="background-color: white">      	}</span><br>         905:  <span style="background-color: white">      </span><br>         906:  <span style="background-color: white">      	// TODO: Nonlinearsegments</span><br>         907:  <span style="background-color: white">      	public void insertPath(int pathIndex, MultiPathImpl src, int srcPathIndex,</span><br>         908:  <span style="background-color: white">      			boolean bForward) {</span><br>         909:  <span style="background-color: white">      		if (src == this)</span><br>         910:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>         911:  <span style="background-color: white">      </span><br>         912:  <span style="background-color: white">      		if (srcPathIndex &gt;= src.getPathCount())</span><br>         913:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>         914:  <span style="background-color: white">      </span><br>         915:  <span style="background-color: white">      		int oldPathCount = getPathCount();</span><br>         916:  <span style="background-color: white">      		if (pathIndex &gt; oldPathCount)</span><br>         917:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>         918:  <span style="background-color: white">      </span><br>         919:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>         920:  <span style="background-color: white">      			pathIndex = oldPathCount;</span><br>         921:  <span style="background-color: white">      </span><br>         922:  <span style="background-color: white">      		if (srcPathIndex &lt; 0)</span><br>         923:  <span style="background-color: white">      			srcPathIndex = src.getPathCount() - 1;</span><br>         924:  <span style="background-color: white">      </span><br>         925:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>         926:  <span style="background-color: white">      </span><br>         927:  <span style="background-color: white">      		mergeVertexDescription(src.m_description);// merge attributes from the</span><br>         928:  <span style="background-color: white">      													// source</span><br>         929:  <span style="background-color: white">      </span><br>         930:  <span style="background-color: white">      		src._verifyAllStreams();// the source need to be correct.</span><br>         931:  <span style="background-color: white">      </span><br>         932:  <span style="background-color: white">      		int srcPathIndexStart = src.getPathStart(srcPathIndex);</span><br>         933:  <span style="background-color: white">      		int srcPathSize = src.getPathSize(srcPathIndex);</span><br>         934:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>         935:  <span style="background-color: white">      		int offset = src.isClosedPath(srcPathIndex) &amp;&amp; !bForward ? 1 : 0;</span><br>         936:  <span style="background-color: white">      </span><br>         937:  <span style="background-color: white">      		_resizeImpl(m_pointCount + srcPathSize);</span><br>         938:  <span style="background-color: white">      		_verifyAllStreams();</span><br>         939:  <span style="background-color: white">      		int pathIndexStart = pathIndex &lt; oldPathCount ? getPathStart(pathIndex)</span><br>         940:  <span style="background-color: white">      				: oldPointCount;</span><br>         941:  <span style="background-color: white">      </span><br>         942:  <span style="background-color: white">      		// Copy all attribute values.</span><br>         943:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>         944:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>         945:  <span style="background-color: white">      			int isrcAttr = src.m_description.getAttributeIndex(semantics);</span><br>         946:  <span style="background-color: white">      </span><br>         947:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>         948:  <span style="background-color: white">      </span><br>         949:  <span style="background-color: white">      			if (isrcAttr &gt;= 0 &amp;&amp; src.m_vertexAttributes[isrcAttr] != null) {</span><br>         950:  <span style="background-color: white">      				if (offset != 0)</span><br>         951:  <span style="background-color: white">      					m_vertexAttributes[iattr].insertRange(</span><br>         952:  <span style="background-color: white">      							pathIndexStart * comp,</span><br>         953:  <span style="background-color: white">      							src.m_vertexAttributes[isrcAttr], comp</span><br>         954:  <span style="background-color: white">      									* srcPathIndexStart, comp, true, comp, comp</span><br>         955:  <span style="background-color: white">      									* oldPointCount);</span><br>         956:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange((pathIndexStart + offset)</span><br>         957:  <span style="background-color: white">      						* comp, src.m_vertexAttributes[isrcAttr], comp</span><br>         958:  <span style="background-color: white">      						* (srcPathIndexStart + offset), comp</span><br>         959:  <span style="background-color: white">      						* (srcPathSize - offset), bForward, comp, comp</span><br>         960:  <span style="background-color: white">      						* (oldPointCount + offset));</span><br>         961:  <span style="background-color: white">      			} else {</span><br>         962:  <span style="background-color: white">      				// Need to make room for the attributes, so we copy default</span><br>         963:  <span style="background-color: white">      				// values in</span><br>         964:  <span style="background-color: white">      </span><br>         965:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>         966:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(pathIndexStart * comp, v,</span><br>         967:  <span style="background-color: white">      						comp * srcPathSize, comp * oldPointCount);</span><br>         968:  <span style="background-color: white">      			}</span><br>         969:  <span style="background-color: white">      		}</span><br>         970:  <span style="background-color: white">      </span><br>         971:  <span style="background-color: white">      		int newPointCount = oldPointCount + srcPathSize;</span><br>         972:  <span style="background-color: white">      		m_paths.add(newPointCount);</span><br>         973:  <span style="background-color: white">      </span><br>         974:  <span style="background-color: white">      		for (int ipath = oldPathCount; ipath &gt;= pathIndex + 1; ipath--) {</span><br>         975:  <span style="background-color: white">      			int iend = m_paths.read(ipath - 1);</span><br>         976:  <span style="background-color: white">      			m_paths.write(ipath, iend + srcPathSize);</span><br>         977:  <span style="background-color: white">      		}</span><br>         978:  <span style="background-color: white">      </span><br>         979:  <span style="background-color: white">      		// ========================== todo: NonLinearSegments =================</span><br>         980:  <span style="background-color: white">      		if (src.hasNonLinearSegments(srcPathIndex)) {</span><br>         981:  <span style="background-color: white">      </span><br>         982:  <span style="background-color: white">      		}</span><br>         983:  <span style="background-color: white">      </span><br>         984:  <span style="background-color: white">      		m_pathFlags.add((byte) 0);</span><br>         985:  <span style="background-color: white">      </span><br>         986:  <span style="background-color: white">      		// _ASSERT(m_pathFlags.size() == m_paths.size());</span><br>         987:  <span style="background-color: white">      </span><br>         988:  <span style="background-color: white">      		for (int ipath = oldPathCount - 1; ipath &gt;= pathIndex + 1; ipath--) {</span><br>         989:  <span style="background-color: white">      			byte flags = m_pathFlags.read(ipath);</span><br>         990:  <span style="background-color: white">      			flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>         991:  <span style="background-color: white">      			m_pathFlags.write(ipath + 1, flags);</span><br>         992:  <span style="background-color: white">      		}</span><br>         993:  <span style="background-color: white">      </span><br>         994:  <span style="background-color: white">      		AttributeStreamOfInt8 srcPathFlags = src.getPathFlagsStreamRef();</span><br>         995:  <span style="background-color: white">      		byte flags = srcPathFlags.read(srcPathIndex);</span><br>         996:  <span style="background-color: white">      		flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>         997:  <span style="background-color: white">      </span><br>         998:  <span style="background-color: white">      		if (m_bPolygon)</span><br>         999:  <span style="background-color: white">      			flags |= (byte) PathFlags.enumClosed;</span><br>        1000:  <span style="background-color: white">      </span><br>        1001:  <span style="background-color: white">      		m_pathFlags.write(pathIndex, flags);</span><br>        1002:  <span style="background-color: white">      	}</span><br>        1003:  <span style="background-color: white">      </span><br>        1004:  <span style="background-color: white">      	public void insertPath(int pathIndex, Point2D[] points, int pointsOffset,</span><br>        1005:  <span style="background-color: white">      			int count, boolean bForward) {</span><br>        1006:  <span style="background-color: white">      		int oldPathCount = getPathCount();</span><br>        1007:  <span style="background-color: white">      		if (pathIndex &gt; oldPathCount)</span><br>        1008:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>        1009:  <span style="background-color: white">      </span><br>        1010:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>        1011:  <span style="background-color: white">      			pathIndex = oldPathCount;</span><br>        1012:  <span style="background-color: white">      </span><br>        1013:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>        1014:  <span style="background-color: white">      </span><br>        1015:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>        1016:  <span style="background-color: white">      </span><br>        1017:  <span style="background-color: white">      		// Copy all attribute values.</span><br>        1018:  <span style="background-color: white">      		if (points != null) {</span><br>        1019:  <span style="background-color: white">      			_resizeImpl(m_pointCount + count);</span><br>        1020:  <span style="background-color: white">      			_verifyAllStreams();</span><br>        1021:  <span style="background-color: white">      </span><br>        1022:  <span style="background-color: white">      			int pathStart = pathIndex &lt; oldPathCount ? getPathStart(pathIndex)</span><br>        1023:  <span style="background-color: white">      					: oldPointCount;</span><br>        1024:  <span style="background-color: white">      </span><br>        1025:  <span style="background-color: white">      			for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>        1026:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>        1027:  <span style="background-color: white">      </span><br>        1028:  <span style="background-color: white">      				if (semantics == VertexDescription.Semantics.POSITION) {</span><br>        1029:  <span style="background-color: white">      					// copy range to make place for new vertices</span><br>        1030:  <span style="background-color: white">      					m_vertexAttributes[iattr].writeRange(</span><br>        1031:  <span style="background-color: white">      							2 * (pathStart + count),</span><br>        1032:  <span style="background-color: white">      							2 * (oldPointCount - pathIndex),</span><br>        1033:  <span style="background-color: white">      							m_vertexAttributes[iattr], 2 * pathStart, true, 2);</span><br>        1034:  <span style="background-color: white">      </span><br>        1035:  <span style="background-color: white">      					AttributeStreamOfDbl position = (AttributeStreamOfDbl) (AttributeStreamBase) getAttributeStreamRef(semantics);</span><br>        1036:  <span style="background-color: white">      </span><br>        1037:  <span style="background-color: white">      					int j = pathStart;</span><br>        1038:  <span style="background-color: white">      					for (int i = 0; i &lt; count; i++, j++) {</span><br>        1039:  <span style="background-color: white">      						int index = (bForward ? pointsOffset + i : pointsOffset</span><br>        1040:  <span style="background-color: white">      								+ count - i - 1);</span><br>        1041:  <span style="background-color: white">      						position.write(2 * j, points[index].x);</span><br>        1042:  <span style="background-color: white">      						position.write(2 * j + 1, points[index].y);</span><br>        1043:  <span style="background-color: white">      					}</span><br>        1044:  <span style="background-color: white">      				} else {</span><br>        1045:  <span style="background-color: white">      					// Need to make room for the attributes, so we copy default</span><br>        1046:  <span style="background-color: white">      					// values in</span><br>        1047:  <span style="background-color: white">      </span><br>        1048:  <span style="background-color: white">      					int comp = VertexDescription.getComponentCount(semantics);</span><br>        1049:  <span style="background-color: white">      					double v = VertexDescription.getDefaultValue(semantics);</span><br>        1050:  <span style="background-color: white">      					m_vertexAttributes[iattr].insertRange(pathStart * comp, v,</span><br>        1051:  <span style="background-color: white">      							comp * count, comp * oldPointCount);</span><br>        1052:  <span style="background-color: white">      				}</span><br>        1053:  <span style="background-color: white">      			}</span><br>        1054:  <span style="background-color: white">      		} else {</span><br>        1055:  <span style="background-color: white">      			_verifyAllStreams();</span><br>        1056:  <span style="background-color: white">      		}</span><br>        1057:  <span style="background-color: white">      </span><br>        1058:  <span style="background-color: white">      		m_paths.add(m_pointCount);</span><br>        1059:  <span style="background-color: white">      </span><br>        1060:  <span style="background-color: white">      		for (int ipath = oldPathCount; ipath &gt;= pathIndex + 1; ipath--) {</span><br>        1061:  <span style="background-color: white">      			int iend = m_paths.read(ipath - 1);</span><br>        1062:  <span style="background-color: white">      			m_paths.write(ipath, iend + count);</span><br>        1063:  <span style="background-color: white">      		}</span><br>        1064:  <span style="background-color: white">      </span><br>        1065:  <span style="background-color: white">      		m_pathFlags.add((byte) 0);</span><br>        1066:  <span style="background-color: white">      </span><br>        1067:  <span style="background-color: white">      		// _ASSERT(m_pathFlags.size() == m_paths.size());</span><br>        1068:  <span style="background-color: white">      </span><br>        1069:  <span style="background-color: white">      		for (int ipath = oldPathCount - 1; ipath &gt;= pathIndex + 1; ipath--) {</span><br>        1070:  <span style="background-color: white">      			byte flags = m_pathFlags.read(ipath);</span><br>        1071:  <span style="background-color: white">      			flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>        1072:  <span style="background-color: white">      			m_pathFlags.write(ipath + 1, flags);</span><br>        1073:  <span style="background-color: white">      		}</span><br>        1074:  <span style="background-color: white">      </span><br>        1075:  <span style="background-color: white">      		if (m_bPolygon)</span><br>        1076:  <span style="background-color: white">      			m_pathFlags.write(pathIndex, (byte) PathFlags.enumClosed);</span><br>        1077:  <span style="background-color: white">      	}</span><br>        1078:  <span style="background-color: white">      </span><br>        1079:  <span style="background-color: white">      	public void insertPoints(int pathIndex, int beforePointIndex,</span><br>        1080:  <span style="background-color: white">      			MultiPathImpl src, int srcPathIndex, int srcPointIndexFrom,</span><br>        1081:  <span style="background-color: white">      			int srcPointCount, boolean bForward) {</span><br>        1082:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>        1083:  <span style="background-color: white">      			pathIndex = getPathCount();</span><br>        1084:  <span style="background-color: white">      </span><br>        1085:  <span style="background-color: white">      		if (srcPathIndex &lt; 0)</span><br>        1086:  <span style="background-color: white">      			srcPathIndex = src.getPathCount() - 1;</span><br>        1087:  <span style="background-color: white">      </span><br>        1088:  <span style="background-color: white">      		if (pathIndex &gt; getPathCount() || beforePointIndex &gt;= 0</span><br>        1089:  <span style="background-color: white">      				&amp;&amp; beforePointIndex &gt; getPathSize(pathIndex)</span><br>        1090:  <span style="background-color: white">      				|| srcPathIndex &gt;= src.getPathCount()</span><br>        1091:  <span style="background-color: white">      				|| srcPointCount &gt; src.getPathSize(srcPathIndex))</span><br>        1092:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>        1093:  <span style="background-color: white">      </span><br>        1094:  <span style="background-color: white">      		if (srcPointCount == 0)</span><br>        1095:  <span style="background-color: white">      			return;</span><br>        1096:  <span style="background-color: white">      </span><br>        1097:  <span style="background-color: white">      		mergeVertexDescription(src.m_description);</span><br>        1098:  <span style="background-color: white">      </span><br>        1099:  <span style="background-color: white">      		if (pathIndex == getPathCount())// adding a new path.</span><br>        1100:  <span style="background-color: white">      		{</span><br>        1101:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>        1102:  <span style="background-color: white">      </span><br>        1103:  <span style="background-color: white">      			byte flags = src.m_pathFlags.read(srcPathIndex);</span><br>        1104:  <span style="background-color: white">      			flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>        1105:  <span style="background-color: white">      </span><br>        1106:  <span style="background-color: white">      			if (!m_bPolygon)</span><br>        1107:  <span style="background-color: white">      				m_pathFlags.add(flags);</span><br>        1108:  <span style="background-color: white">      			else</span><br>        1109:  <span style="background-color: white">      				m_pathFlags.add((byte) (flags | PathFlags.enumClosed));</span><br>        1110:  <span style="background-color: white">      		}</span><br>        1111:  <span style="background-color: white">      </span><br>        1112:  <span style="background-color: white">      		if (beforePointIndex &lt; 0)</span><br>        1113:  <span style="background-color: white">      			beforePointIndex = getPathSize(pathIndex);</span><br>        1114:  <span style="background-color: white">      </span><br>        1115:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>        1116:  <span style="background-color: white">      		_resizeImpl(m_pointCount + srcPointCount);</span><br>        1117:  <span style="background-color: white">      		_verifyAllStreams();</span><br>        1118:  <span style="background-color: white">      		src._verifyAllStreams();</span><br>        1119:  <span style="background-color: white">      </span><br>        1120:  <span style="background-color: white">      		int pathStart = getPathStart(pathIndex);</span><br>        1121:  <span style="background-color: white">      		int absoluteIndex = pathStart + beforePointIndex;</span><br>        1122:  <span style="background-color: white">      </span><br>        1123:  <span style="background-color: white">      		if (srcPointCount &lt; 0)</span><br>        1124:  <span style="background-color: white">      			srcPointCount = src.getPathSize(srcPathIndex);</span><br>        1125:  <span style="background-color: white">      </span><br>        1126:  <span style="background-color: white">      		int srcPathStart = src.getPathStart(srcPathIndex);</span><br>        1127:  <span style="background-color: white">      		int srcAbsoluteIndex = srcPathStart + srcPointCount;</span><br>        1128:  <span style="background-color: white">      </span><br>        1129:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>        1130:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>        1131:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>        1132:  <span style="background-color: white">      </span><br>        1133:  <span style="background-color: white">      			int isrcAttr = src.m_description.getAttributeIndex(semantics);</span><br>        1134:  <span style="background-color: white">      			if (isrcAttr &lt; 0 || src.m_vertexAttributes[isrcAttr] == null) // The</span><br>        1135:  <span style="background-color: white">      																			// source</span><br>        1136:  <span style="background-color: white">      																			// does</span><br>        1137:  <span style="background-color: white">      																			// not</span><br>        1138:  <span style="background-color: white">      																			// have</span><br>        1139:  <span style="background-color: white">      																			// the</span><br>        1140:  <span style="background-color: white">      																			// attribute.</span><br>        1141:  <span style="background-color: white">      			{</span><br>        1142:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>        1143:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(comp * absoluteIndex, v,</span><br>        1144:  <span style="background-color: white">      						srcAbsoluteIndex * comp, comp * oldPointCount);</span><br>        1145:  <span style="background-color: white">      				continue;</span><br>        1146:  <span style="background-color: white">      			}</span><br>        1147:  <span style="background-color: white">      </span><br>        1148:  <span style="background-color: white">      			// add vertices to the given stream</span><br>        1149:  <span style="background-color: white">      			m_vertexAttributes[iattr].insertRange(comp</span><br>        1150:  <span style="background-color: white">      					* (pathStart + beforePointIndex),</span><br>        1151:  <span style="background-color: white">      					src.m_vertexAttributes[isrcAttr], comp</span><br>        1152:  <span style="background-color: white">      							* (srcPathStart + srcPointIndexFrom), srcPointCount</span><br>        1153:  <span style="background-color: white">      							* comp, bForward, comp, comp * oldPointCount);</span><br>        1154:  <span style="background-color: white">      		}</span><br>        1155:  <span style="background-color: white">      </span><br>        1156:  <span style="background-color: white">      		if (hasNonLinearSegments()) {// TODO: probably a bug here when a new</span><br>        1157:  <span style="background-color: white">      										// path is added.</span><br>        1158:  <span style="background-color: white">      			m_segmentFlags.writeRange((getPathStart(pathIndex)</span><br>        1159:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount), (oldPointCount</span><br>        1160:  <span style="background-color: white">      					- getPathStart(pathIndex) - beforePointIndex),</span><br>        1161:  <span style="background-color: white">      					m_segmentFlags,</span><br>        1162:  <span style="background-color: white">      					(getPathStart(pathIndex) + beforePointIndex), true, 1);</span><br>        1163:  <span style="background-color: white">      			m_segmentParamIndex.writeRange((getPathStart(pathIndex)</span><br>        1164:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount), (oldPointCount</span><br>        1165:  <span style="background-color: white">      					- getPathStart(pathIndex) - beforePointIndex),</span><br>        1166:  <span style="background-color: white">      					m_segmentParamIndex,</span><br>        1167:  <span style="background-color: white">      					(getPathStart(pathIndex) + beforePointIndex), true, 1);</span><br>        1168:  <span style="background-color: white">      			for (int i = getPathStart(pathIndex) + beforePointIndex, n = getPathStart(pathIndex)</span><br>        1169:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount; i &lt; n; i++) {</span><br>        1170:  <span style="background-color: white">      				m_segmentFlags.write(i, (byte) SegmentFlags.enumLineSeg);</span><br>        1171:  <span style="background-color: white">      				m_segmentParamIndex.write(i, -1);</span><br>        1172:  <span style="background-color: white">      			}</span><br>        1173:  <span style="background-color: white">      		}</span><br>        1174:  <span style="background-color: white">      </span><br>        1175:  <span style="background-color: white">      		if (src.hasNonLinearSegments(srcPathIndex)) {</span><br>        1176:  <span style="background-color: white">      			// TODO: implement me. For example as a while loop over all curves.</span><br>        1177:  <span style="background-color: white">      			// Replace, calling ReplaceSegment</span><br>        1178:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>        1179:  <span style="background-color: white">      		}</span><br>        1180:  <span style="background-color: white">      </span><br>        1181:  <span style="background-color: white">      		for (int ipath = pathIndex + 1, npaths = getPathCount(); ipath &lt;= npaths; ipath++) {</span><br>        1182:  <span style="background-color: white">      			int num = m_paths.read(ipath);</span><br>        1183:  <span style="background-color: white">      			m_paths.write(ipath, num + srcPointCount);</span><br>        1184:  <span style="background-color: white">      		}</span><br>        1185:  <span style="background-color: white">      	}</span><br>        1186:  <span style="background-color: white">      </span><br>        1187:  <span style="background-color: white">      	public void insertPoints(int pathIndex, int beforePointIndex,</span><br>        1188:  <span style="background-color: white">      			Point2D[] src, int srcPointIndexFrom, int srcPointCount,</span><br>        1189:  <span style="background-color: white">      			boolean bForward) {</span><br>        1190:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>        1191:  <span style="background-color: white">      			pathIndex = getPathCount();</span><br>        1192:  <span style="background-color: white">      </span><br>        1193:  <span style="background-color: white">      		if (pathIndex &gt; getPathCount()</span><br>        1194:  <span style="background-color: white">      				|| beforePointIndex &gt; getPathSize(pathIndex)</span><br>        1195:  <span style="background-color: white">      				|| srcPointIndexFrom &lt; 0 || srcPointCount &gt; src.length)</span><br>        1196:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>        1197:  <span style="background-color: white">      </span><br>        1198:  <span style="background-color: white">      		if (srcPointCount == 0)</span><br>        1199:  <span style="background-color: white">      			return;</span><br>        1200:  <span style="background-color: white">      </span><br>        1201:  <span style="background-color: white">      		if (pathIndex == getPathCount())// adding a new path.</span><br>        1202:  <span style="background-color: white">      		{</span><br>        1203:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>        1204:  <span style="background-color: white">      </span><br>        1205:  <span style="background-color: white">      			if (!m_bPolygon)</span><br>        1206:  <span style="background-color: white">      				m_pathFlags.add((byte) 0);</span><br>        1207:  <span style="background-color: white">      			else</span><br>        1208:  <span style="background-color: white">      				m_pathFlags.add((byte) PathFlags.enumClosed);</span><br>        1209:  <span style="background-color: white">      		}</span><br>        1210:  <span style="background-color: white">      </span><br>        1211:  <span style="background-color: white">      		if (beforePointIndex &lt; 0)</span><br>        1212:  <span style="background-color: white">      			beforePointIndex = getPathSize(pathIndex);</span><br>        1213:  <span style="background-color: white">      </span><br>        1214:  <span style="background-color: white">      		_verifyAllStreams();</span><br>        1215:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>        1216:  <span style="background-color: white">      		_resizeImpl(m_pointCount + srcPointCount);</span><br>        1217:  <span style="background-color: white">      		_verifyAllStreams();</span><br>        1218:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>        1219:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>        1220:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>        1221:  <span style="background-color: white">      			// copy range to make place for new vertices</span><br>        1222:  <span style="background-color: white">      			m_vertexAttributes[iattr]</span><br>        1223:  <span style="background-color: white">      					.writeRange(</span><br>        1224:  <span style="background-color: white">      							comp</span><br>        1225:  <span style="background-color: white">      									* (getPathStart(pathIndex)</span><br>        1226:  <span style="background-color: white">      											+ beforePointIndex + srcPointCount),</span><br>        1227:  <span style="background-color: white">      							(oldPointCount - getPathStart(pathIndex) - beforePointIndex)</span><br>        1228:  <span style="background-color: white">      									* comp,</span><br>        1229:  <span style="background-color: white">      							m_vertexAttributes[iattr],</span><br>        1230:  <span style="background-color: white">      							comp * (getPathStart(pathIndex) + beforePointIndex),</span><br>        1231:  <span style="background-color: white">      							true, comp);</span><br>        1232:  <span style="background-color: white">      </span><br>        1233:  <span style="background-color: white">      			if (iattr == 0) {</span><br>        1234:  <span style="background-color: white">      				// add vertices to the given stream</span><br>        1235:  <span style="background-color: white">      				((AttributeStreamOfDbl) (AttributeStreamBase) m_vertexAttributes[iattr])</span><br>        1236:  <span style="background-color: white">      						.writeRange(comp</span><br>        1237:  <span style="background-color: white">      								* (getPathStart(pathIndex) + beforePointIndex),</span><br>        1238:  <span style="background-color: white">      								srcPointCount, src, srcPointIndexFrom, bForward);</span><br>        1239:  <span style="background-color: white">      			} else {</span><br>        1240:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>        1241:  <span style="background-color: white">      				m_vertexAttributes[iattr].setRange(v,</span><br>        1242:  <span style="background-color: white">      						(getPathStart(pathIndex) + beforePointIndex) * comp,</span><br>        1243:  <span style="background-color: white">      						srcPointCount * comp);</span><br>        1244:  <span style="background-color: white">      			}</span><br>        1245:  <span style="background-color: white">      		}</span><br>        1246:  <span style="background-color: white">      </span><br>        1247:  <span style="background-color: white">      		if (hasNonLinearSegments()) {</span><br>        1248:  <span style="background-color: white">      			m_segmentFlags.writeRange((getPathStart(pathIndex)</span><br>        1249:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount), (oldPointCount</span><br>        1250:  <span style="background-color: white">      					- getPathStart(pathIndex) - beforePointIndex),</span><br>        1251:  <span style="background-color: white">      					m_segmentFlags,</span><br>        1252:  <span style="background-color: white">      					(getPathStart(pathIndex) + beforePointIndex), true, 1);</span><br>        1253:  <span style="background-color: white">      			m_segmentParamIndex.writeRange((getPathStart(pathIndex)</span><br>        1254:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount), (oldPointCount</span><br>        1255:  <span style="background-color: white">      					- getPathStart(pathIndex) - beforePointIndex),</span><br>        1256:  <span style="background-color: white">      					m_segmentParamIndex,</span><br>        1257:  <span style="background-color: white">      					(getPathStart(pathIndex) + beforePointIndex), true, 1);</span><br>        1258:  <span style="background-color: white">      			m_segmentFlags.setRange((byte) SegmentFlags.enumLineSeg,</span><br>        1259:  <span style="background-color: white">      					getPathStart(pathIndex) + beforePointIndex, srcPointCount);</span><br>        1260:  <span style="background-color: white">      			m_segmentParamIndex.setRange(-1, getPathStart(pathIndex)</span><br>        1261:  <span style="background-color: white">      					+ beforePointIndex, srcPointCount);</span><br>        1262:  <span style="background-color: white">      		}</span><br>        1263:  <span style="background-color: white">      </span><br>        1264:  <span style="background-color: white">      		for (int ipath = pathIndex + 1, npaths = getPathCount(); ipath &lt;= npaths; ipath++) {</span><br>        1265:  <span style="background-color: white">      			m_paths.write(ipath, m_paths.read(ipath) + srcPointCount);</span><br>        1266:  <span style="background-color: white">      		}</span><br>        1267:  <span style="background-color: white">      	}</span><br>        1268:  <span style="background-color: white">      </span><br>        1269:  <span style="background-color: white">      	public void insertPoint(int pathIndex, int beforePointIndex, Point2D pt) {</span><br>        1270:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>        1271:  <span style="background-color: white">      </span><br>        1272:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>        1273:  <span style="background-color: white">      			pathIndex = getPathCount();</span><br>        1274:  <span style="background-color: white">      </span><br>        1275:  <span style="background-color: white">      		if (pathIndex &gt;= pathCount || beforePointIndex &gt; getPathSize(pathIndex))</span><br>        1276:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>        1277:  <span style="background-color: white">      </span><br>        1278:  <span style="background-color: white">      		if (pathIndex == getPathCount())// adding a new path.</span><br>        1279:  <span style="background-color: white">      		{</span><br>        1280:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>        1281:  <span style="background-color: white">      </span><br>        1282:  <span style="background-color: white">      			if (!m_bPolygon)</span><br>        1283:  <span style="background-color: white">      				m_pathFlags.add((byte) 0);</span><br>        1284:  <span style="background-color: white">      			else</span><br>        1285:  <span style="background-color: white">      				m_pathFlags.add((byte) PathFlags.enumClosed);</span><br>        1286:  <span style="background-color: white">      		}</span><br>        1287:  <span style="background-color: white">      </span><br>        1288:  <span style="background-color: white">      		if (beforePointIndex &lt; 0)</span><br>        1289:  <span style="background-color: white">      			beforePointIndex = getPathSize(pathIndex);</span><br>        1290:  <span style="background-color: white">      </span><br>        1291:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>        1292:  <span style="background-color: white">      		_resizeImpl(m_pointCount + 1);</span><br>        1293:  <span style="background-color: white">      		_verifyAllStreams();</span><br>        1294:  <span style="background-color: white">      </span><br>        1295:  <span style="background-color: white">      		int pathStart = getPathStart(pathIndex);</span><br>        1296:  <span style="background-color: white">      </span><br>        1297:  <span style="background-color: white">      		((AttributeStreamOfDbl) (AttributeStreamBase) m_vertexAttributes[0])</span><br>        1298:  <span style="background-color: white">      				.insert(2 * (pathStart + beforePointIndex), pt,</span><br>        1299:  <span style="background-color: white">      						2 * oldPointCount);</span><br>        1300:  <span style="background-color: white">      </span><br>        1301:  <span style="background-color: white">      		for (int iattr = 1, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>        1302:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>        1303:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>        1304:  <span style="background-color: white">      </span><br>        1305:  <span style="background-color: white">      			// Need to make room for the attribute, so we copy a default value</span><br>        1306:  <span style="background-color: white">      			// in</span><br>        1307:  <span style="background-color: white">      			double v = VertexDescription.getDefaultValue(semantics);</span><br>        1308:  <span style="background-color: white">      			m_vertexAttributes[iattr].insertRange(comp</span><br>        1309:  <span style="background-color: white">      					* (pathStart + beforePointIndex), v, comp, comp</span><br>        1310:  <span style="background-color: white">      					* oldPointCount);</span><br>        1311:  <span style="background-color: white">      		}</span><br>        1312:  <span style="background-color: white">      </span><br>        1313:  <span style="background-color: white">      		for (int ipath = pathIndex + 1, npaths = pathCount; ipath &lt;= npaths; ipath++) {</span><br>        1314:  <span style="background-color: white">      			m_paths.write(ipath, m_paths.read(ipath) + 1);</span><br>        1315:  <span style="background-color: white">      		}</span><br>        1316:  <span style="background-color: white">      	}</span><br>        1317:  <span style="background-color: white">      </span><br>        1318:  <span style="background-color: white">      	public void insertPoint(int pathIndex, int beforePointIndex, Point pt) {</span><br>        1319:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>        1320:  <span style="background-color: white">      </span><br>        1321:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>        1322:  <span style="background-color: white">      			pathIndex = getPathCount();</span><br>        1323:  <span style="background-color: white">      </span><br>        1324:  <span style="background-color: white">      		if (pathIndex &gt;= pathCount || beforePointIndex &gt; getPathSize(pathIndex))</span><br>        1325:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>        1326:  <span style="background-color: white">      </span><br>        1327:  <span style="background-color: white">      		if (pathIndex == getPathCount())// adding a new path.</span><br>        1328:  <span style="background-color: white">      		{</span><br>        1329:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>        1330:  <span style="background-color: white">      </span><br>        1331:  <span style="background-color: white">      			if (!m_bPolygon)</span><br>        1332:  <span style="background-color: white">      				m_pathFlags.add((byte) 0);</span><br>        1333:  <span style="background-color: white">      			else</span><br>        1334:  <span style="background-color: white">      				m_pathFlags.add((byte) PathFlags.enumClosed);</span><br>        1335:  <span style="background-color: white">      		}</span><br>        1336:  <span style="background-color: white">      </span><br>        1337:  <span style="background-color: white">      		if (beforePointIndex &lt; 0)</span><br>        1338:  <span style="background-color: white">      			beforePointIndex = getPathSize(pathIndex);</span><br>        1339:  <span style="background-color: white">      </span><br>        1340:  <span style="background-color: white">      		mergeVertexDescription(pt.getDescription());</span><br>        1341:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>        1342:  <span style="background-color: white">      		_resizeImpl(m_pointCount + 1);</span><br>        1343:  <span style="background-color: white">      		_verifyAllStreams();</span><br>        1344:  <span style="background-color: white">      </span><br>        1345:  <span style="background-color: white">      		int pathStart = getPathStart(pathIndex);</span><br>        1346:  <span style="background-color: white">      </span><br>        1347:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>        1348:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>        1349:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>        1350:  <span style="background-color: white">      </span><br>        1351:  <span style="background-color: white">      			if (pt.hasAttribute(semantics)) {</span><br>        1352:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertAttributes(comp</span><br>        1353:  <span style="background-color: white">      						* (pathStart + beforePointIndex), pt, semantics, comp</span><br>        1354:  <span style="background-color: white">      						* oldPointCount);</span><br>        1355:  <span style="background-color: white">      			} else {</span><br>        1356:  <span style="background-color: white">      				// Need to make room for the attribute, so we copy a default</span><br>        1357:  <span style="background-color: white">      				// value in</span><br>        1358:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>        1359:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(comp</span><br>        1360:  <span style="background-color: white">      						* (pathStart + beforePointIndex), v, comp, comp</span><br>        1361:  <span style="background-color: white">      						* oldPointCount);</span><br>        1362:  <span style="background-color: white">      			}</span><br>        1363:  <span style="background-color: white">      		}</span><br>        1364:  <span style="background-color: white">      </span><br>        1365:  <span style="background-color: white">      		for (int ipath = pathIndex + 1, npaths = pathCount; ipath &lt;= npaths; ipath++) {</span><br>        1366:  <span style="background-color: white">      			m_paths.write(ipath, m_paths.read(ipath) + 1);</span><br>        1367:  <span style="background-color: white">      		}</span><br>        1368:  <span style="background-color: white">      </span><br>        1369:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>        1370:  <span style="background-color: white">      	}</span><br>        1371:  <span style="background-color: white">      </span><br>        1372:  <span style="background-color: white">      	public void removePoint(int pathIndex, int pointIndex) {</span><br>        1373:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>        1374:  <span style="background-color: white">      </span><br>        1375:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>        1376:  <span style="background-color: white">      			pathIndex = pathCount - 1;</span><br>        1377:  <span style="background-color: white">      </span><br>        1378:  <span style="background-color: white">      		if (pathIndex &gt;= pathCount || pointIndex &gt;= getPathSize(pathIndex))</span><br>        1379:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>        1380:  <span style="background-color: white">      </span><br>        1381:  <span style="background-color: white">      		_verifyAllStreams();</span><br>        1382:  <span style="background-color: white">      </span><br>        1383:  <span style="background-color: white">      		int pathStart = getPathStart(pathIndex);</span><br>        1384:  <span style="background-color: white">      </span><br>        1385:  <span style="background-color: white">      		if (pointIndex &lt; 0)</span><br>        1386:  <span style="background-color: white">      			pointIndex = getPathSize(pathIndex) - 1;</span><br>        1387:  <span style="background-color: white">      </span><br>        1388:  <span style="background-color: white">      		int absoluteIndex = pathStart + pointIndex;</span><br>        1389:  <span style="background-color: white">      </span><br>        1390:  <span style="background-color: white">      		// Remove the attribute values for the path</span><br>        1391:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>        1392:  <span style="background-color: white">      			if (m_vertexAttributes[iattr] != null) {</span><br>        1393:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>        1394:  <span style="background-color: white">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>        1395:  <span style="background-color: white">      				m_vertexAttributes[iattr].eraseRange(comp * absoluteIndex,</span><br>        1396:  <span style="background-color: white">      						comp, comp * m_pointCount);</span><br>        1397:  <span style="background-color: white">      			}</span><br>        1398:  <span style="background-color: white">      		}</span><br>        1399:  <span style="background-color: white">      </span><br>        1400:  <span style="background-color: white">      		for (int ipath = pathCount; ipath &gt;= pathIndex + 1; ipath--) {</span><br>        1401:  <span style="background-color: white">      			int iend = m_paths.read(ipath);</span><br>        1402:  <span style="background-color: white">      			m_paths.write(ipath, iend - 1);</span><br>        1403:  <span style="background-color: white">      		}</span><br>        1404:  <span style="background-color: white">      </span><br>        1405:  <span style="background-color: white">      		m_pointCount--;</span><br>        1406:  <span style="background-color: white">      		m_reservedPointCount--;</span><br>        1407:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>        1408:  <span style="background-color: white">      	}</span><br>        1409:  <span style="background-color: white">      </span><br>        1410:  <span style="background-color: white">      	public double calculatePathLength2D(int pathIndex) /* const */</span><br>        1411:  <span style="background-color: white">      	{</span><br>        1412:  <span style="background-color: white">      		SegmentIteratorImpl segIter = querySegmentIteratorAtVertex(getPathStart(pathIndex));</span><br>        1413:  <span style="background-color: white">      </span><br>        1414:  <span style="background-color: white">      		MathUtils.KahanSummator len = new MathUtils.KahanSummator(0);</span><br>        1415:  <span style="background-color: white">      		while (segIter.hasNextSegment()) {</span><br>        1416:  <span style="background-color: white">      			len.add(segIter.nextSegment().calculateLength2D());</span><br>        1417:  <span style="background-color: white">      		}</span><br>        1418:  <span style="background-color: white">      </span><br>        1419:  <span style="background-color: white">      		return len.getResult();</span><br>        1420:  <span style="background-color: white">      	}</span><br>        1421:  <span style="background-color: white">      </span><br>        1422:  <span style="background-color: white">      	double calculateSubLength2D(int from_path_index, int from_point_index,</span><br>        1423:  <span style="background-color: white">      			int to_path_index, int to_point_index) {</span><br>        1424:  <span style="background-color: white">      		int absolute_from_index = getPathStart(from_path_index)</span><br>        1425:  <span style="background-color: white">      				+ from_point_index;</span><br>        1426:  <span style="background-color: white">      		int absolute_to_index = getPathStart(to_path_index) + to_point_index;</span><br>        1427:  <span style="background-color: white">      </span><br>        1428:  <span style="background-color: white">      		if (absolute_to_index &lt; absolute_from_index || absolute_from_index &lt; 0</span><br>        1429:  <span style="background-color: white">      				|| absolute_to_index &gt; getPointCount() - 1)</span><br>        1430:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>        1431:  <span style="background-color: white">      </span><br>        1432:  <span style="background-color: white">      		SegmentIteratorImpl seg_iter = querySegmentIterator();</span><br>        1433:  <span style="background-color: white">      </span><br>        1434:  <span style="background-color: white">      		double sub_length = 0.0;</span><br>        1435:  <span style="background-color: white">      </span><br>        1436:  <span style="background-color: white">      		seg_iter.resetToVertex(absolute_from_index);</span><br>        1437:  <span style="background-color: white">      </span><br>        1438:  <span style="background-color: white">      		do {</span><br>        1439:  <span style="background-color: white">      			while (seg_iter.hasNextSegment()) {</span><br>        1440:  <span style="background-color: white">      				Segment segment = seg_iter.nextSegment();</span><br>        1441:  <span style="background-color: white">      </span><br>        1442:  <span style="background-color: white">      				if (seg_iter.getStartPointIndex() == absolute_to_index)</span><br>        1443:  <span style="background-color: white">      					break;</span><br>        1444:  <span style="background-color: white">      </span><br>        1445:  <span style="background-color: white">      				double segment_length = segment.calculateLength2D();</span><br>        1446:  <span style="background-color: white">      				sub_length += segment_length;</span><br>        1447:  <span style="background-color: white">      			}</span><br>        1448:  <span style="background-color: white">      </span><br>        1449:  <span style="background-color: white">      			if (seg_iter.getStartPointIndex() == absolute_to_index)</span><br>        1450:  <span style="background-color: white">      				break;</span><br>        1451:  <span style="background-color: white">      </span><br>        1452:  <span style="background-color: white">      		} while (seg_iter.nextPath());</span><br>        1453:  <span style="background-color: white">      </span><br>        1454:  <span style="background-color: white">      		return sub_length;</span><br>        1455:  <span style="background-color: white">      	}</span><br>        1456:  <span style="background-color: white">      </span><br>        1457:  <span style="background-color: white">      	double calculateSubLength2D(int path_index, int from_point_index,</span><br>        1458:  <span style="background-color: white">      			int to_point_index) {</span><br>        1459:  <span style="background-color: white">      		int absolute_from_index = getPathStart(path_index) + from_point_index;</span><br>        1460:  <span style="background-color: white">      		int absolute_to_index = getPathStart(path_index) + to_point_index;</span><br>        1461:  <span style="background-color: white">      </span><br>        1462:  <span style="background-color: white">      		if (absolute_from_index &lt; 0 || absolute_to_index &gt; getPointCount() - 1)</span><br>        1463:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>        1464:  <span style="background-color: white">      </span><br>        1465:  <span style="background-color: white">      		SegmentIteratorImpl seg_iter = querySegmentIterator();</span><br>        1466:  <span style="background-color: white">      </span><br>        1467:  <span style="background-color: white">      		if (absolute_from_index &gt; absolute_to_index) {</span><br>        1468:  <span style="background-color: white">      			if (!isClosedPath(path_index))</span><br>        1469:  <span style="background-color: white">      				throw new IllegalArgumentException(</span><br>        1470:  <span style="background-color: white">      						"cannot iterate across an open path");</span><br>        1471:  <span style="background-color: white">      </span><br>        1472:  <span style="background-color: white">      			seg_iter.setCirculator(true);</span><br>        1473:  <span style="background-color: white">      		}</span><br>        1474:  <span style="background-color: white">      </span><br>        1475:  <span style="background-color: white">      		double prev_length = 0.0;</span><br>        1476:  <span style="background-color: white">      		double sub_length = 0.0;</span><br>        1477:  <span style="background-color: white">      </span><br>        1478:  <span style="background-color: white">      		seg_iter.resetToVertex(absolute_from_index);</span><br>        1479:  <span style="background-color: white">      </span><br>        1480:  <span style="background-color: white">      		do {</span><br>        1481:  <span style="background-color: white">      			assert (seg_iter.hasNextSegment());</span><br>        1482:  <span style="background-color: white">      			sub_length += prev_length;</span><br>        1483:  <span style="background-color: white">      			Segment segment = seg_iter.nextSegment();</span><br>        1484:  <span style="background-color: white">      			prev_length = segment.calculateLength2D();</span><br>        1485:  <span style="background-color: white">      </span><br>        1486:  <span style="background-color: white">      		} while (seg_iter.getStartPointIndex() != absolute_to_index);</span><br>        1487:  <span style="background-color: white">      </span><br>        1488:  <span style="background-color: white">      		return sub_length;</span><br>        1489:  <span style="background-color: white">      	}</span><br>        1490:  <span style="background-color: white">      </span><br>        1491:  <span style="background-color: white">      	@Override</span><br>        1492:  <span style="background-color: white">      	public Geometry getBoundary() {</span><br>        1493:  <span style="background-color: white">      		return Boundary.calculate(this, null);</span><br>        1494:  <span style="background-color: white">      	}</span><br>        1495:  <span style="background-color: white">      </span><br>        1496:  <span style="background-color: white">      	// TODO: Add code fore interpolation type (none and angular)</span><br>        1497:  <span style="background-color: white">      	void interpolateAttributes(int from_path_index, int from_point_index,</span><br>        1498:  <span style="background-color: white">      			int to_path_index, int to_point_index) {</span><br>        1499:  <span style="background-color: white">      		for (int ipath = from_path_index; ipath &lt; to_path_index - 1; ipath++) {</span><br>        1500:  <span style="background-color: white">      			if (isClosedPath(ipath))</span><br>        1501:  <span style="background-color: white">      				throw new IllegalArgumentException(</span><br>        1502:  <span style="background-color: white">      						"cannot interpolate across closed paths");</span><br>        1503:  <span style="background-color: white">      		}</span><br>        1504:  <span style="background-color: white">      </span><br>        1505:  <span style="background-color: white">      		int nattr = m_description.getAttributeCount();</span><br>        1506:  <span style="background-color: white">      </span><br>        1507:  <span style="background-color: white">      		if (nattr == 1)</span><br>        1508:  <span style="background-color: white">      			return; // only has position</span><br>        1509:  <span style="background-color: white">      </span><br>        1510:  <span style="background-color: white">      		double sub_length = calculateSubLength2D(from_path_index,</span><br>        1511:  <span style="background-color: white">      				from_point_index, to_path_index, to_point_index);</span><br>        1512:  <span style="background-color: white">      </span><br>        1513:  <span style="background-color: white">      		if (sub_length == 0.0)</span><br>        1514:  <span style="background-color: white">      			return;</span><br>        1515:  <span style="background-color: white">      </span><br>        1516:  <span style="background-color: white">      		for (int iattr = 1; iattr &lt; nattr; iattr++) {</span><br>        1517:  <span style="background-color: white">      			int semantics = m_description.getSemantics(iattr);</span><br>        1518:  <span style="background-color: white">      </span><br>        1519:  <span style="background-color: white">      			int interpolation = VertexDescription.getInterpolation(semantics);</span><br>        1520:  <span style="background-color: white">      			if (interpolation == VertexDescription.Interpolation.ANGULAR)</span><br>        1521:  <span style="background-color: white">      				continue;</span><br>        1522:  <span style="background-color: white">      </span><br>        1523:  <span style="background-color: white">      			int components = VertexDescription.getComponentCount(semantics);</span><br>        1524:  <span style="background-color: white">      </span><br>        1525:  <span style="background-color: white">      			for (int ordinate = 0; ordinate &lt; components; ordinate++)</span><br>        1526:  <span style="background-color: white">      				interpolateAttributes_(semantics, from_path_index,</span><br>        1527:  <span style="background-color: white">      						from_point_index, to_path_index, to_point_index,</span><br>        1528:  <span style="background-color: white">      						sub_length, ordinate);</span><br>        1529:  <span style="background-color: white">      		}</span><br>        1530:  <span style="background-color: white">      	}</span><br>        1531:  <span style="background-color: white">      </span><br>        1532:  <span style="background-color: white">      	// TODO: Add code for interpolation type (none and angular)</span><br>        1533:  <span style="background-color: white">      	void interpolateAttributesForSemantics(int semantics, int from_path_index,</span><br>        1534:  <span style="background-color: white">      			int from_point_index, int to_path_index, int to_point_index) {</span><br>        1535:  <span style="background-color: white">      		if (semantics == VertexDescription.Semantics.POSITION)</span><br>        1536:  <span style="background-color: white">      			return;</span><br>        1537:  <span style="background-color: white">      </span><br>        1538:  <span style="background-color: white">      		if (!hasAttribute(semantics))</span><br>        1539:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>        1540:  <span style="background-color: white">      					"does not have the given attribute");</span><br>        1541:  <span style="background-color: white">      </span><br>        1542:  <span style="background-color: white">      		int interpolation = VertexDescription.getInterpolation(semantics);</span><br>        1543:  <span style="background-color: white">      		if (interpolation == VertexDescription.Interpolation.ANGULAR)</span><br>        1544:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>        1545:  <span style="background-color: white">      					"not implemented for the given semantics");</span><br>        1546:  <span style="background-color: white">      </span><br>        1547:  <span style="background-color: white">      		for (int ipath = from_path_index; ipath &lt; to_path_index - 1; ipath++) {</span><br>        1548:  <span style="background-color: white">      			if (isClosedPath(ipath))</span><br>        1549:  <span style="background-color: white">      				throw new IllegalArgumentException(</span><br>        1550:  <span style="background-color: white">      						"cannot interpolate across closed paths");</span><br>        1551:  <span style="background-color: white">      		}</span><br>        1552:  <span style="background-color: white">      </span><br>        1553:  <span style="background-color: white">      		double sub_length = calculateSubLength2D(from_path_index,</span><br>        1554:  <span style="background-color: white">      				from_point_index, to_path_index, to_point_index);</span><br>        1555:  <span style="background-color: white">      </span><br>        1556:  <span style="background-color: white">      		if (sub_length == 0.0)</span><br>        1557:  <span style="background-color: white">      			return;</span><br>        1558:  <span style="background-color: white">      </span><br>        1559:  <span style="background-color: white">      		int components = VertexDescription.getComponentCount(semantics);</span><br>        1560:  <span style="background-color: white">      </span><br>        1561:  <span style="background-color: white">      		for (int ordinate = 0; ordinate &lt; components; ordinate++)</span><br>        1562:  <span style="background-color: white">      			interpolateAttributes_(semantics, from_path_index,</span><br>        1563:  <span style="background-color: white">      					from_point_index, to_path_index, to_point_index,</span><br>        1564:  <span style="background-color: white">      					sub_length, ordinate);</span><br>        1565:  <span style="background-color: white">      	}</span><br>        1566:  <span style="background-color: white">      </span><br>        1567:  <span style="background-color: white">      	void interpolateAttributes(int path_index, int from_point_index,</span><br>        1568:  <span style="background-color: white">      			int to_point_index) {</span><br>        1569:  <span style="background-color: white">      		int nattr = m_description.getAttributeCount();</span><br>        1570:  <span style="background-color: white">      </span><br>        1571:  <span style="background-color: white">      		if (nattr == 1)</span><br>        1572:  <span style="background-color: white">      			return; // only has position</span><br>        1573:  <span style="background-color: white">      </span><br>        1574:  <span style="background-color: white">      		double sub_length = calculateSubLength2D(path_index, from_point_index,</span><br>        1575:  <span style="background-color: white">      				to_point_index);</span><br>        1576:  <span style="background-color: white">      </span><br>        1577:  <span style="background-color: white">      		if (sub_length == 0.0)</span><br>        1578:  <span style="background-color: white">      			return;</span><br>        1579:  <span style="background-color: white">      </span><br>        1580:  <span style="background-color: white">      		for (int iattr = 1; iattr &lt; nattr; iattr++) {</span><br>        1581:  <span style="background-color: white">      			int semantics = m_description.getSemantics(iattr);</span><br>        1582:  <span style="background-color: white">      </span><br>        1583:  <span style="background-color: white">      			int interpolation = VertexDescription.getInterpolation(semantics);</span><br>        1584:  <span style="background-color: white">      			if (interpolation == VertexDescription.Interpolation.ANGULAR)</span><br>        1585:  <span style="background-color: white">      				continue;</span><br>        1586:  <span style="background-color: white">      </span><br>        1587:  <span style="background-color: white">      			int components = VertexDescription.getComponentCount(semantics);</span><br>        1588:  <span style="background-color: white">      </span><br>        1589:  <span style="background-color: white">      			for (int ordinate = 0; ordinate &lt; components; ordinate++)</span><br>        1590:  <span style="background-color: white">      				interpolateAttributes_(semantics, path_index, from_point_index,</span><br>        1591:  <span style="background-color: white">      						to_point_index, sub_length, ordinate);</span><br>        1592:  <span style="background-color: white">      		}</span><br>        1593:  <span style="background-color: white">      	}</span><br>        1594:  <span style="background-color: white">      </span><br>        1595:  <span style="background-color: white">      	void interpolateAttributesForSemantics(int semantics, int path_index,</span><br>        1596:  <span style="background-color: white">      			int from_point_index, int to_point_index) {</span><br>        1597:  <span style="background-color: white">      		if (semantics == VertexDescription.Semantics.POSITION)</span><br>        1598:  <span style="background-color: white">      			return;</span><br>        1599:  <span style="background-color: white">      </span><br>        1600:  <span style="background-color: white">      		if (!hasAttribute(semantics))</span><br>        1601:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>        1602:  <span style="background-color: white">      					"does not have the given attribute");</span><br>        1603:  <span style="background-color: white">      </span><br>        1604:  <span style="background-color: white">      		int interpolation = VertexDescription.getInterpolation(semantics);</span><br>        1605:  <span style="background-color: white">      		if (interpolation == VertexDescription.Interpolation.ANGULAR)</span><br>        1606:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>        1607:  <span style="background-color: white">      					"not implemented for the given semantics");</span><br>        1608:  <span style="background-color: white">      </span><br>        1609:  <span style="background-color: white">      		double sub_length = calculateSubLength2D(path_index, from_point_index,</span><br>        1610:  <span style="background-color: white">      				to_point_index);</span><br>        1611:  <span style="background-color: white">      </span><br>        1612:  <span style="background-color: white">      		if (sub_length == 0.0)</span><br>        1613:  <span style="background-color: white">      			return;</span><br>        1614:  <span style="background-color: white">      </span><br>        1615:  <span style="background-color: white">      		int components = VertexDescription.getComponentCount(semantics);</span><br>        1616:  <span style="background-color: white">      </span><br>        1617:  <span style="background-color: white">      		for (int ordinate = 0; ordinate &lt; components; ordinate++)</span><br>        1618:  <span style="background-color: white">      			interpolateAttributes_(semantics, path_index, from_point_index,</span><br>        1619:  <span style="background-color: white">      					to_point_index, sub_length, ordinate);</span><br>        1620:  <span style="background-color: white">      	}</span><br>        1621:  <span style="background-color: white">      </span><br>        1622:  <span style="background-color: white">      	// TODO: Add code fore interpolation type (none and angular)</span><br>        1623:  <span style="background-color: white">      	void interpolateAttributes_(int semantics, int from_path_index,</span><br>        1624:  <span style="background-color: white">      			int from_point_index, int to_path_index, int to_point_index,</span><br>        1625:  <span style="background-color: white">      			double sub_length, int ordinate) {</span><br>        1626:  <span style="background-color: white">      		SegmentIteratorImpl seg_iter = querySegmentIterator();</span><br>        1627:  <span style="background-color: white">      </span><br>        1628:  <span style="background-color: white">      		int absolute_from_index = getPathStart(from_path_index)</span><br>        1629:  <span style="background-color: white">      				+ from_point_index;</span><br>        1630:  <span style="background-color: white">      		int absolute_to_index = getPathStart(to_path_index) + to_point_index;</span><br>        1631:  <span style="background-color: white">      </span><br>        1632:  <span style="background-color: white">      		double from_attribute = getAttributeAsDbl(semantics,</span><br>        1633:  <span style="background-color: white">      				absolute_from_index, ordinate);</span><br>        1634:  <span style="background-color: white">      		double to_attribute = getAttributeAsDbl(semantics, absolute_to_index,</span><br>        1635:  <span style="background-color: white">      				ordinate);</span><br>        1636:  <span style="background-color: white">      		double interpolated_attribute = from_attribute;</span><br>        1637:  <span style="background-color: white">      		double cumulative_length = 0.0;</span><br>        1638:  <span style="background-color: white">      </span><br>        1639:  <span style="background-color: white">      		seg_iter.resetToVertex(absolute_from_index);</span><br>        1640:  <span style="background-color: white">      </span><br>        1641:  <span style="background-color: white">      		do {</span><br>        1642:  <span style="background-color: white">      			if (seg_iter.hasNextSegment()) {</span><br>        1643:  <span style="background-color: white">      				seg_iter.nextSegment();</span><br>        1644:  <span style="background-color: white">      </span><br>        1645:  <span style="background-color: white">      				if (seg_iter.getStartPointIndex() == absolute_to_index)</span><br>        1646:  <span style="background-color: white">      					return;</span><br>        1647:  <span style="background-color: white">      </span><br>        1648:  <span style="background-color: white">      				setAttribute(semantics, seg_iter.getStartPointIndex(),</span><br>        1649:  <span style="background-color: white">      						ordinate, interpolated_attribute);</span><br>        1650:  <span style="background-color: white">      </span><br>        1651:  <span style="background-color: white">      				seg_iter.previousSegment();</span><br>        1652:  <span style="background-color: white">      </span><br>        1653:  <span style="background-color: white">      				do {</span><br>        1654:  <span style="background-color: white">      					Segment segment = seg_iter.nextSegment();</span><br>        1655:  <span style="background-color: white">      </span><br>        1656:  <span style="background-color: white">      					if (seg_iter.getEndPointIndex() == absolute_to_index)</span><br>        1657:  <span style="background-color: white">      						return;</span><br>        1658:  <span style="background-color: white">      </span><br>        1659:  <span style="background-color: white">      					double segment_length = segment.calculateLength2D();</span><br>        1660:  <span style="background-color: white">      					cumulative_length += segment_length;</span><br>        1661:  <span style="background-color: white">      					double t = cumulative_length / sub_length;</span><br>        1662:  <span style="background-color: white">      					interpolated_attribute = MathUtils.lerp(from_attribute,  to_attribute, t);</span><br>        1663:  <span style="background-color: white">      </span><br>        1664:  <span style="background-color: white">      					if (!seg_iter.isClosingSegment())</span><br>        1665:  <span style="background-color: white">      						setAttribute(semantics, seg_iter.getEndPointIndex(),</span><br>        1666:  <span style="background-color: white">      								ordinate, interpolated_attribute);</span><br>        1667:  <span style="background-color: white">      </span><br>        1668:  <span style="background-color: white">      				} while (seg_iter.hasNextSegment());</span><br>        1669:  <span style="background-color: white">      			}</span><br>        1670:  <span style="background-color: white">      </span><br>        1671:  <span style="background-color: white">      		} while (seg_iter.nextPath());</span><br>        1672:  <span style="background-color: white">      	}</span><br>        1673:  <span style="background-color: white">      </span><br>        1674:  <span style="background-color: white">      	void interpolateAttributes_(int semantics, int path_index,</span><br>        1675:  <span style="background-color: white">      			int from_point_index, int to_point_index, double sub_length,</span><br>        1676:  <span style="background-color: white">      			int ordinate) {</span><br>        1677:  <span style="background-color: white">      		assert (m_bPolygon);</span><br>        1678:  <span style="background-color: white">      		SegmentIteratorImpl seg_iter = querySegmentIterator();</span><br>        1679:  <span style="background-color: white">      </span><br>        1680:  <span style="background-color: white">      		int absolute_from_index = getPathStart(path_index) + from_point_index;</span><br>        1681:  <span style="background-color: white">      		int absolute_to_index = getPathStart(path_index) + to_point_index;</span><br>        1682:  <span style="background-color: white">      </span><br>        1683:  <span style="background-color: white">      		if (absolute_to_index == absolute_from_index)</span><br>        1684:  <span style="background-color: white">      			return;</span><br>        1685:  <span style="background-color: white">      </span><br>        1686:  <span style="background-color: white">      		double from_attribute = getAttributeAsDbl(semantics,</span><br>        1687:  <span style="background-color: white">      				absolute_from_index, ordinate);</span><br>        1688:  <span style="background-color: white">      		double to_attribute = getAttributeAsDbl(semantics, absolute_to_index,</span><br>        1689:  <span style="background-color: white">      				ordinate);</span><br>        1690:  <span style="background-color: white">      		double cumulative_length = 0.0;</span><br>        1691:  <span style="background-color: white">      </span><br>        1692:  <span style="background-color: white">      		seg_iter.resetToVertex(absolute_from_index);</span><br>        1693:  <span style="background-color: white">      		seg_iter.setCirculator(true);</span><br>        1694:  <span style="background-color: white">      </span><br>        1695:  <span style="background-color: white">      		double prev_interpolated_attribute = from_attribute;</span><br>        1696:  <span style="background-color: white">      </span><br>        1697:  <span style="background-color: white">      		do {</span><br>        1698:  <span style="background-color: white">      			Segment segment = seg_iter.nextSegment();</span><br>        1699:  <span style="background-color: white">      			setAttribute(semantics, seg_iter.getStartPointIndex(), ordinate,</span><br>        1700:  <span style="background-color: white">      					prev_interpolated_attribute);</span><br>        1701:  <span style="background-color: white">      </span><br>        1702:  <span style="background-color: white">      			double segment_length = segment.calculateLength2D();</span><br>        1703:  <span style="background-color: white">      			cumulative_length += segment_length;</span><br>        1704:  <span style="background-color: white">      			double t = cumulative_length / sub_length;</span><br>        1705:  <span style="background-color: white">      			prev_interpolated_attribute = MathUtils.lerp(from_attribute, to_attribute, t);</span><br>        1706:  <span style="background-color: white">      </span><br>        1707:  <span style="background-color: white">      		} while (seg_iter.getEndPointIndex() != absolute_to_index);</span><br>        1708:  <span style="background-color: white">      	}</span><br>        1709:  <span style="background-color: white">      </span><br>        1710:  <span style="background-color: white">      	@Override</span><br>        1711:  <span style="background-color: white">      	public void setEmpty() {</span><br>        1712:  <span style="background-color: white">      		m_curveParamwritePoint = 0;</span><br>        1713:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>        1714:  <span style="background-color: white">      		m_paths = null;</span><br>        1715:  <span style="background-color: white">      		m_pathFlags = null;</span><br>        1716:  <span style="background-color: white">      		m_segmentParamIndex = null;</span><br>        1717:  <span style="background-color: white">      		m_segmentFlags = null;</span><br>        1718:  <span style="background-color: white">      		m_segmentParams = null;</span><br>        1719:  <span style="background-color: white">      		_setEmptyImpl();</span><br>        1720:  <span style="background-color: white">      	}</span><br>        1721:  <span style="background-color: white">      </span><br>        1722:  <span style="background-color: white">      	@Override</span><br>        1723:  <span style="background-color: white">      	public void applyTransformation(Transformation2D transform) {</span><br>        1724:  <span style="background-color: white">      		applyTransformation(transform, -1);</span><br>        1725:  <span style="background-color: white">      	}</span><br>        1726:  <span style="background-color: white">      </span><br>        1727:  <span style="background-color: white">      	public void applyTransformation(Transformation2D transform, int pathIndex) {</span><br>        1728:  <span style="background-color: white">      		if (isEmpty())</span><br>        1729:  <span style="background-color: white">      			return;</span><br>        1730:  <span style="background-color: white">      </span><br>        1731:  <span style="background-color: white">      		if (transform.isIdentity())</span><br>        1732:  <span style="background-color: white">      			return;</span><br>        1733:  <span style="background-color: white">      </span><br>        1734:  <span style="background-color: white">      		_verifyAllStreams();</span><br>        1735:  <span style="background-color: white">      		AttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];</span><br>        1736:  <span style="background-color: white">      		Point2D ptStart = new Point2D();</span><br>        1737:  <span style="background-color: white">      		Point2D ptControl = new Point2D();</span><br>        1738:  <span style="background-color: white">      </span><br>        1739:  <span style="background-color: white">      		boolean bHasNonLinear;</span><br>        1740:  <span style="background-color: white">      		int fistIdx;</span><br>        1741:  <span style="background-color: white">      		int lastIdx;</span><br>        1742:  <span style="background-color: white">      		if (pathIndex &lt; 0) {</span><br>        1743:  <span style="background-color: white">      			bHasNonLinear = hasNonLinearSegments();</span><br>        1744:  <span style="background-color: white">      			fistIdx = 0;</span><br>        1745:  <span style="background-color: white">      			lastIdx = m_pointCount;</span><br>        1746:  <span style="background-color: white">      		} else {</span><br>        1747:  <span style="background-color: white">      			bHasNonLinear = hasNonLinearSegments(pathIndex);</span><br>        1748:  <span style="background-color: white">      			fistIdx = getPathStart(pathIndex);</span><br>        1749:  <span style="background-color: white">      			lastIdx = getPathEnd(pathIndex);</span><br>        1750:  <span style="background-color: white">      		}</span><br>        1751:  <span style="background-color: white">      </span><br>        1752:  <span style="background-color: white">      		for (int ipoint = fistIdx; ipoint &lt; lastIdx; ipoint++) {</span><br>        1753:  <span style="background-color: white">      			ptStart.x = points.read(ipoint * 2);</span><br>        1754:  <span style="background-color: white">      			ptStart.y = points.read(ipoint * 2 + 1);</span><br>        1755:  <span style="background-color: white">      </span><br>        1756:  <span style="background-color: white">      			if (bHasNonLinear) {</span><br>        1757:  <span style="background-color: white">      				int segIndex = m_segmentParamIndex.read(ipoint);</span><br>        1758:  <span style="background-color: white">      				if (segIndex &gt;= 0) {</span><br>        1759:  <span style="background-color: white">      					int segmentType = (int) m_segmentFlags.read(ipoint);</span><br>        1760:  <span style="background-color: white">      					int type = segmentType &amp; SegmentFlags.enumSegmentMask;</span><br>        1761:  <span style="background-color: white">      					switch (type) {</span><br>        1762:  <span style="background-color: white">      					case SegmentFlags.enumBezierSeg: {</span><br>        1763:  <span style="background-color: white">      						ptControl.x = m_segmentParams.read(segIndex);</span><br>        1764:  <span style="background-color: white">      						ptControl.y = m_segmentParams.read(segIndex + 1);</span><br>        1765:  <span style="background-color: white">      						transform.transform(ptControl, ptControl);</span><br>        1766:  <span style="background-color: white">      						m_segmentParams.write(segIndex, ptControl.x);</span><br>        1767:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 1, ptControl.y);</span><br>        1768:  <span style="background-color: white">      </span><br>        1769:  <span style="background-color: white">      						ptControl.x = m_segmentParams.read(segIndex + 3);</span><br>        1770:  <span style="background-color: white">      						ptControl.y = m_segmentParams.read(segIndex + 4);</span><br>        1771:  <span style="background-color: white">      						transform.transform(ptControl, ptControl);</span><br>        1772:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 3, ptControl.x);</span><br>        1773:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 4, ptControl.y);</span><br>        1774:  <span style="background-color: white">      					}</span><br>        1775:  <span style="background-color: white">      						break;</span><br>        1776:  <span style="background-color: white">      					case SegmentFlags.enumArcSeg:</span><br>        1777:  <span style="background-color: white">      						throw GeometryException.GeometryInternalError();</span><br>        1778:  <span style="background-color: white">      </span><br>        1779:  <span style="background-color: white">      					}</span><br>        1780:  <span style="background-color: white">      				}</span><br>        1781:  <span style="background-color: white">      			}</span><br>        1782:  <span style="background-color: white">      </span><br>        1783:  <span style="background-color: white">      			transform.transform(ptStart, ptStart);</span><br>        1784:  <span style="background-color: white">      			points.write(ipoint * 2, ptStart.x);</span><br>        1785:  <span style="background-color: white">      			points.write(ipoint * 2 + 1, ptStart.y);</span><br>        1786:  <span style="background-color: white">      		}</span><br>        1787:  <span style="background-color: white">      </span><br>        1788:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>        1789:  <span style="background-color: white">      		// REFACTOR: reset the exact envelope only and transform the loose</span><br>        1790:  <span style="background-color: white">      		// envelope</span><br>        1791:  <span style="background-color: white">      	}</span><br>        1792:  <span style="background-color: white">      </span><br>        1793:  <span style="background-color: white">      	@Override</span><br>        1794:  <span style="background-color: white">      	public void applyTransformation(Transformation3D transform) {</span><br>        1795:  <span style="background-color: white">      		if (isEmpty())</span><br>        1796:  <span style="background-color: white">      			return;</span><br>        1797:  <span style="background-color: white">      </span><br>        1798:  <span style="background-color: white">      		addAttribute(VertexDescription.Semantics.Z);</span><br>        1799:  <span style="background-color: white">      		_verifyAllStreams();</span><br>        1800:  <span style="background-color: white">      		AttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];</span><br>        1801:  <span style="background-color: white">      		AttributeStreamOfDbl zs = (AttributeStreamOfDbl) m_vertexAttributes[1];</span><br>        1802:  <span style="background-color: white">      		Point3D ptStart = new Point3D();</span><br>        1803:  <span style="background-color: white">      		Point3D ptControl = new Point3D();</span><br>        1804:  <span style="background-color: white">      		boolean bHasNonLinear = hasNonLinearSegments();</span><br>        1805:  <span style="background-color: white">      		for (int ipoint = 0; ipoint &lt; m_pointCount; ipoint++) {</span><br>        1806:  <span style="background-color: white">      			ptStart.x = points.read(ipoint * 2);</span><br>        1807:  <span style="background-color: white">      			ptStart.y = points.read(ipoint * 2 + 1);</span><br>        1808:  <span style="background-color: white">      			ptStart.z = zs.read(ipoint);</span><br>        1809:  <span style="background-color: white">      </span><br>        1810:  <span style="background-color: white">      			if (bHasNonLinear) {</span><br>        1811:  <span style="background-color: white">      				int segIndex = m_segmentParamIndex.read(ipoint);</span><br>        1812:  <span style="background-color: white">      				if (segIndex &gt;= 0) {</span><br>        1813:  <span style="background-color: white">      					int segmentType = (int) m_segmentFlags.read(ipoint);</span><br>        1814:  <span style="background-color: white">      					int type = segmentType &amp; (int) SegmentFlags.enumSegmentMask;</span><br>        1815:  <span style="background-color: white">      					switch (type) {</span><br>        1816:  <span style="background-color: white">      					case SegmentFlags.enumBezierSeg: {</span><br>        1817:  <span style="background-color: white">      						ptControl.x = m_segmentParams.read(segIndex);</span><br>        1818:  <span style="background-color: white">      						ptControl.y = m_segmentParams.read(segIndex + 1);</span><br>        1819:  <span style="background-color: white">      						ptControl.z = m_segmentParams.read(segIndex + 2);</span><br>        1820:  <span style="background-color: white">      						ptControl = transform.transform(ptControl);</span><br>        1821:  <span style="background-color: white">      						m_segmentParams.write(segIndex, ptControl.x);</span><br>        1822:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 1, ptControl.y);</span><br>        1823:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 1, ptControl.z);</span><br>        1824:  <span style="background-color: white">      </span><br>        1825:  <span style="background-color: white">      						ptControl.x = m_segmentParams.read(segIndex + 3);</span><br>        1826:  <span style="background-color: white">      						ptControl.y = m_segmentParams.read(segIndex + 4);</span><br>        1827:  <span style="background-color: white">      						ptControl.z = m_segmentParams.read(segIndex + 5);</span><br>        1828:  <span style="background-color: white">      						ptControl = transform.transform(ptControl);</span><br>        1829:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 3, ptControl.x);</span><br>        1830:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 4, ptControl.y);</span><br>        1831:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 5, ptControl.z);</span><br>        1832:  <span style="background-color: white">      					}</span><br>        1833:  <span style="background-color: white">      						break;</span><br>        1834:  <span style="background-color: white">      					case SegmentFlags.enumArcSeg:</span><br>        1835:  <span style="background-color: white">      						throw GeometryException.GeometryInternalError();</span><br>        1836:  <span style="background-color: white">      </span><br>        1837:  <span style="background-color: white">      					}</span><br>        1838:  <span style="background-color: white">      				}</span><br>        1839:  <span style="background-color: white">      			}</span><br>        1840:  <span style="background-color: white">      </span><br>        1841:  <span style="background-color: white">      			ptStart = transform.transform(ptStart);</span><br>        1842:  <span style="background-color: white">      			points.write(ipoint * 2, ptStart.x);</span><br>        1843:  <span style="background-color: white">      			points.write(ipoint * 2 + 1, ptStart.y);</span><br>        1844:  <span style="background-color: white">      			zs.write(ipoint, ptStart.z);</span><br>        1845:  <span style="background-color: white">      		}</span><br>        1846:  <span style="background-color: white">      </span><br>        1847:  <span style="background-color: white">      		// REFACTOR: reset the exact envelope only and transform the loose</span><br>        1848:  <span style="background-color: white">      		// envelope</span><br>        1849:  <span style="background-color: white">      </span><br>        1850:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>        1851:  <span style="background-color: white">      	}</span><br>        1852:  <span style="background-color: white">      </span><br>        1853:  <span style="background-color: red">      	@Override</span><br>        1854:  <span style="background-color: white">      	protected void _verifyStreamsImpl() {</span><br>        1855:  <span style="background-color: red">      		if (m_paths == null) {</span><br>        1856:  <span style="background-color: white">      			m_paths = (AttributeStreamOfInt32) AttributeStreamBase</span><br>        1857:  <span style="background-color: white">      					.createIndexStream(1, 0);</span><br>        1858:  <span style="background-color: white">      			m_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase</span><br>        1859:  <span style="background-color: white">      					.createByteStream(1, (byte) 0);</span><br>        1860:  <span style="background-color: white">      		}</span><br>        1861:  <span style="background-color: white">      </span><br>        1862:  <span style="background-color: red">      		if (m_segmentFlags != null) {</span><br>        1863:  <span style="background-color: white">      			m_segmentFlags.resize(m_reservedPointCount,</span><br>        1864:  <span style="background-color: white">      					(byte) SegmentFlags.enumLineSeg);</span><br>        1865:  <span style="background-color: white">      			m_segmentParamIndex.resize(m_reservedPointCount, -1);</span><br>        1866:  <span style="background-color: white">      		}</span><br>        1867:  <span style="background-color: white">      	}</span><br>        1868:  <span style="background-color: white">      </span><br>        1869:  <span style="background-color: white">      	@Override</span><br>        1870:  <span style="background-color: white">      	void _copyToImpl(MultiVertexGeometryImpl dst) {</span><br>        1871:  <span style="background-color: white">      		MultiPathImpl dstPoly = (MultiPathImpl) dst;</span><br>        1872:  <span style="background-color: white">      		dstPoly.m_bPathStarted = false;</span><br>        1873:  <span style="background-color: white">      		dstPoly.m_curveParamwritePoint = m_curveParamwritePoint;</span><br>        1874:  <span style="background-color: white">      		dstPoly.m_fill_rule = m_fill_rule;</span><br>        1875:  <span style="background-color: white">      		</span><br>        1876:  <span style="background-color: white">      		if (m_paths != null)</span><br>        1877:  <span style="background-color: white">      			dstPoly.m_paths = new AttributeStreamOfInt32(m_paths);</span><br>        1878:  <span style="background-color: white">      		else</span><br>        1879:  <span style="background-color: white">      			dstPoly.m_paths = null;</span><br>        1880:  <span style="background-color: white">      </span><br>        1881:  <span style="background-color: white">      		if (m_pathFlags != null)</span><br>        1882:  <span style="background-color: white">      			dstPoly.m_pathFlags = new AttributeStreamOfInt8(m_pathFlags);</span><br>        1883:  <span style="background-color: white">      		else</span><br>        1884:  <span style="background-color: white">      			dstPoly.m_pathFlags = null;</span><br>        1885:  <span style="background-color: white">      </span><br>        1886:  <span style="background-color: white">      		if (m_segmentParamIndex != null)</span><br>        1887:  <span style="background-color: white">      			dstPoly.m_segmentParamIndex = new AttributeStreamOfInt32(</span><br>        1888:  <span style="background-color: white">      					m_segmentParamIndex);</span><br>        1889:  <span style="background-color: white">      		else</span><br>        1890:  <span style="background-color: white">      			dstPoly.m_segmentParamIndex = null;</span><br>        1891:  <span style="background-color: white">      </span><br>        1892:  <span style="background-color: white">      		if (m_segmentFlags != null)</span><br>        1893:  <span style="background-color: white">      			dstPoly.m_segmentFlags = new AttributeStreamOfInt8(m_segmentFlags);</span><br>        1894:  <span style="background-color: white">      		else</span><br>        1895:  <span style="background-color: white">      			dstPoly.m_segmentFlags = null;</span><br>        1896:  <span style="background-color: white">      </span><br>        1897:  <span style="background-color: white">      		if (m_segmentParams != null)</span><br>        1898:  <span style="background-color: white">      			dstPoly.m_segmentParams = new AttributeStreamOfDbl(m_segmentParams);</span><br>        1899:  <span style="background-color: white">      		else</span><br>        1900:  <span style="background-color: white">      			dstPoly.m_segmentParams = null;</span><br>        1901:  <span style="background-color: white">      </span><br>        1902:  <span style="background-color: white">      		dstPoly.m_cachedLength2D = m_cachedLength2D;</span><br>        1903:  <span style="background-color: white">      		dstPoly.m_cachedArea2D = m_cachedArea2D;</span><br>        1904:  <span style="background-color: white">      </span><br>        1905:  <span style="background-color: white">      		if (!_hasDirtyFlag(DirtyFlags.DirtyRingAreas2D)) {</span><br>        1906:  <span style="background-color: white">      			dstPoly.m_cachedRingAreas2D = (AttributeStreamOfDbl) m_cachedRingAreas2D;</span><br>        1907:  <span style="background-color: white">      		} else</span><br>        1908:  <span style="background-color: white">      			dstPoly.m_cachedRingAreas2D = null;</span><br>        1909:  <span style="background-color: white">      </span><br>        1910:  <span style="background-color: white">      	}</span><br>        1911:  <span style="background-color: white">      </span><br>        1912:  <span style="background-color: white">      	@Override</span><br>        1913:  <span style="background-color: white">      	public double calculateLength2D() {</span><br>        1914:  <span style="background-color: white">      		if (!_hasDirtyFlag(DirtyFlags.DirtyLength2D)) {</span><br>        1915:  <span style="background-color: white">      			return m_cachedLength2D;</span><br>        1916:  <span style="background-color: white">      		}</span><br>        1917:  <span style="background-color: white">      </span><br>        1918:  <span style="background-color: white">      		SegmentIteratorImpl segIter = querySegmentIterator();</span><br>        1919:  <span style="background-color: white">      		MathUtils.KahanSummator len = new MathUtils.KahanSummator(0);</span><br>        1920:  <span style="background-color: white">      		while (segIter.nextPath()) {</span><br>        1921:  <span style="background-color: white">      			while (segIter.hasNextSegment()) {</span><br>        1922:  <span style="background-color: white">      				len.add(segIter.nextSegment().calculateLength2D());</span><br>        1923:  <span style="background-color: white">      			}</span><br>        1924:  <span style="background-color: white">      		}</span><br>        1925:  <span style="background-color: white">      </span><br>        1926:  <span style="background-color: white">      		m_cachedLength2D = len.getResult();</span><br>        1927:  <span style="background-color: white">      		_setDirtyFlag(DirtyFlags.DirtyLength2D, false);</span><br>        1928:  <span style="background-color: white">      </span><br>        1929:  <span style="background-color: white">      		return len.getResult();</span><br>        1930:  <span style="background-color: white">      	}</span><br>        1931:  <span style="background-color: white">      </span><br>        1932:  <span style="background-color: red">      	@Override</span><br>        1933:  <span style="background-color: white">      	public boolean equals(Object other) {</span><br>        1934:  <span style="background-color: red">      		if (other == this)</span><br>        1935:  <span style="background-color: white">      			return true;</span><br>        1936:  <span style="background-color: white">      </span><br>        1937:  <span style="background-color: red">      		if (!(other instanceof MultiPathImpl))</span><br>        1938:  <span style="background-color: white">      			return false;</span><br>        1939:  <span style="background-color: white">      </span><br>        1940:  <span style="background-color: red">      		if (!super.equals(other))</span><br>        1941:  <span style="background-color: white">      			return false;</span><br>        1942:  <span style="background-color: white">      </span><br>        1943:  <span style="background-color: red">      		MultiPathImpl otherMultiPath = (MultiPathImpl) other;</span><br>        1944:  <span style="background-color: white">      </span><br>        1945:  <span style="background-color: red">      		int pathCount = getPathCount();</span><br>        1946:  <span style="background-color: red">      		int pathCountOther = otherMultiPath.getPathCount();</span><br>        1947:  <span style="background-color: white">      </span><br>        1948:  <span style="background-color: red">      		if (pathCount != pathCountOther)</span><br>        1949:  <span style="background-color: white">      			return false;</span><br>        1950:  <span style="background-color: white">      </span><br>        1951:  <span style="background-color: red">      		if (pathCount &gt; 0 &amp;&amp; m_paths != null</span><br>        1952:  <span style="background-color: white">      				&amp;&amp; !m_paths.equals(otherMultiPath.m_paths, 0, pathCount + 1))</span><br>        1953:  <span style="background-color: white">      			return false;</span><br>        1954:  <span style="background-color: white">      </span><br>        1955:  <span style="background-color: red">      		if (m_fill_rule != otherMultiPath.m_fill_rule)</span><br>        1956:  <span style="background-color: white">      			return false;</span><br>        1957:  <span style="background-color: white">      </span><br>        1958:  <span style="background-color: white">      		{</span><br>        1959:  <span style="background-color: white">      			// Note: OGC flags do not participate in the equals operation by</span><br>        1960:  <span style="background-color: white">      			// design.</span><br>        1961:  <span style="background-color: white">      			// Because for the polygon pathFlags will have all enum_closed set,</span><br>        1962:  <span style="background-color: white">      			// we do not need to compare this stream. Only for polyline.</span><br>        1963:  <span style="background-color: white">      			// Polyline does not have OGC flags set.</span><br>        1964:  <span style="background-color: white">      			if (!m_bPolygon) {</span><br>        1965:  <span style="background-color: white">      				if (m_pathFlags != null</span><br>        1966:  <span style="background-color: white">      						&amp;&amp; !m_pathFlags.equals(otherMultiPath.m_pathFlags, 0,</span><br>        1967:  <span style="background-color: white">      								pathCount))</span><br>        1968:  <span style="background-color: white">      					return false;</span><br>        1969:  <span style="background-color: white">      			}</span><br>        1970:  <span style="background-color: white">      		}</span><br>        1971:  <span style="background-color: white">      	      </span><br>        1972:  <span style="background-color: red">      		return super.equals(other);</span><br>        1973:  <span style="background-color: white">      	}</span><br>        1974:  <span style="background-color: white">      </span><br>        1975:  <span style="background-color: white">      	/**</span><br>        1976:  <span style="background-color: white">      	 * Returns a SegmentIterator that set to a specific vertex of the</span><br>        1977:  <span style="background-color: white">      	 * MultiPathImpl. The call to NextSegment will return the segment that</span><br>        1978:  <span style="background-color: white">      	 * starts at the vertex. Call to PreviousSegment will return the segment</span><br>        1979:  <span style="background-color: white">      	 * that starts at the previous vertex.</span><br>        1980:  <span style="background-color: white">      	 */</span><br>        1981:  <span style="background-color: white">      	public SegmentIteratorImpl querySegmentIteratorAtVertex(int startVertexIndex) {</span><br>        1982:  <span style="background-color: white">      		if (startVertexIndex &lt; 0 || startVertexIndex &gt;= getPointCount())</span><br>        1983:  <span style="background-color: white">      			throw new IndexOutOfBoundsException();</span><br>        1984:  <span style="background-color: white">      </span><br>        1985:  <span style="background-color: white">      		SegmentIteratorImpl iter = new SegmentIteratorImpl(this,</span><br>        1986:  <span style="background-color: white">      				startVertexIndex);</span><br>        1987:  <span style="background-color: white">      		return iter;</span><br>        1988:  <span style="background-color: white">      	}</span><br>        1989:  <span style="background-color: white">      </span><br>        1990:  <span style="background-color: white">      	// void QuerySegmentIterator(int fromVertex, SegmentIterator iterator);</span><br>        1991:  <span style="background-color: red">      	public SegmentIteratorImpl querySegmentIterator() {</span><br>        1992:  <span style="background-color: white">      		return new SegmentIteratorImpl(this);</span><br>        1993:  <span style="background-color: white">      	}</span><br>        1994:  <span style="background-color: white">      </span><br>        1995:  <span style="background-color: white">      	@Override</span><br>        1996:  <span style="background-color: white">      	public void _updateXYImpl(boolean bExact) {</span><br>        1997:  <span style="background-color: white">      		super._updateXYImpl(bExact);</span><br>        1998:  <span style="background-color: white">      		boolean bHasCurves = hasNonLinearSegments();</span><br>        1999:  <span style="background-color: white">      		if (bHasCurves) {</span><br>        2000:  <span style="background-color: white">      			SegmentIteratorImpl segIter = querySegmentIterator();</span><br>        2001:  <span style="background-color: white">      			while (segIter.nextPath()) {</span><br>        2002:  <span style="background-color: white">      				while (segIter.hasNextSegment()) {</span><br>        2003:  <span style="background-color: white">      					Segment curve = segIter.nextCurve();</span><br>        2004:  <span style="background-color: white">      					if (curve != null) {</span><br>        2005:  <span style="background-color: white">      						Envelope2D env2D = new Envelope2D();</span><br>        2006:  <span style="background-color: white">      						curve.queryEnvelope2D(env2D);</span><br>        2007:  <span style="background-color: white">      						m_envelope.merge(env2D);</span><br>        2008:  <span style="background-color: white">      					} else</span><br>        2009:  <span style="background-color: white">      						break;</span><br>        2010:  <span style="background-color: white">      				}</span><br>        2011:  <span style="background-color: white">      			}</span><br>        2012:  <span style="background-color: white">      		}</span><br>        2013:  <span style="background-color: white">      	}</span><br>        2014:  <span style="background-color: white">      </span><br>        2015:  <span style="background-color: white">      	@Override</span><br>        2016:  <span style="background-color: white">      	void calculateEnvelope2D(Envelope2D env, boolean bExact) {</span><br>        2017:  <span style="background-color: white">      		super.calculateEnvelope2D(env, bExact);</span><br>        2018:  <span style="background-color: white">      		boolean bHasCurves = hasNonLinearSegments();</span><br>        2019:  <span style="background-color: white">      		if (bHasCurves) {</span><br>        2020:  <span style="background-color: white">      			SegmentIteratorImpl segIter = querySegmentIterator();</span><br>        2021:  <span style="background-color: white">      			while (segIter.nextPath()) {</span><br>        2022:  <span style="background-color: white">      				while (segIter.hasNextSegment()) {</span><br>        2023:  <span style="background-color: white">      					Segment curve = segIter.nextCurve();</span><br>        2024:  <span style="background-color: white">      					if (curve != null) {</span><br>        2025:  <span style="background-color: white">      						Envelope2D env2D = new Envelope2D();</span><br>        2026:  <span style="background-color: white">      						curve.queryEnvelope2D(env2D);</span><br>        2027:  <span style="background-color: white">      						env.merge(env2D);</span><br>        2028:  <span style="background-color: white">      					} else</span><br>        2029:  <span style="background-color: white">      						break;</span><br>        2030:  <span style="background-color: white">      				}</span><br>        2031:  <span style="background-color: white">      			}</span><br>        2032:  <span style="background-color: white">      		}</span><br>        2033:  <span style="background-color: white">      	}</span><br>        2034:  <span style="background-color: white">      </span><br>        2035:  <span style="background-color: red">      	@Override</span><br>        2036:  <span style="background-color: white">      	public void _notifyModifiedAllImpl() {</span><br>        2037:  <span style="background-color: red">      		if (m_paths == null || m_paths.size() == 0)// if (m_paths == null ||</span><br>        2038:  <span style="background-color: white">      													// !m_paths.size())</span><br>        2039:  <span style="background-color: white">      			m_pointCount = 0;</span><br>        2040:  <span style="background-color: white">      		else</span><br>        2041:  <span style="background-color: red">      			m_pointCount = m_paths.read(m_paths.size() - 1);</span><br>        2042:  <span style="background-color: white">      	}</span><br>        2043:  <span style="background-color: white">      </span><br>        2044:  <span style="background-color: white">      	@Override</span><br>        2045:  <span style="background-color: white">      	public double calculateArea2D() {</span><br>        2046:  <span style="background-color: white">      		if (!m_bPolygon)</span><br>        2047:  <span style="background-color: white">      			return 0.0;</span><br>        2048:  <span style="background-color: white">      </span><br>        2049:  <span style="background-color: white">      		_updateRingAreas2D();</span><br>        2050:  <span style="background-color: white">      </span><br>        2051:  <span style="background-color: white">      		return m_cachedArea2D;</span><br>        2052:  <span style="background-color: white">      	}</span><br>        2053:  <span style="background-color: white">      </span><br>        2054:  <span style="background-color: white">      	/**</span><br>        2055:  <span style="background-color: white">      	 * Returns True if the ring is an exterior ring. Valid only for simple</span><br>        2056:  <span style="background-color: white">      	 * polygons.</span><br>        2057:  <span style="background-color: white">      	 */</span><br>        2058:  <span style="background-color: white">      	public boolean isExteriorRing(int ringIndex) {</span><br>        2059:  <span style="background-color: white">      		if (!m_bPolygon)</span><br>        2060:  <span style="background-color: white">      			return false;</span><br>        2061:  <span style="background-color: white">      </span><br>        2062:  <span style="background-color: white">      		if (!_hasDirtyFlag(DirtyFlags.DirtyOGCFlags))</span><br>        2063:  <span style="background-color: white">      			return (m_pathFlags.read(ringIndex) &amp; (byte) PathFlags.enumOGCStartPolygon) != 0;</span><br>        2064:  <span style="background-color: white">      </span><br>        2065:  <span style="background-color: white">      		_updateRingAreas2D();</span><br>        2066:  <span style="background-color: white">      		return m_cachedRingAreas2D.read(ringIndex) &gt; 0;</span><br>        2067:  <span style="background-color: white">      		// Should we make a function called _UpdateHasNonLinearSegmentsFlags and</span><br>        2068:  <span style="background-color: white">      		// call it here?</span><br>        2069:  <span style="background-color: white">      	}</span><br>        2070:  <span style="background-color: white">      </span><br>        2071:  <span style="background-color: red">      	public double calculateRingArea2D(int pathIndex) {</span><br>        2072:  <span style="background-color: white">      		if (!m_bPolygon)</span><br>        2073:  <span style="background-color: white">      			return 0.0;</span><br>        2074:  <span style="background-color: white">      </span><br>        2075:  <span style="background-color: white">      		_updateRingAreas2D();</span><br>        2076:  <span style="background-color: white">      </span><br>        2077:  <span style="background-color: red">      		return m_cachedRingAreas2D.read(pathIndex);</span><br>        2078:  <span style="background-color: white">      	}</span><br>        2079:  <span style="background-color: white">      </span><br>        2080:  <span style="background-color: red">      	public void _updateRingAreas2D() {</span><br>        2081:  <span style="background-color: red">      		if (_hasDirtyFlag(DirtyFlags.DirtyRingAreas2D)) {</span><br>        2082:  <span style="background-color: red">      			int pathCount = getPathCount();</span><br>        2083:  <span style="background-color: white">      </span><br>        2084:  <span style="background-color: red">      			if (m_cachedRingAreas2D == null)</span><br>        2085:  <span style="background-color: red">      				m_cachedRingAreas2D = new AttributeStreamOfDbl(pathCount);</span><br>        2086:  <span style="background-color: white">      			else if (m_cachedRingAreas2D.size() != pathCount)</span><br>        2087:  <span style="background-color: white">      				m_cachedRingAreas2D.resize(pathCount);</span><br>        2088:  <span style="background-color: white">      </span><br>        2089:  <span style="background-color: red">      			MathUtils.KahanSummator totalArea = new MathUtils.KahanSummator(0);</span><br>        2090:  <span style="background-color: red">      			MathUtils.KahanSummator pathArea = new MathUtils.KahanSummator(0);</span><br>        2091:  <span style="background-color: red">      			Point2D pt = new Point2D();</span><br>        2092:  <span style="background-color: red">      			int ipath = 0;</span><br>        2093:  <span style="background-color: red">      			SegmentIteratorImpl segIter = querySegmentIterator();</span><br>        2094:  <span style="background-color: red">      			while (segIter.nextPath()) {</span><br>        2095:  <span style="background-color: red">      				pathArea.reset();</span><br>        2096:  <span style="background-color: red">      				getXY(getPathStart(segIter.getPathIndex()), pt);// get the area</span><br>        2097:  <span style="background-color: white">      																// calculation</span><br>        2098:  <span style="background-color: white">      																// origin to be</span><br>        2099:  <span style="background-color: white">      																// the origin of</span><br>        2100:  <span style="background-color: white">      																// the ring.</span><br>        2101:  <span style="background-color: red">      				while (segIter.hasNextSegment()) {</span><br>        2102:  <span style="background-color: red">      					pathArea.add(segIter.nextSegment()._calculateArea2DHelper(</span><br>        2103:  <span style="background-color: white">      							pt.x, pt.y));</span><br>        2104:  <span style="background-color: white">      				}</span><br>        2105:  <span style="background-color: white">      </span><br>        2106:  <span style="background-color: red">      				totalArea.add(pathArea.getResult());</span><br>        2107:  <span style="background-color: white">      </span><br>        2108:  <span style="background-color: red">      				int i = ipath++;</span><br>        2109:  <span style="background-color: red">      				m_cachedRingAreas2D.write(i, pathArea.getResult());</span><br>        2110:  <span style="background-color: white">      			}</span><br>        2111:  <span style="background-color: white">      </span><br>        2112:  <span style="background-color: red">      			m_cachedArea2D = totalArea.getResult();</span><br>        2113:  <span style="background-color: red">      			_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, false);</span><br>        2114:  <span style="background-color: white">      		}</span><br>        2115:  <span style="background-color: white">      	}</span><br>        2116:  <span style="background-color: white">      </span><br>        2117:  <span style="background-color: red">      	int getOGCPolygonCount() {</span><br>        2118:  <span style="background-color: white">      		if (!m_bPolygon)</span><br>        2119:  <span style="background-color: white">      			return 0;</span><br>        2120:  <span style="background-color: white">      </span><br>        2121:  <span style="background-color: white">      		_updateOGCFlags();</span><br>        2122:  <span style="background-color: white">      </span><br>        2123:  <span style="background-color: red">      		int polygonCount = 0;</span><br>        2124:  <span style="background-color: red">      		int partCount = getPathCount();</span><br>        2125:  <span style="background-color: red">      		for (int ipart = 0; ipart &lt; partCount; ipart++) {</span><br>        2126:  <span style="background-color: red">      			if (((int) m_pathFlags.read(ipart) &amp; (int) PathFlags.enumOGCStartPolygon) != 0)</span><br>        2127:  <span style="background-color: red">      				polygonCount++;</span><br>        2128:  <span style="background-color: white">      		}</span><br>        2129:  <span style="background-color: white">      </span><br>        2130:  <span style="background-color: red">      		return polygonCount;</span><br>        2131:  <span style="background-color: white">      	}</span><br>        2132:  <span style="background-color: white">      </span><br>        2133:  <span style="background-color: yellow">      	protected void _updateOGCFlags() {</span><br>        2134:  <span style="background-color: yellow">      		if (_hasDirtyFlag(DirtyFlags.DirtyOGCFlags)) {</span><br>        2135:  <span style="background-color: yellow">      			_updateRingAreas2D();</span><br>        2136:  <span style="background-color: yellow">      </span><br>        2137:  <span style="background-color: yellow">      			int pathCount = getPathCount();</span><br>        2138:  <span style="background-color: yellow">      			if (pathCount &gt; 0 &amp;&amp; (m_pathFlags == null || m_pathFlags.size() &lt; pathCount))</span><br>        2139:  <span style="background-color: yellow">      				m_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase</span><br>        2140:  <span style="background-color: yellow">      						.createByteStream(pathCount + 1);</span><br>        2141:  <span style="background-color: yellow">      </span><br>        2142:  <span style="background-color: yellow">      			int firstSign = 1;</span><br>        2143:  <span style="background-color: yellow">      			for (int ipath = 0; ipath &lt; pathCount; ipath++) {</span><br>        2144:  <span style="background-color: yellow">      				double area = m_cachedRingAreas2D.read(ipath);</span><br>        2145:  <span style="background-color: yellow">      				if (ipath == 0)</span><br>        2146:  <span style="background-color: yellow">      					firstSign = area &gt; 0 ? 1 : -1;</span><br>        2147:  <span style="background-color: yellow">      				if (area * firstSign &gt; 0.0)</span><br>        2148:  <span style="background-color: yellow">      					m_pathFlags.setBits(ipath,</span><br>        2149:  <span style="background-color: yellow">      							(byte) PathFlags.enumOGCStartPolygon);</span><br>        2150:  <span style="background-color: yellow">      				else</span><br>        2151:  <span style="background-color: yellow">      					m_pathFlags.clearBits(ipath,</span><br>        2152:  <span style="background-color: yellow">      							(byte) PathFlags.enumOGCStartPolygon);</span><br>        2153:  <span style="background-color: yellow">      			}</span><br>        2154:  <span style="background-color: yellow">      			_setDirtyFlag(DirtyFlags.DirtyOGCFlags, false);</span><br>        2155:  <span style="background-color: yellow">      		}</span><br>        2156:  <span style="background-color: yellow">      	}</span><br>        2157:  <span style="background-color: white">      </span><br>        2158:  <span style="background-color: white">      	public int getPathIndexFromPointIndex(int pointIndex) {</span><br>        2159:  <span style="background-color: white">      		int positionHint = m_currentPathIndex;// in case of multithreading</span><br>        2160:  <span style="background-color: white">      												// thiswould simply produce an</span><br>        2161:  <span style="background-color: white">      												// invalid value</span><br>        2162:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>        2163:  <span style="background-color: white">      </span><br>        2164:  <span style="background-color: white">      		// Try using the hint position first to get the path index.</span><br>        2165:  <span style="background-color: white">      		if (positionHint &gt;= 0 &amp;&amp; positionHint &lt; pathCount) {</span><br>        2166:  <span style="background-color: white">      			if (pointIndex &lt; getPathEnd(positionHint)) {</span><br>        2167:  <span style="background-color: white">      				if (pointIndex &gt;= getPathStart(positionHint))</span><br>        2168:  <span style="background-color: white">      					return positionHint;</span><br>        2169:  <span style="background-color: white">      				positionHint--;</span><br>        2170:  <span style="background-color: white">      			} else {</span><br>        2171:  <span style="background-color: white">      				positionHint++;</span><br>        2172:  <span style="background-color: white">      			}</span><br>        2173:  <span style="background-color: white">      </span><br>        2174:  <span style="background-color: white">      			if (positionHint &gt;= 0 &amp;&amp; positionHint &lt; pathCount) {</span><br>        2175:  <span style="background-color: white">      				if (pointIndex &gt;= getPathStart(positionHint)</span><br>        2176:  <span style="background-color: white">      						&amp;&amp; pointIndex &lt; getPathEnd(positionHint)) {</span><br>        2177:  <span style="background-color: white">      					m_currentPathIndex = positionHint;</span><br>        2178:  <span style="background-color: white">      					return positionHint;</span><br>        2179:  <span style="background-color: white">      				}</span><br>        2180:  <span style="background-color: white">      			}</span><br>        2181:  <span style="background-color: white">      		}</span><br>        2182:  <span style="background-color: white">      </span><br>        2183:  <span style="background-color: white">      		if (pathCount &lt; 5) {// TODO: time the performance to choose when to use</span><br>        2184:  <span style="background-color: white">      							// linear search.</span><br>        2185:  <span style="background-color: white">      			for (int i = 0; i &lt; pathCount; i++) {</span><br>        2186:  <span style="background-color: white">      				if (pointIndex &lt; getPathEnd(i)) {</span><br>        2187:  <span style="background-color: white">      					m_currentPathIndex = i;</span><br>        2188:  <span style="background-color: white">      					return i;</span><br>        2189:  <span style="background-color: white">      				}</span><br>        2190:  <span style="background-color: white">      			}</span><br>        2191:  <span style="background-color: white">      			throw new GeometryException("corrupted geometry");</span><br>        2192:  <span style="background-color: white">      		}</span><br>        2193:  <span style="background-color: white">      </span><br>        2194:  <span style="background-color: white">      		// Do binary search:</span><br>        2195:  <span style="background-color: white">      		int minPathIndex = 0;</span><br>        2196:  <span style="background-color: white">      		int maxPathIndex = pathCount - 1;</span><br>        2197:  <span style="background-color: white">      		while (maxPathIndex &gt; minPathIndex) {</span><br>        2198:  <span style="background-color: white">      			int mid = minPathIndex + ((maxPathIndex - minPathIndex) &gt;&gt; 1);</span><br>        2199:  <span style="background-color: white">      			int pathStart = getPathStart(mid);</span><br>        2200:  <span style="background-color: white">      			if (pointIndex &lt; pathStart)</span><br>        2201:  <span style="background-color: white">      				maxPathIndex = mid - 1;</span><br>        2202:  <span style="background-color: white">      			else {</span><br>        2203:  <span style="background-color: white">      				int pathEnd = getPathEnd(mid);</span><br>        2204:  <span style="background-color: white">      				if (pointIndex &gt;= pathEnd)</span><br>        2205:  <span style="background-color: white">      					minPathIndex = mid + 1;</span><br>        2206:  <span style="background-color: white">      				else {</span><br>        2207:  <span style="background-color: white">      					m_currentPathIndex = mid;</span><br>        2208:  <span style="background-color: white">      					return mid;</span><br>        2209:  <span style="background-color: white">      				}</span><br>        2210:  <span style="background-color: white">      			}</span><br>        2211:  <span style="background-color: white">      		}</span><br>        2212:  <span style="background-color: white">      </span><br>        2213:  <span style="background-color: white">      		m_currentPathIndex = minPathIndex;</span><br>        2214:  <span style="background-color: white">      		return minPathIndex;</span><br>        2215:  <span style="background-color: white">      	}</span><br>        2216:  <span style="background-color: white">      </span><br>        2217:  <span style="background-color: red">      	int getHighestPointIndex(int path_index) {</span><br>        2218:  <span style="background-color: red">      		assert (path_index &gt;= 0 &amp;&amp; path_index &lt; getPathCount());</span><br>        2219:  <span style="background-color: white">      </span><br>        2220:  <span style="background-color: red">      		AttributeStreamOfDbl position = (AttributeStreamOfDbl) (getAttributeStreamRef(VertexDescription.Semantics.POSITION));</span><br>        2221:  <span style="background-color: red">      		AttributeStreamOfInt32 paths = (AttributeStreamOfInt32) (getPathStreamRef());</span><br>        2222:  <span style="background-color: white">      </span><br>        2223:  <span style="background-color: red">      		int path_end = getPathEnd(path_index);</span><br>        2224:  <span style="background-color: red">      		int path_start = getPathStart(path_index);</span><br>        2225:  <span style="background-color: red">      		int max_index = -1;</span><br>        2226:  <span style="background-color: red">      		Point2D max_point = new Point2D(), pt = new Point2D();</span><br>        2227:  <span style="background-color: red">      		max_point.y = NumberUtils.negativeInf();</span><br>        2228:  <span style="background-color: red">      		max_point.x = NumberUtils.negativeInf();</span><br>        2229:  <span style="background-color: white">      </span><br>        2230:  <span style="background-color: red">      		for (int i = path_start + 0; i &lt; path_end; i++) {</span><br>        2231:  <span style="background-color: red">      			position.read(2 * i, pt);</span><br>        2232:  <span style="background-color: red">      			if (max_point.compare(pt) == -1) {</span><br>        2233:  <span style="background-color: red">      				max_index = i;</span><br>        2234:  <span style="background-color: red">      				max_point.setCoords(pt);</span><br>        2235:  <span style="background-color: white">      			}</span><br>        2236:  <span style="background-color: white">      		}</span><br>        2237:  <span style="background-color: white">      </span><br>        2238:  <span style="background-color: red">      		return max_index;</span><br>        2239:  <span style="background-color: white">      	}</span><br>        2240:  <span style="background-color: white">      </span><br>        2241:  <span style="background-color: white">      	/**</span><br>        2242:  <span style="background-color: white">      	 * Returns total segment count in the MultiPathImpl.</span><br>        2243:  <span style="background-color: white">      	 */</span><br>        2244:  <span style="background-color: white">      	public int getSegmentCount() {</span><br>        2245:  <span style="background-color: white">      		int segCount = getPointCount();</span><br>        2246:  <span style="background-color: white">      		if (!m_bPolygon) {</span><br>        2247:  <span style="background-color: white">      			segCount -= getPathCount();</span><br>        2248:  <span style="background-color: white">      			for (int i = 0, n = getPathCount(); i &lt; n; i++)</span><br>        2249:  <span style="background-color: white">      				if (isClosedPath(i))</span><br>        2250:  <span style="background-color: white">      					segCount++;</span><br>        2251:  <span style="background-color: white">      		}</span><br>        2252:  <span style="background-color: white">      </span><br>        2253:  <span style="background-color: white">      		return segCount;</span><br>        2254:  <span style="background-color: white">      	}</span><br>        2255:  <span style="background-color: white">      </span><br>        2256:  <span style="background-color: white">      	public int getSegmentCount(int path_index) {</span><br>        2257:  <span style="background-color: white">      		int segCount = getPathSize(path_index);</span><br>        2258:  <span style="background-color: white">      		if (!isClosedPath(path_index))</span><br>        2259:  <span style="background-color: white">      			segCount--;</span><br>        2260:  <span style="background-color: white">      		return segCount;</span><br>        2261:  <span style="background-color: white">      	}</span><br>        2262:  <span style="background-color: white">      </span><br>        2263:  <span style="background-color: white">      	// HEADER defintions</span><br>        2264:  <span style="background-color: white">      	@Override</span><br>        2265:  <span style="background-color: white">      	public Geometry createInstance() {</span><br>        2266:  <span style="background-color: white">      		return new MultiPathImpl(m_bPolygon, getDescription());</span><br>        2267:  <span style="background-color: white">      	}</span><br>        2268:  <span style="background-color: white">      </span><br>        2269:  <span style="background-color: white">      	@Override</span><br>        2270:  <span style="background-color: white">      	public int getDimension() {</span><br>        2271:  <span style="background-color: white">      		return m_bPolygon ? 2 : 1;</span><br>        2272:  <span style="background-color: white">      	}</span><br>        2273:  <span style="background-color: white">      </span><br>        2274:  <span style="background-color: white">      	@Override</span><br>        2275:  <span style="background-color: white">      	public Geometry.Type getType() {</span><br>        2276:  <span style="background-color: white">      		return m_bPolygon ? Type.Polygon : Type.Polyline;</span><br>        2277:  <span style="background-color: white">      	}</span><br>        2278:  <span style="background-color: white">      </span><br>        2279:  <span style="background-color: white">      	/**</span><br>        2280:  <span style="background-color: white">      	 * Returns True if the class is envelope. THis is not an exact method. Only</span><br>        2281:  <span style="background-color: white">      	 * addEnvelope makes this true.</span><br>        2282:  <span style="background-color: white">      	 */</span><br>        2283:  <span style="background-color: white">      	public boolean isEnvelope() {</span><br>        2284:  <span style="background-color: white">      		return !_hasDirtyFlag(DirtyFlags.DirtyIsEnvelope);</span><br>        2285:  <span style="background-color: white">      	}</span><br>        2286:  <span style="background-color: white">      </span><br>        2287:  <span style="background-color: white">      	/**</span><br>        2288:  <span style="background-color: white">      	 * Returns a reference to the AttributeStream of MultiPathImpl parts</span><br>        2289:  <span style="background-color: white">      	 * (Paths).</span><br>        2290:  <span style="background-color: white">      	 * </span><br>        2291:  <span style="background-color: white">      	 * For the non empty MultiPathImpl, that stream contains start points of the</span><br>        2292:  <span style="background-color: white">      	 * MultiPathImpl curves. In addition, the last element is the total point</span><br>        2293:  <span style="background-color: white">      	 * count. The number of vertices in a given part is parts[i + 1] - parts[i].</span><br>        2294:  <span style="background-color: white">      	 */</span><br>        2295:  <span style="background-color: red">      	public AttributeStreamOfInt32 getPathStreamRef() {</span><br>        2296:  <span style="background-color: white">      		throwIfEmpty();</span><br>        2297:  <span style="background-color: white">      		return m_paths;</span><br>        2298:  <span style="background-color: white">      	}</span><br>        2299:  <span style="background-color: white">      </span><br>        2300:  <span style="background-color: white">      	/**</span><br>        2301:  <span style="background-color: white">      	 * sets a reference to an AttributeStream of MultiPathImpl paths (Paths).</span><br>        2302:  <span style="background-color: white">      	 */</span><br>        2303:  <span style="background-color: red">      	public void setPathStreamRef(AttributeStreamOfInt32 paths) {</span><br>        2304:  <span style="background-color: red">      		m_paths = paths;</span><br>        2305:  <span style="background-color: red">      		notifyModified(DirtyFlags.DirtyAll);</span><br>        2306:  <span style="background-color: white">      	}</span><br>        2307:  <span style="background-color: white">      </span><br>        2308:  <span style="background-color: white">      	/**</span><br>        2309:  <span style="background-color: white">      	 * Returns a reference to the AttributeStream of Segment flags (SegmentFlags</span><br>        2310:  <span style="background-color: white">      	 * flags). Can be NULL when no non-linear segments are present.</span><br>        2311:  <span style="background-color: white">      	 * </span><br>        2312:  <span style="background-color: white">      	 * Segment flags indicate what kind of segment originates (starts) on the</span><br>        2313:  <span style="background-color: white">      	 * given point. The last vertices of open Path parts has enumNone flag.</span><br>        2314:  <span style="background-color: white">      	 */</span><br>        2315:  <span style="background-color: red">      	public AttributeStreamOfInt8 getSegmentFlagsStreamRef() {</span><br>        2316:  <span style="background-color: white">      		throwIfEmpty();</span><br>        2317:  <span style="background-color: white">      		return m_segmentFlags;</span><br>        2318:  <span style="background-color: white">      	}</span><br>        2319:  <span style="background-color: white">      </span><br>        2320:  <span style="background-color: white">      	/**</span><br>        2321:  <span style="background-color: white">      	 * Returns a reference to the AttributeStream of Path flags (PathFlags</span><br>        2322:  <span style="background-color: white">      	 * flags).</span><br>        2323:  <span style="background-color: white">      	 * </span><br>        2324:  <span style="background-color: white">      	 * Each start point of a path has a flag set to indicate if the Path is open</span><br>        2325:  <span style="background-color: white">      	 * or closed.</span><br>        2326:  <span style="background-color: white">      	 */</span><br>        2327:  <span style="background-color: red">      	public AttributeStreamOfInt8 getPathFlagsStreamRef() {</span><br>        2328:  <span style="background-color: white">      		throwIfEmpty();</span><br>        2329:  <span style="background-color: white">      		return m_pathFlags;</span><br>        2330:  <span style="background-color: white">      	}</span><br>        2331:  <span style="background-color: white">      </span><br>        2332:  <span style="background-color: white">      	/**</span><br>        2333:  <span style="background-color: white">      	 * sets a reference to an AttributeStream of Path flags (PathFlags flags).</span><br>        2334:  <span style="background-color: white">      	 */</span><br>        2335:  <span style="background-color: red">      	public void setPathFlagsStreamRef(AttributeStreamOfInt8 pathFlags) {</span><br>        2336:  <span style="background-color: red">      		m_pathFlags = pathFlags;</span><br>        2337:  <span style="background-color: red">      		notifyModified(DirtyFlags.DirtyAll);</span><br>        2338:  <span style="background-color: white">      	}</span><br>        2339:  <span style="background-color: white">      </span><br>        2340:  <span style="background-color: white">      	public AttributeStreamOfInt32 getSegmentIndexStreamRef() {</span><br>        2341:  <span style="background-color: white">      		throwIfEmpty();</span><br>        2342:  <span style="background-color: white">      		return m_segmentParamIndex;</span><br>        2343:  <span style="background-color: white">      	}</span><br>        2344:  <span style="background-color: white">      </span><br>        2345:  <span style="background-color: white">      	public AttributeStreamOfDbl getSegmentDataStreamRef() {</span><br>        2346:  <span style="background-color: white">      		throwIfEmpty();</span><br>        2347:  <span style="background-color: white">      		return m_segmentParams;</span><br>        2348:  <span style="background-color: white">      	}</span><br>        2349:  <span style="background-color: white">      </span><br>        2350:  <span style="background-color: red">      	public int getPathCount() {</span><br>        2351:  <span style="background-color: red">      		return (m_paths != null) ? m_paths.size() - 1 : 0;</span><br>        2352:  <span style="background-color: white">      	}</span><br>        2353:  <span style="background-color: white">      </span><br>        2354:  <span style="background-color: red">      	public int getPathEnd(int partIndex) {</span><br>        2355:  <span style="background-color: red">      		return m_paths.read(partIndex + 1);</span><br>        2356:  <span style="background-color: white">      	}</span><br>        2357:  <span style="background-color: white">      </span><br>        2358:  <span style="background-color: red">      	public int getPathSize(int partIndex) {</span><br>        2359:  <span style="background-color: red">      		return m_paths.read(partIndex + 1) - m_paths.read(partIndex);</span><br>        2360:  <span style="background-color: white">      	}</span><br>        2361:  <span style="background-color: white">      </span><br>        2362:  <span style="background-color: red">      	public int getPathStart(int partIndex) {</span><br>        2363:  <span style="background-color: red">      		return m_paths.read(partIndex);</span><br>        2364:  <span style="background-color: white">      	}</span><br>        2365:  <span style="background-color: white">      </span><br>        2366:  <span style="background-color: white">      	@Override</span><br>        2367:  <span style="background-color: white">      	public Object _getImpl() {</span><br>        2368:  <span style="background-color: white">      		return this;</span><br>        2369:  <span style="background-color: white">      	}</span><br>        2370:  <span style="background-color: white">      </span><br>        2371:  <span style="background-color: red">      	public void setDirtyOGCFlags(boolean bYesNo) {</span><br>        2372:  <span style="background-color: red">      		_setDirtyFlag(DirtyFlags.DirtyOGCFlags, bYesNo);</span><br>        2373:  <span style="background-color: white">      	}</span><br>        2374:  <span style="background-color: white">      </span><br>        2375:  <span style="background-color: white">      	public boolean hasDirtyOGCStartFlags() {</span><br>        2376:  <span style="background-color: white">      		return _hasDirtyFlag(DirtyFlags.DirtyOGCFlags);</span><br>        2377:  <span style="background-color: white">      	}</span><br>        2378:  <span style="background-color: white">      </span><br>        2379:  <span style="background-color: white">      	public void setDirtyRingAreas2D(boolean bYesNo) {</span><br>        2380:  <span style="background-color: white">      		_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, bYesNo);</span><br>        2381:  <span style="background-color: white">      	}</span><br>        2382:  <span style="background-color: white">      </span><br>        2383:  <span style="background-color: white">      	public boolean hasDirtyRingAreas2D() {</span><br>        2384:  <span style="background-color: white">      		return _hasDirtyFlag(DirtyFlags.DirtyRingAreas2D);</span><br>        2385:  <span style="background-color: white">      	}</span><br>        2386:  <span style="background-color: white">      </span><br>        2387:  <span style="background-color: white">      	public void setRingAreasStreamRef(AttributeStreamOfDbl ringAreas) {</span><br>        2388:  <span style="background-color: white">      		m_cachedRingAreas2D = ringAreas;</span><br>        2389:  <span style="background-color: white">      		_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, false);</span><br>        2390:  <span style="background-color: white">      	}</span><br>        2391:  <span style="background-color: white">      </span><br>        2392:  <span style="background-color: white">      	// HEADER defintions</span><br>        2393:  <span style="background-color: white">      </span><br>        2394:  <span style="background-color: white">      	// // TODO check this against current implementation in native</span><br>        2395:  <span style="background-color: white">      	// public void notifyModified(int flags)</span><br>        2396:  <span style="background-color: white">      	// {</span><br>        2397:  <span style="background-color: white">      	// if(flags == DirtyFlags.DirtyAll)</span><br>        2398:  <span style="background-color: white">      	// {</span><br>        2399:  <span style="background-color: white">      	// m_reservedPointCount = -1;</span><br>        2400:  <span style="background-color: white">      	// _notifyModifiedAllImpl();</span><br>        2401:  <span style="background-color: white">      	// }</span><br>        2402:  <span style="background-color: white">      	// m_flagsMask |= flags;</span><br>        2403:  <span style="background-color: white">      	// _clearAccelerators();</span><br>        2404:  <span style="background-color: white">      	//</span><br>        2405:  <span style="background-color: white">      	//</span><br>        2406:  <span style="background-color: white">      	// // ROHIT's implementation</span><br>        2407:  <span style="background-color: white">      	// // if (m_paths == null || 0 == m_paths.size())</span><br>        2408:  <span style="background-color: white">      	// // m_pointCount = 0;</span><br>        2409:  <span style="background-color: white">      	// // else</span><br>        2410:  <span style="background-color: white">      	// // m_pointCount = m_paths.read(m_paths.size() - 1);</span><br>        2411:  <span style="background-color: white">      	// //</span><br>        2412:  <span style="background-color: white">      	// // super.notifyModified(flags);</span><br>        2413:  <span style="background-color: white">      	// }</span><br>        2414:  <span style="background-color: white">      </span><br>        2415:  <span style="background-color: white">      	@Override</span><br>        2416:  <span style="background-color: white">      	public boolean _buildRasterizedGeometryAccelerator(double toleranceXY,</span><br>        2417:  <span style="background-color: white">      			GeometryAccelerationDegree accelDegree) {</span><br>        2418:  <span style="background-color: white">      		if (m_accelerators == null)// (!m_accelerators)</span><br>        2419:  <span style="background-color: white">      		{</span><br>        2420:  <span style="background-color: white">      			m_accelerators = new GeometryAccelerators();</span><br>        2421:  <span style="background-color: white">      		}</span><br>        2422:  <span style="background-color: white">      </span><br>        2423:  <span style="background-color: white">      		int rasterSize = RasterizedGeometry2D</span><br>        2424:  <span style="background-color: white">      				.rasterSizeFromAccelerationDegree(accelDegree);</span><br>        2425:  <span style="background-color: white">      		RasterizedGeometry2D rgeom = m_accelerators.getRasterizedGeometry();</span><br>        2426:  <span style="background-color: white">      		if (rgeom != null) {</span><br>        2427:  <span style="background-color: white">      			if (rgeom.getToleranceXY() &lt; toleranceXY</span><br>        2428:  <span style="background-color: white">      					|| rasterSize &gt; rgeom.getRasterSize()) {</span><br>        2429:  <span style="background-color: white">      				m_accelerators._setRasterizedGeometry(null);</span><br>        2430:  <span style="background-color: white">      			} else</span><br>        2431:  <span style="background-color: white">      				return true;</span><br>        2432:  <span style="background-color: white">      		}</span><br>        2433:  <span style="background-color: white">      </span><br>        2434:  <span style="background-color: white">      		rgeom = RasterizedGeometry2D.create(this, toleranceXY, rasterSize);</span><br>        2435:  <span style="background-color: white">      		m_accelerators._setRasterizedGeometry(rgeom);</span><br>        2436:  <span style="background-color: white">      		//rgeom.dbgSaveToBitmap("c:/temp/ddd.bmp");</span><br>        2437:  <span style="background-color: white">      		return true;</span><br>        2438:  <span style="background-color: white">      	}</span><br>        2439:  <span style="background-color: white">      </span><br>        2440:  <span style="background-color: white">      	@Override</span><br>        2441:  <span style="background-color: white">      	public int hashCode() {</span><br>        2442:  <span style="background-color: white">      		int hashCode = super.hashCode();</span><br>        2443:  <span style="background-color: white">      </span><br>        2444:  <span style="background-color: white">      		if (!isEmptyImpl()) {</span><br>        2445:  <span style="background-color: white">      			int pathCount = getPathCount();</span><br>        2446:  <span style="background-color: white">      </span><br>        2447:  <span style="background-color: white">      			if (m_paths != null)</span><br>        2448:  <span style="background-color: white">      				m_paths.calculateHashImpl(hashCode, 0, pathCount + 1);</span><br>        2449:  <span style="background-color: white">      </span><br>        2450:  <span style="background-color: white">      			if (m_pathFlags != null)</span><br>        2451:  <span style="background-color: white">      				m_pathFlags.calculateHashImpl(hashCode, 0, pathCount);</span><br>        2452:  <span style="background-color: white">      		}</span><br>        2453:  <span style="background-color: white">      </span><br>        2454:  <span style="background-color: white">      		return hashCode;</span><br>        2455:  <span style="background-color: white">      	}</span><br>        2456:  <span style="background-color: white">      </span><br>        2457:  <span style="background-color: white">      	public byte getSegmentFlags(int ivertex) {</span><br>        2458:  <span style="background-color: white">      		if (m_segmentFlags != null)</span><br>        2459:  <span style="background-color: white">      			return m_segmentFlags.read(ivertex);</span><br>        2460:  <span style="background-color: white">      		else</span><br>        2461:  <span style="background-color: white">      			return (byte) SegmentFlags.enumLineSeg;</span><br>        2462:  <span style="background-color: white">      	}</span><br>        2463:  <span style="background-color: white">      </span><br>        2464:  <span style="background-color: white">      	public void getSegment(int startVertexIndex, SegmentBuffer segBuffer,</span><br>        2465:  <span style="background-color: white">      			boolean bStripAttributes) {</span><br>        2466:  <span style="background-color: white">      		int ipath = getPathIndexFromPointIndex(startVertexIndex);</span><br>        2467:  <span style="background-color: white">      		if (startVertexIndex == getPathEnd(ipath) - 1 &amp;&amp; !isClosedPath(ipath))</span><br>        2468:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>        2469:  <span style="background-color: white">      </span><br>        2470:  <span style="background-color: white">      		_verifyAllStreams();</span><br>        2471:  <span style="background-color: white">      		AttributeStreamOfInt8 segFlagStream = getSegmentFlagsStreamRef();</span><br>        2472:  <span style="background-color: white">      		int segFlag = SegmentFlags.enumLineSeg;</span><br>        2473:  <span style="background-color: white">      		if (segFlagStream != null)</span><br>        2474:  <span style="background-color: white">      			segFlag = segFlagStream.read(startVertexIndex)</span><br>        2475:  <span style="background-color: white">      					&amp; SegmentFlags.enumSegmentMask;</span><br>        2476:  <span style="background-color: white">      </span><br>        2477:  <span style="background-color: white">      		switch (segFlag) {</span><br>        2478:  <span style="background-color: white">      		case SegmentFlags.enumLineSeg:</span><br>        2479:  <span style="background-color: white">      			segBuffer.createLine();</span><br>        2480:  <span style="background-color: white">      			break;</span><br>        2481:  <span style="background-color: white">      		case SegmentFlags.enumBezierSeg:</span><br>        2482:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>        2483:  <span style="background-color: white">      		case SegmentFlags.enumArcSeg:</span><br>        2484:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>        2485:  <span style="background-color: white">      		default:</span><br>        2486:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>        2487:  <span style="background-color: white">      		}</span><br>        2488:  <span style="background-color: white">      </span><br>        2489:  <span style="background-color: white">      		Segment currentSegment = segBuffer.get();</span><br>        2490:  <span style="background-color: white">      		if (!bStripAttributes)</span><br>        2491:  <span style="background-color: white">      			currentSegment.assignVertexDescription(m_description);</span><br>        2492:  <span style="background-color: white">      		else</span><br>        2493:  <span style="background-color: white">      			currentSegment</span><br>        2494:  <span style="background-color: white">      					.assignVertexDescription(VertexDescriptionDesignerImpl</span><br>        2495:  <span style="background-color: white">      							.getDefaultDescriptor2D());</span><br>        2496:  <span style="background-color: white">      </span><br>        2497:  <span style="background-color: white">      		int endVertexIndex;</span><br>        2498:  <span style="background-color: white">      		if (startVertexIndex == getPathEnd(ipath) - 1 &amp;&amp; isClosedPath(ipath)) {</span><br>        2499:  <span style="background-color: white">      			endVertexIndex = getPathStart(ipath);</span><br>        2500:  <span style="background-color: white">      		} else</span><br>        2501:  <span style="background-color: white">      			endVertexIndex = startVertexIndex + 1;</span><br>        2502:  <span style="background-color: white">      </span><br>        2503:  <span style="background-color: white">      		Point2D pt = new Point2D();</span><br>        2504:  <span style="background-color: white">      		getXY(startVertexIndex, pt);</span><br>        2505:  <span style="background-color: white">      		currentSegment.setStartXY(pt);</span><br>        2506:  <span style="background-color: white">      		getXY(endVertexIndex, pt);</span><br>        2507:  <span style="background-color: white">      		currentSegment.setEndXY(pt);</span><br>        2508:  <span style="background-color: white">      </span><br>        2509:  <span style="background-color: white">      		if (!bStripAttributes) {</span><br>        2510:  <span style="background-color: white">      			for (int i = 1, nattr = m_description.getAttributeCount(); i &lt; nattr; i++) {</span><br>        2511:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(i);</span><br>        2512:  <span style="background-color: white">      				int ncomp = VertexDescription.getComponentCount(semantics);</span><br>        2513:  <span style="background-color: white">      				for (int ord = 0; ord &lt; ncomp; ord++) {</span><br>        2514:  <span style="background-color: white">      					double vs = getAttributeAsDbl(semantics, startVertexIndex,</span><br>        2515:  <span style="background-color: white">      							ord);</span><br>        2516:  <span style="background-color: white">      					currentSegment.setStartAttribute(semantics, ord, vs);</span><br>        2517:  <span style="background-color: white">      					double ve = getAttributeAsDbl(semantics, endVertexIndex,</span><br>        2518:  <span style="background-color: white">      							ord);</span><br>        2519:  <span style="background-color: white">      					currentSegment.setEndAttribute(semantics, ord, ve);</span><br>        2520:  <span style="background-color: white">      				}</span><br>        2521:  <span style="background-color: white">      			}</span><br>        2522:  <span style="background-color: white">      		}</span><br>        2523:  <span style="background-color: white">      	}</span><br>        2524:  <span style="background-color: white">      </span><br>        2525:  <span style="background-color: white">      	void queryPathEnvelope2D(int path_index, Envelope2D envelope) {</span><br>        2526:  <span style="background-color: white">      		if (path_index &gt;= getPathCount())</span><br>        2527:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>        2528:  <span style="background-color: white">      </span><br>        2529:  <span style="background-color: white">      		if (isEmpty()) {</span><br>        2530:  <span style="background-color: white">      			envelope.setEmpty();</span><br>        2531:  <span style="background-color: white">      			return;</span><br>        2532:  <span style="background-color: white">      		}</span><br>        2533:  <span style="background-color: white">      </span><br>        2534:  <span style="background-color: white">      		if (hasNonLinearSegments(path_index)) {</span><br>        2535:  <span style="background-color: white">      			throw new GeometryException("not implemented");</span><br>        2536:  <span style="background-color: white">      		} else {</span><br>        2537:  <span style="background-color: white">      			AttributeStreamOfDbl stream = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);</span><br>        2538:  <span style="background-color: white">      			Point2D pt = new Point2D();</span><br>        2539:  <span style="background-color: white">      			Envelope2D env = new Envelope2D();</span><br>        2540:  <span style="background-color: white">      			env.setEmpty();</span><br>        2541:  <span style="background-color: white">      			for (int i = getPathStart(path_index), iend = getPathEnd(path_index); i &lt; iend; i++) {</span><br>        2542:  <span style="background-color: white">      				stream.read(2 * i, pt);</span><br>        2543:  <span style="background-color: white">      				env.merge(pt);</span><br>        2544:  <span style="background-color: white">      			}</span><br>        2545:  <span style="background-color: white">      			envelope.setCoords(env);</span><br>        2546:  <span style="background-color: white">      		}</span><br>        2547:  <span style="background-color: white">      	}</span><br>        2548:  <span style="background-color: white">      </span><br>        2549:  <span style="background-color: white">      	public void queryLoosePathEnvelope2D(int path_index, Envelope2D envelope) {</span><br>        2550:  <span style="background-color: white">      		if (path_index &gt;= getPathCount())</span><br>        2551:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>        2552:  <span style="background-color: white">      </span><br>        2553:  <span style="background-color: white">      		if (isEmpty()) {</span><br>        2554:  <span style="background-color: white">      			envelope.setEmpty();</span><br>        2555:  <span style="background-color: white">      			return;</span><br>        2556:  <span style="background-color: white">      		}</span><br>        2557:  <span style="background-color: white">      </span><br>        2558:  <span style="background-color: white">      		if (hasNonLinearSegments(path_index)) {</span><br>        2559:  <span style="background-color: white">      			throw new GeometryException("not implemented");</span><br>        2560:  <span style="background-color: white">      		} else {</span><br>        2561:  <span style="background-color: white">      			AttributeStreamOfDbl stream = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);</span><br>        2562:  <span style="background-color: white">      			Point2D pt = new Point2D();</span><br>        2563:  <span style="background-color: white">      			Envelope2D env = new Envelope2D();</span><br>        2564:  <span style="background-color: white">      			env.setEmpty();</span><br>        2565:  <span style="background-color: white">      			for (int i = getPathStart(path_index), iend = getPathEnd(path_index); i &lt; iend; i++) {</span><br>        2566:  <span style="background-color: white">      				stream.read(2 * i, pt);</span><br>        2567:  <span style="background-color: white">      				env.merge(pt);</span><br>        2568:  <span style="background-color: white">      			}</span><br>        2569:  <span style="background-color: white">      			envelope.setCoords(env);</span><br>        2570:  <span style="background-color: white">      		}</span><br>        2571:  <span style="background-color: white">      	}</span><br>        2572:  <span style="background-color: white">      	</span><br>        2573:  <span style="background-color: white">      	@Override</span><br>        2574:  <span style="background-color: white">      	public boolean _buildQuadTreeAccelerator(GeometryAccelerationDegree d) {</span><br>        2575:  <span style="background-color: white">      		if (m_accelerators == null)// (!m_accelerators)</span><br>        2576:  <span style="background-color: white">      		{</span><br>        2577:  <span style="background-color: white">      			m_accelerators = new GeometryAccelerators();</span><br>        2578:  <span style="background-color: white">      		}</span><br>        2579:  <span style="background-color: white">      </span><br>        2580:  <span style="background-color: white">      		if (d == GeometryAccelerationDegree.enumMild || getPointCount() &lt; 16)</span><br>        2581:  <span style="background-color: white">      			return false;</span><br>        2582:  <span style="background-color: white">      </span><br>        2583:  <span style="background-color: white">      		QuadTreeImpl quad_tree_impl = InternalUtils.buildQuadTree(this);</span><br>        2584:  <span style="background-color: white">      		m_accelerators._setQuadTree(quad_tree_impl);</span><br>        2585:  <span style="background-color: white">      </span><br>        2586:  <span style="background-color: white">      		return true;</span><br>        2587:  <span style="background-color: white">      	}</span><br>        2588:  <span style="background-color: white">      </span><br>        2589:  <span style="background-color: white">      	boolean _buildQuadTreeForPathsAccelerator(GeometryAccelerationDegree degree) {</span><br>        2590:  <span style="background-color: white">      		if (m_accelerators == null) {</span><br>        2591:  <span style="background-color: white">      			m_accelerators = new GeometryAccelerators();</span><br>        2592:  <span style="background-color: white">      		}</span><br>        2593:  <span style="background-color: white">      </span><br>        2594:  <span style="background-color: white">      		// TODO: when less than two envelopes - no need to this.</span><br>        2595:  <span style="background-color: white">      </span><br>        2596:  <span style="background-color: white">      		if (m_accelerators.getQuadTreeForPaths() != null)</span><br>        2597:  <span style="background-color: white">      			return true;</span><br>        2598:  <span style="background-color: white">      </span><br>        2599:  <span style="background-color: white">      		m_accelerators._setQuadTreeForPaths(null);</span><br>        2600:  <span style="background-color: white">      		QuadTreeImpl quad_tree_impl = InternalUtils.buildQuadTreeForPaths(this);</span><br>        2601:  <span style="background-color: white">      		m_accelerators._setQuadTreeForPaths(quad_tree_impl);</span><br>        2602:  <span style="background-color: white">      </span><br>        2603:  <span style="background-color: white">      		return true;</span><br>        2604:  <span style="background-color: white">      	}</span><br>        2605:  <span style="background-color: white">      </span><br>        2606:  <span style="background-color: white">      	void setFillRule(int rule) {</span><br>        2607:  <span style="background-color: white">      		assert (m_bPolygon);</span><br>        2608:  <span style="background-color: white">      		m_fill_rule = rule;</span><br>        2609:  <span style="background-color: white">      	}</span><br>        2610:  <span style="background-color: white">      </span><br>        2611:  <span style="background-color: white">      	int getFillRule() {</span><br>        2612:  <span style="background-color: white">      		return m_fill_rule;</span><br>        2613:  <span style="background-color: white">      	}</span><br>        2614:  <span style="background-color: white">      </span><br>        2615:  <span style="background-color: white">      	void clearDirtyOGCFlags() { </span><br>        2616:  <span style="background-color: white">      		_setDirtyFlag(DirtyFlags.DirtyOGCFlags, false);</span><br>        2617:  <span style="background-color: white">      	}</span><br>        2618:  <span style="background-color: white">      }</span><br>        2619:  <span style="background-color: white">      </span><br></pre> </code> 
   </div> 
   <div class="column"> 
    <h2>Patched Code:</h2> <code> <pre id="patched-trace">        1-&gt;N:  <span style="background-color: white">      /*</span><br>        2-&gt;N:  <span style="background-color: white">       Copyright 1995-2015 Esri</span><br>        3-&gt;N:  <span style="background-color: white">      </span><br>        4-&gt;N:  <span style="background-color: white">         Licensed under the Apache License, Version 2.0 (the "License");</span><br>        5-&gt;N:  <span style="background-color: white">         you may not use this file except in compliance with the License.</span><br>        6-&gt;N:  <span style="background-color: white">         You may obtain a copy of the License at</span><br>        7-&gt;N:  <span style="background-color: white">      </span><br>        8-&gt;N:  <span style="background-color: white">             http://www.apache.org/licenses/LICENSE-2.0</span><br>        9-&gt;N:  <span style="background-color: white">      </span><br>       10-&gt;N:  <span style="background-color: white">         Unless required by applicable law or agreed to in writing, software</span><br>       11-&gt;N:  <span style="background-color: white">         distributed under the License is distributed on an "AS IS" BASIS,</span><br>       12-&gt;N:  <span style="background-color: white">         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br>       13-&gt;N:  <span style="background-color: white">         See the License for the specific language governing permissions and</span><br>       14-&gt;N:  <span style="background-color: white">         limitations under the License.</span><br>       15-&gt;N:  <span style="background-color: white">      </span><br>       16-&gt;N:  <span style="background-color: white">       For additional information, contact:</span><br>       17-&gt;N:  <span style="background-color: white">       Environmental Systems Research Institute, Inc.</span><br>       18-&gt;N:  <span style="background-color: white">       Attn: Contracts Dept</span><br>       19-&gt;N:  <span style="background-color: white">       380 New York Street</span><br>       20-&gt;N:  <span style="background-color: white">       Redlands, California, USA 92373</span><br>       21-&gt;N:  <span style="background-color: white">      </span><br>       22-&gt;N:  <span style="background-color: white">       email: contracts@esri.com</span><br>       23-&gt;N:  <span style="background-color: white">       */</span><br>       24-&gt;N:  <span style="background-color: white">      </span><br>       25-&gt;N:  <span style="background-color: white">      </span><br>       26-&gt;N:  <span style="background-color: white">      package com.esri.core.geometry;</span><br>       27-&gt;N:  <span style="background-color: white">      </span><br>       28-&gt;N:  <span style="background-color: white">      import static com.esri.core.geometry.SizeOf.SIZE_OF_MULTI_PATH_IMPL;</span><br>       29-&gt;N:  <span style="background-color: white">      </span><br>      30-&gt;30:  <span style="background-color: white">      final class MultiPathImpl extends MultiVertexGeometryImpl {</span><br>      31-&gt;31:  <span style="background-color: white">      	protected boolean m_bPolygon;</span><br>      32-&gt;32:  <span style="background-color: white">      	protected Point m_moveToPoint;</span><br>      33-&gt;33:  <span style="background-color: white">      	protected double m_cachedLength2D;</span><br>      34-&gt;34:  <span style="background-color: white">      	protected double m_cachedArea2D;</span><br>       35-&gt;N:  <span style="background-color: white">      </span><br>      36-&gt;36:  <span style="background-color: white">      	protected AttributeStreamOfDbl m_cachedRingAreas2D;</span><br>      37-&gt;37:  <span style="background-color: white">      	protected boolean m_bPathStarted;</span><br>       38-&gt;N:  <span style="background-color: white">      </span><br>       39-&gt;N:  <span style="background-color: white">      	// Contains starting points of the parts. The size is getPartCount() + 1.</span><br>       40-&gt;N:  <span style="background-color: white">      	// First element is 0, last element is equal to the getPointCount().</span><br>      41-&gt;41:  <span style="background-color: white">      	protected AttributeStreamOfInt32 m_paths;</span><br>       42-&gt;N:  <span style="background-color: white">      	// same size as m_parts. Holds flags for each part (whether the part is</span><br>       43-&gt;N:  <span style="background-color: white">      	// closed, etc. See PathFlags)</span><br>      44-&gt;44:  <span style="background-color: white">      	protected AttributeStreamOfInt8 m_pathFlags;</span><br>       45-&gt;N:  <span style="background-color: white">      	// The segment flags. Size is getPointCount(). This is not a vertex</span><br>       46-&gt;N:  <span style="background-color: white">      	// attribute, because we may want to use indexed access later (via an index</span><br>       47-&gt;N:  <span style="background-color: white">      	// buffer).</span><br>       48-&gt;N:  <span style="background-color: white">      	// Can be NULL if the MultiPathImpl contains straight lines only.</span><br>      49-&gt;49:  <span style="background-color: white">      	protected AttributeStreamOfInt8 m_segmentFlags;</span><br>       50-&gt;N:  <span style="background-color: white">      	// An index into the m_segmentParams stream. Size is getPointCount(). Can be</span><br>       51-&gt;N:  <span style="background-color: white">      	// NULL if the MultiPathImpl contains straight lines only.</span><br>      52-&gt;52:  <span style="background-color: white">      	protected AttributeStreamOfInt32 m_segmentParamIndex;</span><br>      53-&gt;53:  <span style="background-color: white">      	protected AttributeStreamOfDbl m_segmentParams;</span><br>      54-&gt;54:  <span style="background-color: white">      	protected int m_curveParamwritePoint;</span><br>      55-&gt;55:  <span style="background-color: white">      	private int m_currentPathIndex;</span><br>      56-&gt;56:  <span style="background-color: white">      	private int m_fill_rule = Polygon.FillRule.enumFillRuleOddEven;</span><br>       57-&gt;N:  <span style="background-color: white">      </span><br>      58-&gt;58:  <span style="background-color: white">      	static int[] _segmentParamSizes = { 0, 0, 6, 0, 8, 0 }; // None, Line,</span><br>       59-&gt;N:  <span style="background-color: white">      															// Bezier, XXX, Arc,</span><br>       60-&gt;N:  <span style="background-color: white">      															// XXX;</span><br>       61-&gt;N:  <span style="background-color: white">      </span><br>      62-&gt;62:  <span style="background-color: white">      	@Override</span><br>      63-&gt;63:  <span style="background-color: white">      	public long estimateMemorySize()</span><br>       64-&gt;N:  <span style="background-color: white">      	{</span><br>      65-&gt;65:  <span style="background-color: white">      		long size = SIZE_OF_MULTI_PATH_IMPL +</span><br>      66-&gt;66:  <span style="background-color: white">      			+ (m_envelope != null ? m_envelope.estimateMemorySize() : 0)</span><br>      67-&gt;67:  <span style="background-color: white">      			+ (m_moveToPoint != null ? m_moveToPoint.estimateMemorySize() : 0)</span><br>      68-&gt;68:  <span style="background-color: white">      			+ (m_cachedRingAreas2D != null ? m_cachedRingAreas2D.estimateMemorySize() : 0)</span><br>      69-&gt;69:  <span style="background-color: white">      			+ (m_paths != null ? m_paths.estimateMemorySize() : 0)</span><br>      70-&gt;70:  <span style="background-color: white">      			+ (m_pathFlags != null ? m_pathFlags.estimateMemorySize() : 0)</span><br>      71-&gt;71:  <span style="background-color: white">      			+ (m_segmentFlags != null ? m_segmentFlags.estimateMemorySize() : 0)</span><br>      72-&gt;72:  <span style="background-color: white">      			+ (m_segmentParamIndex != null ? m_segmentParamIndex.estimateMemorySize() : 0)</span><br>      73-&gt;73:  <span style="background-color: white">      			+ (m_segmentParams != null ? m_segmentParams.estimateMemorySize() : 0);</span><br>       74-&gt;N:  <span style="background-color: white">      </span><br>      75-&gt;75:  <span style="background-color: white">      		if (m_vertexAttributes != null) {</span><br>      76-&gt;76:  <span style="background-color: white">      			for (int i = 0; i &lt; m_vertexAttributes.length; i++) {</span><br>      77-&gt;77:  <span style="background-color: white">      				size += m_vertexAttributes[i].estimateMemorySize();</span><br>       78-&gt;N:  <span style="background-color: white">      			}</span><br>       79-&gt;N:  <span style="background-color: white">      		}</span><br>       80-&gt;N:  <span style="background-color: white">      </span><br>      81-&gt;81:  <span style="background-color: white">      		if (m_accelerators != null) {</span><br>      82-&gt;82:  <span style="background-color: white">      			size += m_accelerators.estimateMemorySize();</span><br>       83-&gt;N:  <span style="background-color: white">      		}</span><br>       84-&gt;N:  <span style="background-color: white">      </span><br>      85-&gt;85:  <span style="background-color: white">      		return size;</span><br>       86-&gt;N:  <span style="background-color: white">      	}</span><br>       87-&gt;N:  <span style="background-color: white">      </span><br>      88-&gt;88:  <span style="background-color: white">      	public boolean hasNonLinearSegments() {</span><br>      89-&gt;89:  <span style="background-color: white">      		return m_curveParamwritePoint &gt; 0;</span><br>       90-&gt;N:  <span style="background-color: white">      	}</span><br>       91-&gt;N:  <span style="background-color: white">      </span><br>       92-&gt;N:  <span style="background-color: white">      	// / Cpp ///</span><br>       93-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      94-&gt;94:  <span style="background-color: cyan">      	public MultiPathImpl(boolean bPolygon) {</span><br>      95-&gt;95:  <span style="background-color: cyan">      		m_bPolygon = bPolygon;</span><br>       96-&gt;N:  <span style="background-color: white">      </span><br>      97-&gt;97:  <span style="background-color: cyan">      		m_bPathStarted = false;</span><br>      98-&gt;98:  <span style="background-color: cyan">      		m_curveParamwritePoint = 0;</span><br>      99-&gt;99:  <span style="background-color: cyan">      		m_cachedLength2D = 0;</span><br>    100-&gt;100:  <span style="background-color: cyan">      		m_cachedArea2D = 0;</span><br>    101-&gt;101:  <span style="background-color: cyan">      		m_pointCount = 0;</span><br>    102-&gt;102:  <span style="background-color: cyan">      		m_description = VertexDescriptionDesignerImpl.getDefaultDescriptor2D();</span><br>    103-&gt;103:  <span style="background-color: cyan">      		m_cachedRingAreas2D = null;</span><br>    104-&gt;104:  <span style="background-color: cyan">      		m_currentPathIndex = 0;</span><br>      105-&gt;N:  <span style="background-color: white">      	}</span><br>      106-&gt;N:  <span style="background-color: white">      </span><br>      107-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    108-&gt;108:  <span style="background-color: white">      	public MultiPathImpl(boolean bPolygon, VertexDescription description) {</span><br>    109-&gt;109:  <span style="background-color: white">      		if (description == null)</span><br>    110-&gt;110:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>      111-&gt;N:  <span style="background-color: white">      </span><br>    112-&gt;112:  <span style="background-color: white">      		m_bPolygon = bPolygon;</span><br>      113-&gt;N:  <span style="background-color: white">      </span><br>    114-&gt;114:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>    115-&gt;115:  <span style="background-color: white">      		m_curveParamwritePoint = 0;</span><br>    116-&gt;116:  <span style="background-color: white">      		m_cachedLength2D = 0;</span><br>    117-&gt;117:  <span style="background-color: white">      		m_cachedArea2D = 0;</span><br>    118-&gt;118:  <span style="background-color: white">      		m_pointCount = 0;</span><br>    119-&gt;119:  <span style="background-color: white">      		m_description = description;</span><br>    120-&gt;120:  <span style="background-color: white">      		m_cachedRingAreas2D = null;</span><br>    121-&gt;121:  <span style="background-color: white">      		m_currentPathIndex = 0;</span><br>      122-&gt;N:  <span style="background-color: white">      	}</span><br>      123-&gt;N:  <span style="background-color: white">      </span><br>      124-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    125-&gt;125:  <span style="background-color: cyan">      	protected void _initPathStartPoint() {</span><br>      126-&gt;N:  <span style="background-color: white">      		_touch();</span><br>    127-&gt;127:  <span style="background-color: cyan">      		if (m_moveToPoint == null)</span><br>    128-&gt;128:  <span style="background-color: cyan">      			m_moveToPoint = new Point(m_description);</span><br>      129-&gt;N:  <span style="background-color: white">      		else</span><br>    130-&gt;130:  <span style="background-color: cyan">      			m_moveToPoint.assignVertexDescription(m_description);</span><br>      131-&gt;N:  <span style="background-color: white">      	}</span><br>      132-&gt;N:  <span style="background-color: white">      </span><br>      133-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      134-&gt;N:  <span style="background-color: white">      	/**</span><br>      135-&gt;N:  <span style="background-color: white">      	 * Starts a new Path at the Point.</span><br>      136-&gt;N:  <span style="background-color: white">      	 */</span><br>    137-&gt;137:  <span style="background-color: cyan">      	public void startPath(double x, double y) {</span><br>    138-&gt;138:  <span style="background-color: cyan">      		Point2D endPoint = new Point2D();</span><br>    139-&gt;139:  <span style="background-color: cyan">      		endPoint.x = x;</span><br>    140-&gt;140:  <span style="background-color: cyan">      		endPoint.y = y;</span><br>    141-&gt;141:  <span style="background-color: cyan">      		startPath(endPoint);</span><br>      142-&gt;N:  <span style="background-color: white">      	}</span><br>      143-&gt;N:  <span style="background-color: white">      </span><br>      144-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    145-&gt;145:  <span style="background-color: cyan">      	public void startPath(Point2D point) {</span><br>      146-&gt;N:  <span style="background-color: white">      		_initPathStartPoint();</span><br>    147-&gt;147:  <span style="background-color: cyan">      		m_moveToPoint.setXY(point);</span><br>    148-&gt;148:  <span style="background-color: cyan">      		m_bPathStarted = true;</span><br>      149-&gt;N:  <span style="background-color: white">      	}</span><br>      150-&gt;N:  <span style="background-color: white">      </span><br>      151-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    152-&gt;152:  <span style="background-color: white">      	public void startPath(Point3D point) {</span><br>      153-&gt;N:  <span style="background-color: white">      		_initPathStartPoint();</span><br>    154-&gt;154:  <span style="background-color: white">      		m_moveToPoint.setXYZ(point);</span><br>      155-&gt;N:  <span style="background-color: white">      		assignVertexDescription(m_moveToPoint.getDescription());</span><br>    156-&gt;156:  <span style="background-color: white">      		m_bPathStarted = true;</span><br>      157-&gt;N:  <span style="background-color: white">      	}</span><br>      158-&gt;N:  <span style="background-color: white">      </span><br>      159-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    160-&gt;160:  <span style="background-color: cyan">      	public void startPath(Point point) {</span><br>    161-&gt;161:  <span style="background-color: cyan">      		if (point.isEmpty())</span><br>    162-&gt;162:  <span style="background-color: white">      			throw new IllegalArgumentException();// throw new</span><br>      163-&gt;N:  <span style="background-color: white">      													// IllegalArgumentException();</span><br>      164-&gt;N:  <span style="background-color: white">      </span><br>    165-&gt;165:  <span style="background-color: cyan">      		mergeVertexDescription(point.getDescription());</span><br>      166-&gt;N:  <span style="background-color: white">      		_initPathStartPoint();</span><br>    167-&gt;167:  <span style="background-color: cyan">      		point.copyTo(m_moveToPoint);</span><br>      168-&gt;N:  <span style="background-color: white">      </span><br>      169-&gt;N:  <span style="background-color: white">      		// TODO check MultiPathImpl.cpp comment</span><br>      170-&gt;N:  <span style="background-color: white">      		// "//the description will be merged later"</span><br>      171-&gt;N:  <span style="background-color: white">      		// assignVertexDescription(m_moveToPoint.getDescription());</span><br>    172-&gt;172:  <span style="background-color: cyan">      		m_bPathStarted = true;</span><br>      173-&gt;N:  <span style="background-color: white">      	}</span><br>      174-&gt;N:  <span style="background-color: white">      </span><br>      175-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    176-&gt;176:  <span style="background-color: cyan">      	protected void _beforeNewSegment(int resizeBy) {</span><br>      177-&gt;N:  <span style="background-color: white">      		// Called for each new segment being added.</span><br>      178-&gt;N:  <span style="background-color: white">      		if (m_bPathStarted) {</span><br>      179-&gt;N:  <span style="background-color: white">      			_initPathStartPoint();// make sure the m_movetoPoint exists and has</span><br>      180-&gt;N:  <span style="background-color: white">      									// right vertex description</span><br>      181-&gt;N:  <span style="background-color: white">      </span><br>      182-&gt;N:  <span style="background-color: white">      			// The new path is started. Need to grow m_parts and m_pathFlags.</span><br>    183-&gt;183:  <span style="background-color: cyan">      			if (m_paths == null) {</span><br>    184-&gt;184:  <span style="background-color: cyan">      				m_paths = (AttributeStreamOfInt32) AttributeStreamBase</span><br>    185-&gt;185:  <span style="background-color: white">      						.createIndexStream(2);</span><br>    186-&gt;186:  <span style="background-color: cyan">      				m_paths.write(0, 0);</span><br>    187-&gt;187:  <span style="background-color: cyan">      				m_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase</span><br>    188-&gt;188:  <span style="background-color: white">      						.createByteStream(2, (byte) 0);</span><br>      189-&gt;N:  <span style="background-color: white">      			} else {</span><br>      190-&gt;N:  <span style="background-color: white">      				// _ASSERT(m_parts.size() &gt;= 2);</span><br>    191-&gt;191:  <span style="background-color: cyan">      				m_paths.resize(m_paths.size() + 1, 0);</span><br>    192-&gt;192:  <span style="background-color: cyan">      				m_pathFlags.resize(m_pathFlags.size() + 1, 0);</span><br>      193-&gt;N:  <span style="background-color: white">      			}</span><br>      194-&gt;N:  <span style="background-color: white">      </span><br>      195-&gt;N:  <span style="background-color: white">      			if (m_bPolygon) {</span><br>      196-&gt;N:  <span style="background-color: white">      				// Mark the path as closed</span><br>    197-&gt;197:  <span style="background-color: cyan">      				m_pathFlags.write(m_pathFlags.size() - 2,</span><br>    198-&gt;198:  <span style="background-color: white">      						(byte) PathFlags.enumClosed);</span><br>      199-&gt;N:  <span style="background-color: white">      			}</span><br>      200-&gt;N:  <span style="background-color: white">      </span><br>    201-&gt;201:  <span style="background-color: cyan">      			resizeBy++; // +1 for the StartPath point.</span><br>      202-&gt;N:  <span style="background-color: white">      		}</span><br>      203-&gt;N:  <span style="background-color: white">      </span><br>    204-&gt;204:  <span style="background-color: cyan">      		int oldcount = m_pointCount;</span><br>    205-&gt;205:  <span style="background-color: cyan">      		m_paths.write(m_paths.size() - 1, m_pointCount + resizeBy); // The</span><br>      206-&gt;N:  <span style="background-color: white">      																	// NotifyModified</span><br>      207-&gt;N:  <span style="background-color: white">      																	// will</span><br>      208-&gt;N:  <span style="background-color: white">      																	// update</span><br>      209-&gt;N:  <span style="background-color: white">      																	// the</span><br>      210-&gt;N:  <span style="background-color: white">      																	// m_pointCount</span><br>      211-&gt;N:  <span style="background-color: white">      																	// with this</span><br>      212-&gt;N:  <span style="background-color: white">      																	// value.</span><br>    213-&gt;213:  <span style="background-color: cyan">      		_resizeImpl(oldcount + resizeBy);</span><br>    214-&gt;214:  <span style="background-color: cyan">      		m_pathFlags.write(m_paths.size() - 1, (byte) 0);</span><br>      215-&gt;N:  <span style="background-color: white">      </span><br>      216-&gt;N:  <span style="background-color: white">      		if (m_bPathStarted) {</span><br>    217-&gt;217:  <span style="background-color: cyan">      			setPointByVal(oldcount, m_moveToPoint);// setPoint(oldcount,</span><br>      218-&gt;N:  <span style="background-color: white">      													// m_moveToPoint); //finally</span><br>      219-&gt;N:  <span style="background-color: white">      													// set the start point to</span><br>      220-&gt;N:  <span style="background-color: white">      													// the geometry</span><br>    221-&gt;221:  <span style="background-color: cyan">      			m_bPathStarted = false;</span><br>      222-&gt;N:  <span style="background-color: white">      		}</span><br>      223-&gt;N:  <span style="background-color: white">      	}</span><br>      224-&gt;N:  <span style="background-color: white">      </span><br>      225-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    226-&gt;226:  <span style="background-color: cyan">      	protected void _finishLineTo() {</span><br>      227-&gt;N:  <span style="background-color: white">      	}</span><br>      228-&gt;N:  <span style="background-color: white">      </span><br>      229-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      230-&gt;N:  <span style="background-color: white">      	/**</span><br>      231-&gt;N:  <span style="background-color: white">      	 * adds a Line Segment from the last Point to the given endPoint.</span><br>      232-&gt;N:  <span style="background-color: white">      	 */</span><br>    233-&gt;233:  <span style="background-color: cyan">      	public void lineTo(double x, double y) {</span><br>    234-&gt;234:  <span style="background-color: cyan">      		_beforeNewSegment(1);</span><br>    235-&gt;235:  <span style="background-color: cyan">      		setXY(m_pointCount - 1, x, y);</span><br>      236-&gt;N:  <span style="background-color: white">      		_finishLineTo();</span><br>      237-&gt;N:  <span style="background-color: white">      		// Point2D endPoint = new Point2D();</span><br>      238-&gt;N:  <span style="background-color: white">      		// endPoint.x = x; endPoint.y = y;</span><br>      239-&gt;N:  <span style="background-color: white">      		// lineTo(endPoint);</span><br>      240-&gt;N:  <span style="background-color: white">      	}</span><br>      241-&gt;N:  <span style="background-color: white">      </span><br>      242-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    243-&gt;243:  <span style="background-color: white">      	public void lineTo(Point2D endPoint) {</span><br>    244-&gt;244:  <span style="background-color: white">      		_beforeNewSegment(1);</span><br>    245-&gt;245:  <span style="background-color: white">      		setXY(m_pointCount - 1, endPoint);</span><br>      246-&gt;N:  <span style="background-color: white">      		_finishLineTo();</span><br>      247-&gt;N:  <span style="background-color: white">      	}</span><br>      248-&gt;N:  <span style="background-color: white">      </span><br>      249-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    250-&gt;250:  <span style="background-color: white">      	public void lineTo(Point3D endPoint) {</span><br>    251-&gt;251:  <span style="background-color: white">      		_beforeNewSegment(1);</span><br>    252-&gt;252:  <span style="background-color: white">      		setXYZ(m_pointCount - 1, endPoint);</span><br>      253-&gt;N:  <span style="background-color: white">      		_finishLineTo();</span><br>      254-&gt;N:  <span style="background-color: white">      	}</span><br>      255-&gt;N:  <span style="background-color: white">      </span><br>      256-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    257-&gt;257:  <span style="background-color: cyan">      	public void lineTo(Point endPoint) {</span><br>    258-&gt;258:  <span style="background-color: cyan">      		_beforeNewSegment(1);</span><br>    259-&gt;259:  <span style="background-color: cyan">      		setPointByVal(m_pointCount - 1, endPoint);</span><br>      260-&gt;N:  <span style="background-color: white">      		_finishLineTo();</span><br>      261-&gt;N:  <span style="background-color: white">      	}</span><br>      262-&gt;N:  <span style="background-color: white">      </span><br>      263-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    264-&gt;264:  <span style="background-color: white">      	protected void _initSegmentData(int sz) {</span><br>    265-&gt;265:  <span style="background-color: white">      		if (m_segmentParamIndex == null) {</span><br>    266-&gt;266:  <span style="background-color: white">      			m_segmentFlags = (AttributeStreamOfInt8) AttributeStreamBase</span><br>    267-&gt;267:  <span style="background-color: white">      					.createByteStream(m_pointCount,</span><br>    268-&gt;268:  <span style="background-color: white">      							(byte) SegmentFlags.enumLineSeg);</span><br>    269-&gt;269:  <span style="background-color: white">      			m_segmentParamIndex = (AttributeStreamOfInt32) AttributeStreamBase</span><br>    270-&gt;270:  <span style="background-color: white">      					.createIndexStream(m_pointCount, -1);</span><br>      271-&gt;N:  <span style="background-color: white">      		}</span><br>      272-&gt;N:  <span style="background-color: white">      </span><br>    273-&gt;273:  <span style="background-color: white">      		int size = m_curveParamwritePoint + sz;</span><br>    274-&gt;274:  <span style="background-color: white">      		if (m_segmentParams == null) {</span><br>    275-&gt;275:  <span style="background-color: white">      			m_segmentParams = (AttributeStreamOfDbl) AttributeStreamBase</span><br>      276-&gt;N:  <span style="background-color: white">      					.createAttributeStreamWithPersistence(</span><br>    277-&gt;277:  <span style="background-color: white">      							VertexDescription.Persistence.enumDouble, size);</span><br>      278-&gt;N:  <span style="background-color: white">      		} else {</span><br>    279-&gt;279:  <span style="background-color: white">      			m_segmentParams.resize(size, 0);</span><br>      280-&gt;N:  <span style="background-color: white">      		}</span><br>      281-&gt;N:  <span style="background-color: white">      	}</span><br>      282-&gt;N:  <span style="background-color: white">      </span><br>      283-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    284-&gt;284:  <span style="background-color: white">      	protected void _finishBezierTo() {</span><br>      285-&gt;N:  <span style="background-color: white">      		// _ASSERT(m_segmentFlags != null);</span><br>      286-&gt;N:  <span style="background-color: white">      		// _ASSERT(m_segmentParamIndex != null);</span><br>      287-&gt;N:  <span style="background-color: white">      </span><br>    288-&gt;288:  <span style="background-color: white">      		m_segmentFlags.write(m_pointCount - 2,</span><br>    289-&gt;289:  <span style="background-color: white">      				(byte) SegmentFlags.enumBezierSeg);</span><br>      290-&gt;N:  <span style="background-color: white">      	}</span><br>      291-&gt;N:  <span style="background-color: white">      </span><br>      292-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      293-&gt;N:  <span style="background-color: white">      	/**</span><br>      294-&gt;N:  <span style="background-color: white">      	 * adds a Cubic Bezier Segment to the current Path. The Bezier Segment</span><br>      295-&gt;N:  <span style="background-color: white">      	 * connects the current last Point and the given endPoint.</span><br>      296-&gt;N:  <span style="background-color: white">      	 */</span><br>    297-&gt;297:  <span style="background-color: white">      	public void bezierTo(Point2D controlPoint1, Point2D controlPoint2,</span><br>    298-&gt;298:  <span style="background-color: white">      			Point2D endPoint) {</span><br>    299-&gt;299:  <span style="background-color: white">      		_beforeNewSegment(1);</span><br>    300-&gt;300:  <span style="background-color: white">      		setXY(m_pointCount - 1, endPoint);</span><br>    301-&gt;301:  <span style="background-color: white">      		double z;</span><br>    302-&gt;302:  <span style="background-color: white">      		_initSegmentData(6);</span><br>    303-&gt;303:  <span style="background-color: white">      		m_pathFlags.setBits(m_pathFlags.size() - 1,</span><br>    304-&gt;304:  <span style="background-color: white">      				(byte) PathFlags.enumHasNonlinearSegments);</span><br>    305-&gt;305:  <span style="background-color: white">      		m_segmentParamIndex.write(m_pointCount - 2, m_curveParamwritePoint);</span><br>    306-&gt;306:  <span style="background-color: white">      		m_curveParamwritePoint += 6;</span><br>    307-&gt;307:  <span style="background-color: white">      		int curveIndex = m_curveParamwritePoint;</span><br>    308-&gt;308:  <span style="background-color: white">      		m_segmentParams.write(curveIndex, controlPoint1.x);</span><br>    309-&gt;309:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 1, controlPoint1.y);</span><br>    310-&gt;310:  <span style="background-color: white">      		z = 0;// TODO: calculate me.</span><br>    311-&gt;311:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 2, z);</span><br>    312-&gt;312:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 3, controlPoint2.x);</span><br>    313-&gt;313:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 4, controlPoint2.y);</span><br>    314-&gt;314:  <span style="background-color: white">      		z = 0;// TODO: calculate me.</span><br>    315-&gt;315:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 5, z);</span><br>      316-&gt;N:  <span style="background-color: white">      		_finishBezierTo();</span><br>      317-&gt;N:  <span style="background-color: white">      	}</span><br>      318-&gt;N:  <span style="background-color: white">      </span><br>      319-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    320-&gt;320:  <span style="background-color: white">      	public void openPath(int pathIndex) {</span><br>      321-&gt;N:  <span style="background-color: white">      		_touch();</span><br>      322-&gt;N:  <span style="background-color: white">      		if (m_bPolygon)</span><br>    323-&gt;323:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();// do not call this</span><br>      324-&gt;N:  <span style="background-color: white">      															// method on a</span><br>      325-&gt;N:  <span style="background-color: white">      															// polygon</span><br>      326-&gt;N:  <span style="background-color: white">      </span><br>    327-&gt;327:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>    328-&gt;328:  <span style="background-color: white">      		if (pathIndex &gt; getPathCount())</span><br>    329-&gt;329:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>      330-&gt;N:  <span style="background-color: white">      </span><br>    331-&gt;331:  <span style="background-color: white">      		if (m_pathFlags == null)</span><br>    332-&gt;332:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>      333-&gt;N:  <span style="background-color: white">      </span><br>    334-&gt;334:  <span style="background-color: white">      		m_pathFlags.clearBits(pathIndex, (byte) PathFlags.enumClosed);</span><br>      335-&gt;N:  <span style="background-color: white">      	}</span><br>      336-&gt;N:  <span style="background-color: white">      </span><br>    337-&gt;337:  <span style="background-color: white">      	public void openPathAndDuplicateStartVertex(int pathIndex) {</span><br>      338-&gt;N:  <span style="background-color: white">      		_touch();</span><br>      339-&gt;N:  <span style="background-color: white">      		if (m_bPolygon)</span><br>    340-&gt;340:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();// do not call this</span><br>      341-&gt;N:  <span style="background-color: white">      															// method on a</span><br>      342-&gt;N:  <span style="background-color: white">      															// polygon</span><br>      343-&gt;N:  <span style="background-color: white">      </span><br>    344-&gt;344:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>    345-&gt;345:  <span style="background-color: white">      		if (pathIndex &gt; pathCount)</span><br>    346-&gt;346:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>      347-&gt;N:  <span style="background-color: white">      </span><br>    348-&gt;348:  <span style="background-color: white">      		if (!isClosedPath(pathIndex))</span><br>    349-&gt;349:  <span style="background-color: white">      			return;// do not open if open</span><br>      350-&gt;N:  <span style="background-color: white">      </span><br>    351-&gt;351:  <span style="background-color: white">      		if (m_pathFlags == null)// if (!m_pathFlags)</span><br>    352-&gt;352:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>      353-&gt;N:  <span style="background-color: white">      </span><br>    354-&gt;354:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>    355-&gt;355:  <span style="background-color: white">      		int pathIndexStart = getPathStart(pathIndex);</span><br>    356-&gt;356:  <span style="background-color: white">      		int pathIndexEnd = getPathEnd(pathIndex);</span><br>    357-&gt;357:  <span style="background-color: white">      		_resizeImpl(m_pointCount + 1); // resize does not write into m_paths</span><br>      358-&gt;N:  <span style="background-color: white">      										// anymore!</span><br>      359-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>    360-&gt;360:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>    361-&gt;361:  <span style="background-color: white">      			if (m_vertexAttributes[iattr] != null)// if</span><br>      362-&gt;N:  <span style="background-color: white">      													// (m_vertexAttributes[iattr])</span><br>      363-&gt;N:  <span style="background-color: white">      			{</span><br>    364-&gt;364:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>    365-&gt;365:  <span style="background-color: white">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>    366-&gt;366:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(comp * pathIndexEnd,</span><br>    367-&gt;367:  <span style="background-color: white">      						m_vertexAttributes[iattr], comp * pathIndexStart, comp,</span><br>    368-&gt;368:  <span style="background-color: white">      						true, 1, comp * oldPointCount);</span><br>      369-&gt;N:  <span style="background-color: white">      			}</span><br>      370-&gt;N:  <span style="background-color: white">      		}</span><br>      371-&gt;N:  <span style="background-color: white">      </span><br>    372-&gt;372:  <span style="background-color: white">      		for (int ipath = pathCount; ipath &gt; pathIndex; ipath--) {</span><br>    373-&gt;373:  <span style="background-color: white">      			int iend = m_paths.read(ipath);</span><br>    374-&gt;374:  <span style="background-color: white">      			m_paths.write(ipath, iend + 1);</span><br>      375-&gt;N:  <span style="background-color: white">      		}</span><br>      376-&gt;N:  <span style="background-color: white">      </span><br>    377-&gt;377:  <span style="background-color: white">      		m_pathFlags.clearBits(pathIndex, (byte) PathFlags.enumClosed);</span><br>      378-&gt;N:  <span style="background-color: white">      	}</span><br>      379-&gt;N:  <span style="background-color: white">      </span><br>      380-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      381-&gt;N:  <span style="background-color: white">      	// Major Changes on 16th of January</span><br>    382-&gt;382:  <span style="background-color: white">      	public void openAllPathsAndDuplicateStartVertex() {</span><br>      383-&gt;N:  <span style="background-color: white">      		_touch();</span><br>      384-&gt;N:  <span style="background-color: white">      		if (m_bPolygon)</span><br>    385-&gt;385:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();// do not call this</span><br>      386-&gt;N:  <span style="background-color: white">      															// method on a</span><br>      387-&gt;N:  <span style="background-color: white">      															// polygon</span><br>      388-&gt;N:  <span style="background-color: white">      </span><br>    389-&gt;389:  <span style="background-color: white">      		if (m_pathFlags == null)// if (!m_pathFlags)</span><br>    390-&gt;390:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>      391-&gt;N:  <span style="background-color: white">      </span><br>      392-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>      393-&gt;N:  <span style="background-color: white">      </span><br>    394-&gt;394:  <span style="background-color: white">      		int closedPathCount = 0;</span><br>    395-&gt;395:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>    396-&gt;396:  <span style="background-color: white">      		for (int i = 0; i &lt; pathCount; i++) {</span><br>    397-&gt;397:  <span style="background-color: white">      			if (m_pathFlags.read(i) == (byte) PathFlags.enumClosed) {</span><br>    398-&gt;398:  <span style="background-color: white">      				closedPathCount++;</span><br>      399-&gt;N:  <span style="background-color: white">      			}</span><br>      400-&gt;N:  <span style="background-color: white">      		}</span><br>      401-&gt;N:  <span style="background-color: white">      </span><br>    402-&gt;402:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>    403-&gt;403:  <span style="background-color: white">      			if (m_vertexAttributes[iattr] != null) {</span><br>    404-&gt;404:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);// int</span><br>      405-&gt;N:  <span style="background-color: white">      																		// semantics</span><br>      406-&gt;N:  <span style="background-color: white">      																		// =</span><br>      407-&gt;N:  <span style="background-color: white">      																		// m_description._getSemanticsImpl(iattr);</span><br>    408-&gt;408:  <span style="background-color: white">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>    409-&gt;409:  <span style="background-color: white">      				int newSize = comp * (m_pointCount + closedPathCount);</span><br>    410-&gt;410:  <span style="background-color: white">      				m_vertexAttributes[iattr].resize(newSize);</span><br>      411-&gt;N:  <span style="background-color: white">      </span><br>    412-&gt;412:  <span style="background-color: white">      				int offset = closedPathCount;</span><br>    413-&gt;413:  <span style="background-color: white">      				int ipath = pathCount;</span><br>    414-&gt;414:  <span style="background-color: white">      				for (int i = m_pointCount - 1; i &gt;= 0; i--) {</span><br>    415-&gt;415:  <span style="background-color: white">      					if (i + 1 == m_paths.read(ipath)) {</span><br>    416-&gt;416:  <span style="background-color: white">      						ipath--;</span><br>    417-&gt;417:  <span style="background-color: white">      						if (m_pathFlags.read(ipath) == (byte) PathFlags.enumClosed) {</span><br>    418-&gt;418:  <span style="background-color: white">      							int istart = m_paths.read(ipath);</span><br>      419-&gt;N:  <span style="background-color: white">      </span><br>    420-&gt;420:  <span style="background-color: white">      							for (int c = 0; c &lt; comp; c++) {</span><br>    421-&gt;421:  <span style="background-color: white">      								double v = m_vertexAttributes[iattr]</span><br>    422-&gt;422:  <span style="background-color: white">      										.readAsDbl(comp * istart + c);</span><br>    423-&gt;423:  <span style="background-color: white">      								m_vertexAttributes[iattr].writeAsDbl(comp</span><br>    424-&gt;424:  <span style="background-color: white">      										* (offset + i) + c, v);</span><br>      425-&gt;N:  <span style="background-color: white">      							}</span><br>      426-&gt;N:  <span style="background-color: white">      </span><br>    427-&gt;427:  <span style="background-color: white">      							if (--offset == 0)</span><br>    428-&gt;428:  <span style="background-color: white">      								break;</span><br>      429-&gt;N:  <span style="background-color: white">      						}</span><br>      430-&gt;N:  <span style="background-color: white">      					}</span><br>      431-&gt;N:  <span style="background-color: white">      </span><br>    432-&gt;432:  <span style="background-color: white">      					for (int c = 0; c &lt; comp; c++) {</span><br>    433-&gt;433:  <span style="background-color: white">      						double v = m_vertexAttributes[iattr].readAsDbl(comp * i</span><br>    434-&gt;434:  <span style="background-color: white">      								+ c);</span><br>    435-&gt;435:  <span style="background-color: white">      						m_vertexAttributes[iattr].writeAsDbl(comp</span><br>    436-&gt;436:  <span style="background-color: white">      								* (offset + i) + c, v);</span><br>      437-&gt;N:  <span style="background-color: white">      					}</span><br>      438-&gt;N:  <span style="background-color: white">      				}</span><br>      439-&gt;N:  <span style="background-color: white">      			}</span><br>      440-&gt;N:  <span style="background-color: white">      		}</span><br>      441-&gt;N:  <span style="background-color: white">      </span><br>    442-&gt;442:  <span style="background-color: white">      		int offset = closedPathCount;</span><br>    443-&gt;443:  <span style="background-color: white">      		for (int ipath = pathCount; ipath &gt; 0; ipath--) {</span><br>    444-&gt;444:  <span style="background-color: white">      			int iend = m_paths.read(ipath);</span><br>    445-&gt;445:  <span style="background-color: white">      			m_paths.write(ipath, iend + offset);</span><br>      446-&gt;N:  <span style="background-color: white">      </span><br>    447-&gt;447:  <span style="background-color: white">      			if (m_pathFlags.read(ipath - 1) == (byte) PathFlags.enumClosed) {</span><br>    448-&gt;448:  <span style="background-color: white">      				m_pathFlags.clearBits(ipath - 1, (byte) PathFlags.enumClosed);</span><br>      449-&gt;N:  <span style="background-color: white">      </span><br>    450-&gt;450:  <span style="background-color: white">      				if (--offset == 0) {</span><br>    451-&gt;451:  <span style="background-color: white">      					break;</span><br>      452-&gt;N:  <span style="background-color: white">      				}</span><br>      453-&gt;N:  <span style="background-color: white">      			}</span><br>      454-&gt;N:  <span style="background-color: white">      		}</span><br>      455-&gt;N:  <span style="background-color: white">      </span><br>    456-&gt;456:  <span style="background-color: white">      		m_pointCount += closedPathCount;</span><br>      457-&gt;N:  <span style="background-color: white">      	}</span><br>      458-&gt;N:  <span style="background-color: white">      </span><br>    459-&gt;459:  <span style="background-color: cyan">      	void closePathWithLine(int path_index) {</span><br>      460-&gt;N:  <span style="background-color: white">      		// touch_();</span><br>      461-&gt;N:  <span style="background-color: white">      		throwIfEmpty();</span><br>      462-&gt;N:  <span style="background-color: white">      </span><br>    463-&gt;463:  <span style="background-color: cyan">      		byte pf = m_pathFlags.read(path_index);</span><br>    464-&gt;464:  <span style="background-color: cyan">      		m_pathFlags.write(path_index, (byte) (pf | PathFlags.enumClosed));</span><br>    465-&gt;465:  <span style="background-color: cyan">      		if (m_segmentFlags != null) {</span><br>    466-&gt;466:  <span style="background-color: white">      			int vindex = getPathEnd(path_index) - 1;</span><br>    467-&gt;467:  <span style="background-color: white">      			m_segmentFlags.write(vindex, (byte) SegmentFlags.enumLineSeg);</span><br>    468-&gt;468:  <span style="background-color: white">      			m_segmentParamIndex.write(vindex, -1);</span><br>      469-&gt;N:  <span style="background-color: white">      		}</span><br>      470-&gt;N:  <span style="background-color: white">      	}</span><br>      471-&gt;N:  <span style="background-color: white">      </span><br>    472-&gt;472:  <span style="background-color: cyan">      	void closePathWithLine() {</span><br>      473-&gt;N:  <span style="background-color: white">      		throwIfEmpty();</span><br>    474-&gt;474:  <span style="background-color: cyan">      		m_bPathStarted = false;</span><br>    475-&gt;475:  <span style="background-color: cyan">      		closePathWithLine(getPathCount() - 1);</span><br>      476-&gt;N:  <span style="background-color: white">      	}</span><br>      477-&gt;N:  <span style="background-color: white">      </span><br>      478-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      479-&gt;N:  <span style="background-color: white">      	/**</span><br>      480-&gt;N:  <span style="background-color: white">      	 * Closes all open curves by adding an implicit line segment from the end</span><br>      481-&gt;N:  <span style="background-color: white">      	 * point to the start point.</span><br>      482-&gt;N:  <span style="background-color: white">      	 */</span><br>    483-&gt;483:  <span style="background-color: white">      	public void closeAllPaths() {</span><br>      484-&gt;N:  <span style="background-color: white">      		_touch();</span><br>      485-&gt;N:  <span style="background-color: white">      		if (m_bPolygon || isEmptyImpl())</span><br>    486-&gt;486:  <span style="background-color: white">      			return;</span><br>      487-&gt;N:  <span style="background-color: white">      </span><br>    488-&gt;488:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>      489-&gt;N:  <span style="background-color: white">      </span><br>    490-&gt;490:  <span style="background-color: white">      		for (int ipath = 0, npart = m_paths.size() - 1; ipath &lt; npart; ipath++) {</span><br>    491-&gt;491:  <span style="background-color: white">      			if (isClosedPath(ipath))</span><br>    492-&gt;492:  <span style="background-color: white">      				continue;</span><br>      493-&gt;N:  <span style="background-color: white">      </span><br>    494-&gt;494:  <span style="background-color: white">      			byte pf = m_pathFlags.read(ipath);</span><br>    495-&gt;495:  <span style="background-color: white">      			m_pathFlags.write(ipath, (byte) (pf | PathFlags.enumClosed));</span><br>      496-&gt;N:  <span style="background-color: white">      			// if (m_segmentFlags)</span><br>      497-&gt;N:  <span style="background-color: white">      			// {</span><br>      498-&gt;N:  <span style="background-color: white">      			// m_segmentFlags.write(m_pointCount - 1,</span><br>      499-&gt;N:  <span style="background-color: white">      			// (byte)SegmentFlags.LineSeg));</span><br>      500-&gt;N:  <span style="background-color: white">      			// m_segmentParamIndex.write(m_pointCount - 1, -1);</span><br>      501-&gt;N:  <span style="background-color: white">      			// }</span><br>      502-&gt;N:  <span style="background-color: white">      		}</span><br>      503-&gt;N:  <span style="background-color: white">      	}</span><br>      504-&gt;N:  <span style="background-color: white">      </span><br>      505-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      506-&gt;N:  <span style="background-color: white">      	/**</span><br>      507-&gt;N:  <span style="background-color: white">      	 * Returns the size of the segment data for the given segment type.</span><br>      508-&gt;N:  <span style="background-color: white">      	 * </span><br>      509-&gt;N:  <span style="background-color: white">      	 * @param flag</span><br>      510-&gt;N:  <span style="background-color: white">      	 *            is one of the segment flags from the SegmentFlags enum.</span><br>      511-&gt;N:  <span style="background-color: white">      	 * @return the size of the segment params as the number of doubles.</span><br>      512-&gt;N:  <span style="background-color: white">      	 */</span><br>    513-&gt;513:  <span style="background-color: white">      	public static int getSegmentDataSize(byte flag) {</span><br>    514-&gt;514:  <span style="background-color: white">      		return _segmentParamSizes[flag];</span><br>      515-&gt;N:  <span style="background-color: white">      	}</span><br>      516-&gt;N:  <span style="background-color: white">      </span><br>      517-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      518-&gt;N:  <span style="background-color: white">      	/**</span><br>      519-&gt;N:  <span style="background-color: white">      	 * Closes last path of the MultiPathImpl with the Bezier Segment.</span><br>      520-&gt;N:  <span style="background-color: white">      	 * </span><br>      521-&gt;N:  <span style="background-color: white">      	 * The start point of the Bezier is the last point of the path and the last</span><br>      522-&gt;N:  <span style="background-color: white">      	 * point of the bezier is the first point of the path.</span><br>      523-&gt;N:  <span style="background-color: white">      	 */</span><br>    524-&gt;524:  <span style="background-color: white">      	public void closePathWithBezier(Point2D controlPoint1, Point2D controlPoint2) {</span><br>      525-&gt;N:  <span style="background-color: white">      		_touch();</span><br>      526-&gt;N:  <span style="background-color: white">      		if (isEmptyImpl())</span><br>      527-&gt;N:  <span style="background-color: white">      			throw new GeometryException(</span><br>    528-&gt;528:  <span style="background-color: white">      					"Invalid call. This operation cannot be performed on an empty geometry.");</span><br>      529-&gt;N:  <span style="background-color: white">      </span><br>    530-&gt;530:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>      531-&gt;N:  <span style="background-color: white">      </span><br>    532-&gt;532:  <span style="background-color: white">      		int pathIndex = m_paths.size() - 2;</span><br>    533-&gt;533:  <span style="background-color: white">      		byte pf = m_pathFlags.read(pathIndex);</span><br>      534-&gt;N:  <span style="background-color: white">      		m_pathFlags</span><br>    535-&gt;535:  <span style="background-color: white">      				.write(pathIndex,</span><br>    536-&gt;536:  <span style="background-color: white">      						(byte) (pf | PathFlags.enumClosed | PathFlags.enumHasNonlinearSegments));</span><br>    537-&gt;537:  <span style="background-color: white">      		_initSegmentData(6);</span><br>      538-&gt;N:  <span style="background-color: white">      </span><br>    539-&gt;539:  <span style="background-color: white">      		byte oldType = m_segmentFlags</span><br>    540-&gt;540:  <span style="background-color: white">      				.read((byte) ((m_pointCount - 1) &amp; SegmentFlags.enumSegmentMask));</span><br>    541-&gt;541:  <span style="background-color: white">      		m_segmentFlags.write(m_pointCount - 1,</span><br>    542-&gt;542:  <span style="background-color: white">      				(byte) (SegmentFlags.enumBezierSeg));</span><br>      543-&gt;N:  <span style="background-color: white">      </span><br>    544-&gt;544:  <span style="background-color: white">      		int curveIndex = m_curveParamwritePoint;</span><br>    545-&gt;545:  <span style="background-color: white">      		if (getSegmentDataSize(oldType) &lt; getSegmentDataSize((byte) SegmentFlags.enumBezierSeg)) {</span><br>    546-&gt;546:  <span style="background-color: white">      			m_segmentParamIndex.write(m_pointCount - 1, m_curveParamwritePoint);</span><br>    547-&gt;547:  <span style="background-color: white">      			m_curveParamwritePoint += 6;</span><br>      548-&gt;N:  <span style="background-color: white">      		} else {</span><br>      549-&gt;N:  <span style="background-color: white">      			// there was a closing bezier curve or an arc here. We can reuse the</span><br>      550-&gt;N:  <span style="background-color: white">      			// storage.</span><br>    551-&gt;551:  <span style="background-color: white">      			curveIndex = m_segmentParamIndex.read(m_pointCount - 1);</span><br>      552-&gt;N:  <span style="background-color: white">      		}</span><br>      553-&gt;N:  <span style="background-color: white">      </span><br>    554-&gt;554:  <span style="background-color: white">      		double z;</span><br>    555-&gt;555:  <span style="background-color: white">      		m_segmentParams.write(curveIndex, controlPoint1.x);</span><br>    556-&gt;556:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 1, controlPoint1.y);</span><br>    557-&gt;557:  <span style="background-color: white">      		z = 0;// TODO: calculate me.</span><br>    558-&gt;558:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 2, z);</span><br>      559-&gt;N:  <span style="background-color: white">      </span><br>    560-&gt;560:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 3, controlPoint2.x);</span><br>    561-&gt;561:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 4, controlPoint2.y);</span><br>    562-&gt;562:  <span style="background-color: white">      		z = 0;// TODO: calculate me.</span><br>    563-&gt;563:  <span style="background-color: white">      		m_segmentParams.write(curveIndex + 5, z);</span><br>      564-&gt;N:  <span style="background-color: white">      	}</span><br>      565-&gt;N:  <span style="background-color: white">      </span><br>      566-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      567-&gt;N:  <span style="background-color: white">      	/**</span><br>      568-&gt;N:  <span style="background-color: white">      	 * Returns True if the given path is closed (represents a Ring).</span><br>      569-&gt;N:  <span style="background-color: white">      	 */</span><br>    570-&gt;570:  <span style="background-color: cyan">      	public boolean isClosedPath(int ipath) {</span><br>      571-&gt;N:  <span style="background-color: white">      		// Should we make a function called _UpdateClosedPathFlags and call it</span><br>      572-&gt;N:  <span style="background-color: white">      		// here?</span><br>    573-&gt;573:  <span style="background-color: cyan">      		return ((byte) (m_pathFlags.read(ipath) &amp; PathFlags.enumClosed)) != 0;</span><br>      574-&gt;N:  <span style="background-color: white">      	}</span><br>      575-&gt;N:  <span style="background-color: white">      </span><br>    576-&gt;576:  <span style="background-color: white">      	public boolean isClosedPathInXYPlane(int path_index) {</span><br>    577-&gt;577:  <span style="background-color: white">      		if (isClosedPath(path_index))</span><br>    578-&gt;578:  <span style="background-color: white">      			return true;</span><br>    579-&gt;579:  <span style="background-color: white">      		int istart = getPathStart(path_index);</span><br>    580-&gt;580:  <span style="background-color: white">      		int iend = getPathEnd(path_index) - 1;</span><br>    581-&gt;581:  <span style="background-color: white">      		if (istart &gt; iend)</span><br>    582-&gt;582:  <span style="background-color: white">      			return false;</span><br>    583-&gt;583:  <span style="background-color: white">      		Point2D ptS = getXY(istart);</span><br>    584-&gt;584:  <span style="background-color: white">      		Point2D ptE = getXY(iend);</span><br>    585-&gt;585:  <span style="background-color: white">      		return ptS.isEqual(ptE);</span><br>      586-&gt;N:  <span style="background-color: white">      	}</span><br>      587-&gt;N:  <span style="background-color: white">      </span><br>      588-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      589-&gt;N:  <span style="background-color: white">      	/**</span><br>      590-&gt;N:  <span style="background-color: white">      	 * Returns True if the given path might have non-linear segments.</span><br>      591-&gt;N:  <span style="background-color: white">      	 */</span><br>    592-&gt;592:  <span style="background-color: white">      	public boolean hasNonLinearSegments(int ipath) {</span><br>      593-&gt;N:  <span style="background-color: white">      		// Should we make a function called _UpdateHasNonLinearSegmentsFlags and</span><br>      594-&gt;N:  <span style="background-color: white">      		// call it here?</span><br>    595-&gt;595:  <span style="background-color: white">      		return (m_pathFlags.read(ipath) &amp; PathFlags.enumHasNonlinearSegments) != 0;</span><br>      596-&gt;N:  <span style="background-color: white">      	}</span><br>      597-&gt;N:  <span style="background-color: white">      </span><br>      598-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    599-&gt;599:  <span style="background-color: white">      	public void addSegment(Segment segment, boolean bStartNewPath) {</span><br>    600-&gt;600:  <span style="background-color: white">      		mergeVertexDescription(segment.getDescription());</span><br>    601-&gt;601:  <span style="background-color: white">      		if (segment.getType() == Type.Line) {</span><br>    602-&gt;602:  <span style="background-color: white">      			Point point = new Point();</span><br>    603-&gt;603:  <span style="background-color: white">      			if (bStartNewPath || isEmpty()) {</span><br>    604-&gt;604:  <span style="background-color: white">      				segment.queryStart(point);</span><br>    605-&gt;605:  <span style="background-color: white">      				startPath(point);</span><br>      606-&gt;N:  <span style="background-color: white">      			}</span><br>      607-&gt;N:  <span style="background-color: white">      </span><br>    608-&gt;608:  <span style="background-color: white">      			segment.queryEnd(point);</span><br>    609-&gt;609:  <span style="background-color: white">      			lineTo(point);</span><br>      610-&gt;N:  <span style="background-color: white">      		} else {</span><br>    611-&gt;611:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>      612-&gt;N:  <span style="background-color: white">      		}</span><br>      613-&gt;N:  <span style="background-color: white">      	}</span><br>      614-&gt;N:  <span style="background-color: white">      </span><br>      615-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      616-&gt;N:  <span style="background-color: white">      	/**</span><br>      617-&gt;N:  <span style="background-color: white">      	 * adds a rectangular closed Path to the MultiPathImpl.</span><br>      618-&gt;N:  <span style="background-color: white">      	 * </span><br>      619-&gt;N:  <span style="background-color: white">      	 * @param envSrc</span><br>      620-&gt;N:  <span style="background-color: white">      	 *            is the source rectangle.</span><br>      621-&gt;N:  <span style="background-color: white">      	 * @param bReverse</span><br>      622-&gt;N:  <span style="background-color: white">      	 *            Creates reversed path.</span><br>      623-&gt;N:  <span style="background-color: white">      	 */</span><br>    624-&gt;624:  <span style="background-color: white">      	public void addEnvelope(Envelope2D envSrc, boolean bReverse) {</span><br>    625-&gt;625:  <span style="background-color: white">      		boolean bWasEmpty = m_pointCount == 0;</span><br>      626-&gt;N:  <span style="background-color: white">      </span><br>    627-&gt;627:  <span style="background-color: white">      		startPath(envSrc.xmin, envSrc.ymin);</span><br>    628-&gt;628:  <span style="background-color: white">      		if (bReverse) {</span><br>    629-&gt;629:  <span style="background-color: white">      			lineTo(envSrc.xmax, envSrc.ymin);</span><br>    630-&gt;630:  <span style="background-color: white">      			lineTo(envSrc.xmax, envSrc.ymax);</span><br>    631-&gt;631:  <span style="background-color: white">      			lineTo(envSrc.xmin, envSrc.ymax);</span><br>      632-&gt;N:  <span style="background-color: white">      		} else {</span><br>    633-&gt;633:  <span style="background-color: white">      			lineTo(envSrc.xmin, envSrc.ymax);</span><br>    634-&gt;634:  <span style="background-color: white">      			lineTo(envSrc.xmax, envSrc.ymax);</span><br>    635-&gt;635:  <span style="background-color: white">      			lineTo(envSrc.xmax, envSrc.ymin);</span><br>      636-&gt;N:  <span style="background-color: white">      		}</span><br>      637-&gt;N:  <span style="background-color: white">      </span><br>      638-&gt;N:  <span style="background-color: white">      		closePathWithLine();</span><br>    639-&gt;639:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>      640-&gt;N:  <span style="background-color: white">      </span><br>    641-&gt;641:  <span style="background-color: white">      		if (bWasEmpty &amp;&amp; !bReverse) {</span><br>    642-&gt;642:  <span style="background-color: white">      			_setDirtyFlag(DirtyFlags.DirtyIsEnvelope, false);// now we no(sic?)</span><br>      643-&gt;N:  <span style="background-color: white">      																// the polypath</span><br>      644-&gt;N:  <span style="background-color: white">      																// is envelope</span><br>      645-&gt;N:  <span style="background-color: white">      		}</span><br>      646-&gt;N:  <span style="background-color: white">      	}</span><br>      647-&gt;N:  <span style="background-color: white">      </span><br>      648-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      649-&gt;N:  <span style="background-color: white">      	/**</span><br>      650-&gt;N:  <span style="background-color: white">      	 * adds a rectangular closed Path to the MultiPathImpl.</span><br>      651-&gt;N:  <span style="background-color: white">      	 * </span><br>      652-&gt;N:  <span style="background-color: white">      	 * @param envSrc</span><br>      653-&gt;N:  <span style="background-color: white">      	 *            is the source rectangle.</span><br>      654-&gt;N:  <span style="background-color: white">      	 * @param bReverse</span><br>      655-&gt;N:  <span style="background-color: white">      	 *            Creates reversed path.</span><br>      656-&gt;N:  <span style="background-color: white">      	 */</span><br>    657-&gt;657:  <span style="background-color: cyan">      	public void addEnvelope(Envelope envSrc, boolean bReverse) {</span><br>    658-&gt;658:  <span style="background-color: cyan">      		if (envSrc.isEmpty())</span><br>    659-&gt;659:  <span style="background-color: white">      			return;</span><br>      660-&gt;N:  <span style="background-color: white">      </span><br>    661-&gt;661:  <span style="background-color: cyan">      		boolean bWasEmpty = m_pointCount == 0;</span><br>    662-&gt;662:  <span style="background-color: cyan">      		Point pt = new Point(m_description);// getDescription());</span><br>    663-&gt;663:  <span style="background-color: cyan">      		for (int i = 0, n = 4; i &lt; n; i++) {</span><br>    664-&gt;664:  <span style="background-color: cyan">      			int j = bReverse ? n - i - 1 : i;</span><br>      665-&gt;N:  <span style="background-color: white">      </span><br>    666-&gt;666:  <span style="background-color: cyan">      			envSrc.queryCornerByVal(j, pt);</span><br>    667-&gt;667:  <span style="background-color: cyan">      			if (i == 0)</span><br>    668-&gt;668:  <span style="background-color: cyan">      				startPath(pt);</span><br>      669-&gt;N:  <span style="background-color: white">      			else</span><br>    670-&gt;670:  <span style="background-color: cyan">      				lineTo(pt);</span><br>      671-&gt;N:  <span style="background-color: white">      		}</span><br>      672-&gt;N:  <span style="background-color: white">      </span><br>      673-&gt;N:  <span style="background-color: white">      		closePathWithLine();</span><br>    674-&gt;674:  <span style="background-color: cyan">      		m_bPathStarted = false;</span><br>      675-&gt;N:  <span style="background-color: white">      </span><br>    676-&gt;676:  <span style="background-color: cyan">      		if (bWasEmpty &amp;&amp; !bReverse)</span><br>    677-&gt;677:  <span style="background-color: white">      			_setDirtyFlag(DirtyFlags.DirtyIsEnvelope, false);// now we know the</span><br>      678-&gt;N:  <span style="background-color: white">      																// polypath is</span><br>      679-&gt;N:  <span style="background-color: white">      																// envelope</span><br>      680-&gt;N:  <span style="background-color: white">      	}</span><br>      681-&gt;N:  <span style="background-color: white">      </span><br>      682-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    683-&gt;683:  <span style="background-color: white">      	public void add(MultiPathImpl src, boolean bReversePaths) {</span><br>    684-&gt;684:  <span style="background-color: white">      		for (int i = 0; i &lt; src.getPathCount(); i++)</span><br>    685-&gt;685:  <span style="background-color: white">      			addPath(src, i, !bReversePaths);</span><br>      686-&gt;N:  <span style="background-color: white">      	}</span><br>      687-&gt;N:  <span style="background-color: white">      </span><br>    688-&gt;688:  <span style="background-color: white">      	public void addPath(MultiPathImpl src, int srcPathIndex, boolean bForward) {</span><br>    689-&gt;689:  <span style="background-color: white">      		insertPath(-1, src, srcPathIndex, bForward);</span><br>      690-&gt;N:  <span style="background-color: white">      	}</span><br>      691-&gt;N:  <span style="background-color: white">      </span><br>      692-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011 Significant changes to last for loop</span><br>    693-&gt;693:  <span style="background-color: white">      	public void addPath(Point2D[] _points, int count, boolean bForward) {</span><br>    694-&gt;694:  <span style="background-color: white">      		insertPath(-1, _points, 0, count, bForward);</span><br>      695-&gt;N:  <span style="background-color: white">      	}</span><br>      696-&gt;N:  <span style="background-color: white">      </span><br>    697-&gt;697:  <span style="background-color: white">      	public void addSegmentsFromPath(MultiPathImpl src, int src_path_index,</span><br>    698-&gt;698:  <span style="background-color: white">      			int src_segment_from, int src_segment_count,</span><br>    699-&gt;699:  <span style="background-color: white">      			boolean b_start_new_path) {</span><br>    700-&gt;700:  <span style="background-color: white">      		if (!b_start_new_path &amp;&amp; getPathCount() == 0)</span><br>    701-&gt;701:  <span style="background-color: white">      			b_start_new_path = true;</span><br>      702-&gt;N:  <span style="background-color: white">      </span><br>    703-&gt;703:  <span style="background-color: white">      		if (src_path_index &lt; 0)</span><br>    704-&gt;704:  <span style="background-color: white">      			src_path_index = src.getPathCount() - 1;</span><br>      705-&gt;N:  <span style="background-color: white">      </span><br>    706-&gt;706:  <span style="background-color: white">      		if (src_path_index &gt;= src.getPathCount() || src_segment_from &lt; 0</span><br>    707-&gt;707:  <span style="background-color: white">      				|| src_segment_count &lt; 0</span><br>    708-&gt;708:  <span style="background-color: white">      				|| src_segment_count &gt; src.getSegmentCount(src_path_index))</span><br>    709-&gt;709:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>      710-&gt;N:  <span style="background-color: white">      </span><br>    711-&gt;711:  <span style="background-color: white">      		if (src_segment_count == 0)</span><br>    712-&gt;712:  <span style="background-color: white">      			return;</span><br>      713-&gt;N:  <span style="background-color: white">      </span><br>    714-&gt;714:  <span style="background-color: white">      		boolean bIncludesClosingSegment = src.isClosedPath(src_path_index)</span><br>    715-&gt;715:  <span style="background-color: white">      				&amp;&amp; src_segment_from + src_segment_count == src</span><br>    716-&gt;716:  <span style="background-color: white">      						.getSegmentCount(src_path_index);</span><br>      717-&gt;N:  <span style="background-color: white">      </span><br>    718-&gt;718:  <span style="background-color: white">      		if (bIncludesClosingSegment &amp;&amp; src_segment_count == 1)</span><br>    719-&gt;719:  <span style="background-color: white">      			return;// cannot add a closing segment alone.</span><br>      720-&gt;N:  <span style="background-color: white">      </span><br>    721-&gt;721:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>      722-&gt;N:  <span style="background-color: white">      </span><br>    723-&gt;723:  <span style="background-color: white">      		mergeVertexDescription(src.getDescription());</span><br>    724-&gt;724:  <span style="background-color: white">      		int src_point_count = src_segment_count;</span><br>    725-&gt;725:  <span style="background-color: white">      		int srcFromPoint = src.getPathStart(src_path_index) + src_segment_from</span><br>    726-&gt;726:  <span style="background-color: white">      				+ 1;</span><br>    727-&gt;727:  <span style="background-color: white">      		if (b_start_new_path)// adding a new path.</span><br>      728-&gt;N:  <span style="background-color: white">      		{</span><br>    729-&gt;729:  <span style="background-color: white">      			src_point_count++;// add start point.</span><br>    730-&gt;730:  <span style="background-color: white">      			srcFromPoint--;</span><br>      731-&gt;N:  <span style="background-color: white">      		}</span><br>      732-&gt;N:  <span style="background-color: white">      </span><br>    733-&gt;733:  <span style="background-color: white">      		if (bIncludesClosingSegment) {</span><br>    734-&gt;734:  <span style="background-color: white">      			src_point_count--;</span><br>      735-&gt;N:  <span style="background-color: white">      		}</span><br>      736-&gt;N:  <span style="background-color: white">      </span><br>    737-&gt;737:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>    738-&gt;738:  <span style="background-color: white">      		_resizeImpl(m_pointCount + src_point_count);</span><br>      739-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>      740-&gt;N:  <span style="background-color: white">      </span><br>    741-&gt;741:  <span style="background-color: white">      		if (b_start_new_path) {</span><br>    742-&gt;742:  <span style="background-color: white">      			if (src_point_count == 0)</span><br>    743-&gt;743:  <span style="background-color: white">      				return;// happens when adding a single closing segment to the</span><br>      744-&gt;N:  <span style="background-color: white">      						// new path</span><br>      745-&gt;N:  <span style="background-color: white">      </span><br>    746-&gt;746:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>      747-&gt;N:  <span style="background-color: white">      </span><br>    748-&gt;748:  <span style="background-color: white">      			byte flags = src.m_pathFlags.read(src_path_index);</span><br>    749-&gt;749:  <span style="background-color: white">      			flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>      750-&gt;N:  <span style="background-color: white">      </span><br>      751-&gt;N:  <span style="background-color: white">      			if (m_bPolygon)</span><br>    752-&gt;752:  <span style="background-color: white">      				flags |= (byte) PathFlags.enumClosed;</span><br>      753-&gt;N:  <span style="background-color: white">      </span><br>    754-&gt;754:  <span style="background-color: white">      			m_pathFlags.write(m_pathFlags.size() - 1, flags);</span><br>    755-&gt;755:  <span style="background-color: white">      			m_pathFlags.add((byte) 0);</span><br>      756-&gt;N:  <span style="background-color: white">      		} else {</span><br>    757-&gt;757:  <span style="background-color: white">      			m_paths.write(m_pathFlags.size() - 1, m_pointCount);</span><br>      758-&gt;N:  <span style="background-color: white">      		}</span><br>      759-&gt;N:  <span style="background-color: white">      </span><br>      760-&gt;N:  <span style="background-color: white">      		// Index_type absoluteIndex = pathStart + before_point_index;</span><br>      761-&gt;N:  <span style="background-color: white">      </span><br>    762-&gt;762:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>    763-&gt;763:  <span style="background-color: white">      			int semantics = m_description.getSemantics(iattr);</span><br>    764-&gt;764:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>      765-&gt;N:  <span style="background-color: white">      </span><br>    766-&gt;766:  <span style="background-color: white">      			int isrcAttr = src.m_description.getAttributeIndex(semantics);</span><br>    767-&gt;767:  <span style="background-color: white">      			if (isrcAttr &lt; 0 || src.m_vertexAttributes[isrcAttr] == null) {// The</span><br>      768-&gt;N:  <span style="background-color: white">      																			// source</span><br>      769-&gt;N:  <span style="background-color: white">      																			// does</span><br>      770-&gt;N:  <span style="background-color: white">      																			// not</span><br>      771-&gt;N:  <span style="background-color: white">      																			// have</span><br>      772-&gt;N:  <span style="background-color: white">      																			// the</span><br>      773-&gt;N:  <span style="background-color: white">      																			// attribute.</span><br>      774-&gt;N:  <span style="background-color: white">      																			// insert</span><br>      775-&gt;N:  <span style="background-color: white">      																			// default</span><br>      776-&gt;N:  <span style="background-color: white">      																			// value</span><br>    777-&gt;777:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>    778-&gt;778:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(comp * oldPointCount, v,</span><br>    779-&gt;779:  <span style="background-color: white">      						src_point_count * comp, comp * oldPointCount);</span><br>    780-&gt;780:  <span style="background-color: white">      				continue;</span><br>      781-&gt;N:  <span style="background-color: white">      			}</span><br>      782-&gt;N:  <span style="background-color: white">      </span><br>      783-&gt;N:  <span style="background-color: white">      			// add vertices to the given stream</span><br>    784-&gt;784:  <span style="background-color: white">      			boolean b_forward = true;</span><br>    785-&gt;785:  <span style="background-color: white">      			m_vertexAttributes[iattr].insertRange(comp * oldPointCount,</span><br>    786-&gt;786:  <span style="background-color: white">      					src.m_vertexAttributes[isrcAttr], comp * srcFromPoint,</span><br>    787-&gt;787:  <span style="background-color: white">      					src_point_count * comp, b_forward, comp, comp</span><br>    788-&gt;788:  <span style="background-color: white">      							* oldPointCount);</span><br>      789-&gt;N:  <span style="background-color: white">      		}</span><br>      790-&gt;N:  <span style="background-color: white">      </span><br>      791-&gt;N:  <span style="background-color: white">      		if (hasNonLinearSegments()) {</span><br>      792-&gt;N:  <span style="background-color: white">      			// TODO: implement me. For example as a while loop over all curves.</span><br>      793-&gt;N:  <span style="background-color: white">      			// Replace, calling ReplaceSegment</span><br>    794-&gt;794:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>      795-&gt;N:  <span style="background-color: white">      			// m_segment_flags-&gt;write_range((get_path_start(path_index) +</span><br>      796-&gt;N:  <span style="background-color: white">      			// before_point_index + src_point_count), (oldPointCount -</span><br>      797-&gt;N:  <span style="background-color: white">      			// get_path_start(path_index) - before_point_index),</span><br>      798-&gt;N:  <span style="background-color: white">      			// m_segment_flags, (get_path_start(path_index) +</span><br>      799-&gt;N:  <span style="background-color: white">      			// before_point_index), true, 1);</span><br>      800-&gt;N:  <span style="background-color: white">      			// m_segment_param_index-&gt;write_range((get_path_start(path_index) +</span><br>      801-&gt;N:  <span style="background-color: white">      			// before_point_index + src_point_count), (oldPointCount -</span><br>      802-&gt;N:  <span style="background-color: white">      			// get_path_start(path_index) - before_point_index),</span><br>      803-&gt;N:  <span style="background-color: white">      			// m_segment_param_index, (get_path_start(path_index) +</span><br>      804-&gt;N:  <span style="background-color: white">      			// before_point_index), true, 1);</span><br>      805-&gt;N:  <span style="background-color: white">      			// for (Index_type i = get_path_start(path_index) +</span><br>      806-&gt;N:  <span style="background-color: white">      			// before_point_index, n = get_path_start(path_index) +</span><br>      807-&gt;N:  <span style="background-color: white">      			// before_point_index + src_point_count; i &lt; n; i++)</span><br>      808-&gt;N:  <span style="background-color: white">      			// {</span><br>      809-&gt;N:  <span style="background-color: white">      			// m_segment_flags-&gt;write(i, (int8_t)enum_value1(Segment_flags,</span><br>      810-&gt;N:  <span style="background-color: white">      			// enum_line_seg));</span><br>      811-&gt;N:  <span style="background-color: white">      			// m_segment_param_index-&gt;write(i, -1);</span><br>      812-&gt;N:  <span style="background-color: white">      			// }</span><br>      813-&gt;N:  <span style="background-color: white">      		}</span><br>      814-&gt;N:  <span style="background-color: white">      </span><br>    815-&gt;815:  <span style="background-color: white">      		if (src.hasNonLinearSegments(src_path_index)) {</span><br>      816-&gt;N:  <span style="background-color: white">      			// TODO: implement me. For example as a while loop over all curves.</span><br>      817-&gt;N:  <span style="background-color: white">      			// Replace, calling ReplaceSegment</span><br>    818-&gt;818:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>      819-&gt;N:  <span style="background-color: white">      		}</span><br>      820-&gt;N:  <span style="background-color: white">      </span><br>    821-&gt;821:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>      822-&gt;N:  <span style="background-color: white">      	}</span><br>      823-&gt;N:  <span style="background-color: white">      </span><br>      824-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    825-&gt;825:  <span style="background-color: white">      	public void reverseAllPaths() {</span><br>    826-&gt;826:  <span style="background-color: white">      		for (int i = 0, n = getPathCount(); i &lt; n; i++) {</span><br>    827-&gt;827:  <span style="background-color: white">      			reversePath(i);</span><br>      828-&gt;N:  <span style="background-color: white">      		}</span><br>      829-&gt;N:  <span style="background-color: white">      	}</span><br>      830-&gt;N:  <span style="background-color: white">      </span><br>      831-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>    832-&gt;832:  <span style="background-color: cyan">      	public void reversePath(int pathIndex) {</span><br>      833-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>    834-&gt;834:  <span style="background-color: cyan">      		int pathCount = getPathCount();</span><br>    835-&gt;835:  <span style="background-color: cyan">      		if (pathIndex &gt;= pathCount)</span><br>    836-&gt;836:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>      837-&gt;N:  <span style="background-color: white">      </span><br>    838-&gt;838:  <span style="background-color: cyan">      		int reversedPathStart = getPathStart(pathIndex);</span><br>    839-&gt;839:  <span style="background-color: cyan">      		int reversedPathSize = getPathSize(pathIndex);</span><br>    840-&gt;840:  <span style="background-color: cyan">      		int offset = isClosedPath(pathIndex) ? 1 : 0;</span><br>      841-&gt;N:  <span style="background-color: white">      </span><br>      842-&gt;N:  <span style="background-color: white">      		// TODO: a bug for the non linear segments here.</span><br>      843-&gt;N:  <span style="background-color: white">      		// There could be an issue here if someone explicity closes the path</span><br>      844-&gt;N:  <span style="background-color: white">      		// with the same start/end point.</span><br>    845-&gt;845:  <span style="background-color: cyan">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>    846-&gt;846:  <span style="background-color: cyan">      			if (m_vertexAttributes[iattr] != null) {</span><br>    847-&gt;847:  <span style="background-color: cyan">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>    848-&gt;848:  <span style="background-color: cyan">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>    849-&gt;849:  <span style="background-color: cyan">      				m_vertexAttributes[iattr].reverseRange(comp</span><br>    850-&gt;850:  <span style="background-color: white">      						* (reversedPathStart + offset), comp</span><br>    851-&gt;851:  <span style="background-color: white">      						* (reversedPathSize - offset), comp);</span><br>      852-&gt;N:  <span style="background-color: white">      			}</span><br>      853-&gt;N:  <span style="background-color: white">      		}</span><br>      854-&gt;N:  <span style="background-color: white">      </span><br>    855-&gt;855:  <span style="background-color: cyan">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>      856-&gt;N:  <span style="background-color: white">      	}</span><br>      857-&gt;N:  <span style="background-color: white">      </span><br>      858-&gt;N:  <span style="background-color: white">      	// Reviewed vs. Native Jan 11, 2011</span><br>      859-&gt;N:  <span style="background-color: white">      	// TODO: Nonlinearsegments</span><br>    860-&gt;860:  <span style="background-color: white">      	public void removePath(int pathIndex) {</span><br>      861-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>    862-&gt;862:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>      863-&gt;N:  <span style="background-color: white">      </span><br>    864-&gt;864:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>    865-&gt;865:  <span style="background-color: white">      			pathIndex = pathCount - 1;</span><br>      866-&gt;N:  <span style="background-color: white">      </span><br>    867-&gt;867:  <span style="background-color: white">      		if (pathIndex &gt;= pathCount)</span><br>    868-&gt;868:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>      869-&gt;N:  <span style="background-color: white">      </span><br>    870-&gt;870:  <span style="background-color: white">      		boolean bDirtyRingAreas2D = _hasDirtyFlag(DirtyFlags.DirtyRingAreas2D);</span><br>      871-&gt;N:  <span style="background-color: white">      </span><br>    872-&gt;872:  <span style="background-color: white">      		int removedPathStart = getPathStart(pathIndex);</span><br>    873-&gt;873:  <span style="background-color: white">      		int removedPathSize = getPathSize(pathIndex);</span><br>      874-&gt;N:  <span style="background-color: white">      </span><br>      875-&gt;N:  <span style="background-color: white">      		// Remove the attribute values for the path</span><br>    876-&gt;876:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>    877-&gt;877:  <span style="background-color: white">      			if (m_vertexAttributes[iattr] != null) {</span><br>    878-&gt;878:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>    879-&gt;879:  <span style="background-color: white">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>    880-&gt;880:  <span style="background-color: white">      				m_vertexAttributes[iattr].eraseRange(comp * removedPathStart,</span><br>    881-&gt;881:  <span style="background-color: white">      						comp * removedPathSize, comp * m_pointCount);</span><br>      882-&gt;N:  <span style="background-color: white">      			}</span><br>      883-&gt;N:  <span style="background-color: white">      		}</span><br>      884-&gt;N:  <span style="background-color: white">      </span><br>      885-&gt;N:  <span style="background-color: white">      		// Change the start of each path after the removed path</span><br>    886-&gt;886:  <span style="background-color: white">      		for (int i = pathIndex + 1; i &lt;= pathCount; i++) {</span><br>    887-&gt;887:  <span style="background-color: white">      			int istart = m_paths.read(i);</span><br>    888-&gt;888:  <span style="background-color: white">      			m_paths.write(i - 1, istart - removedPathSize);</span><br>      889-&gt;N:  <span style="background-color: white">      		}</span><br>      890-&gt;N:  <span style="background-color: white">      </span><br>    891-&gt;891:  <span style="background-color: white">      		if (m_pathFlags == null) {</span><br>    892-&gt;892:  <span style="background-color: white">      			for (int i = pathIndex + 1; i &lt;= pathCount; i++) {</span><br>    893-&gt;893:  <span style="background-color: white">      				byte flags = m_pathFlags.read(i);</span><br>    894-&gt;894:  <span style="background-color: white">      				m_pathFlags.write(i - 1, flags);</span><br>      895-&gt;N:  <span style="background-color: white">      			}</span><br>      896-&gt;N:  <span style="background-color: white">      		}</span><br>      897-&gt;N:  <span style="background-color: white">      </span><br>    898-&gt;898:  <span style="background-color: white">      		m_paths.resize(pathCount);</span><br>    899-&gt;899:  <span style="background-color: white">      		m_pathFlags.resize(pathCount);</span><br>    900-&gt;900:  <span style="background-color: white">      		m_pointCount -= removedPathSize;</span><br>    901-&gt;901:  <span style="background-color: white">      		m_reservedPointCount -= removedPathSize;</span><br>      902-&gt;N:  <span style="background-color: white">      </span><br>    903-&gt;903:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>      904-&gt;N:  <span style="background-color: white">      	}</span><br>      905-&gt;N:  <span style="background-color: white">      </span><br>      906-&gt;N:  <span style="background-color: white">      	// TODO: Nonlinearsegments</span><br>    907-&gt;907:  <span style="background-color: white">      	public void insertPath(int pathIndex, MultiPathImpl src, int srcPathIndex,</span><br>    908-&gt;908:  <span style="background-color: white">      			boolean bForward) {</span><br>    909-&gt;909:  <span style="background-color: white">      		if (src == this)</span><br>    910-&gt;910:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>      911-&gt;N:  <span style="background-color: white">      </span><br>    912-&gt;912:  <span style="background-color: white">      		if (srcPathIndex &gt;= src.getPathCount())</span><br>    913-&gt;913:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>      914-&gt;N:  <span style="background-color: white">      </span><br>    915-&gt;915:  <span style="background-color: white">      		int oldPathCount = getPathCount();</span><br>    916-&gt;916:  <span style="background-color: white">      		if (pathIndex &gt; oldPathCount)</span><br>    917-&gt;917:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>      918-&gt;N:  <span style="background-color: white">      </span><br>    919-&gt;919:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>    920-&gt;920:  <span style="background-color: white">      			pathIndex = oldPathCount;</span><br>      921-&gt;N:  <span style="background-color: white">      </span><br>    922-&gt;922:  <span style="background-color: white">      		if (srcPathIndex &lt; 0)</span><br>    923-&gt;923:  <span style="background-color: white">      			srcPathIndex = src.getPathCount() - 1;</span><br>      924-&gt;N:  <span style="background-color: white">      </span><br>    925-&gt;925:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>      926-&gt;N:  <span style="background-color: white">      </span><br>    927-&gt;927:  <span style="background-color: white">      		mergeVertexDescription(src.m_description);// merge attributes from the</span><br>      928-&gt;N:  <span style="background-color: white">      													// source</span><br>      929-&gt;N:  <span style="background-color: white">      </span><br>    930-&gt;930:  <span style="background-color: white">      		src._verifyAllStreams();// the source need to be correct.</span><br>      931-&gt;N:  <span style="background-color: white">      </span><br>    932-&gt;932:  <span style="background-color: white">      		int srcPathIndexStart = src.getPathStart(srcPathIndex);</span><br>    933-&gt;933:  <span style="background-color: white">      		int srcPathSize = src.getPathSize(srcPathIndex);</span><br>    934-&gt;934:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>    935-&gt;935:  <span style="background-color: white">      		int offset = src.isClosedPath(srcPathIndex) &amp;&amp; !bForward ? 1 : 0;</span><br>      936-&gt;N:  <span style="background-color: white">      </span><br>    937-&gt;937:  <span style="background-color: white">      		_resizeImpl(m_pointCount + srcPathSize);</span><br>      938-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>    939-&gt;939:  <span style="background-color: white">      		int pathIndexStart = pathIndex &lt; oldPathCount ? getPathStart(pathIndex)</span><br>    940-&gt;940:  <span style="background-color: white">      				: oldPointCount;</span><br>      941-&gt;N:  <span style="background-color: white">      </span><br>      942-&gt;N:  <span style="background-color: white">      		// Copy all attribute values.</span><br>    943-&gt;943:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>    944-&gt;944:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>    945-&gt;945:  <span style="background-color: white">      			int isrcAttr = src.m_description.getAttributeIndex(semantics);</span><br>      946-&gt;N:  <span style="background-color: white">      </span><br>    947-&gt;947:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>      948-&gt;N:  <span style="background-color: white">      </span><br>    949-&gt;949:  <span style="background-color: white">      			if (isrcAttr &gt;= 0 &amp;&amp; src.m_vertexAttributes[isrcAttr] != null) {</span><br>    950-&gt;950:  <span style="background-color: white">      				if (offset != 0)</span><br>    951-&gt;951:  <span style="background-color: white">      					m_vertexAttributes[iattr].insertRange(</span><br>    952-&gt;952:  <span style="background-color: white">      							pathIndexStart * comp,</span><br>    953-&gt;953:  <span style="background-color: white">      							src.m_vertexAttributes[isrcAttr], comp</span><br>    954-&gt;954:  <span style="background-color: white">      									* srcPathIndexStart, comp, true, comp, comp</span><br>    955-&gt;955:  <span style="background-color: white">      									* oldPointCount);</span><br>    956-&gt;956:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange((pathIndexStart + offset)</span><br>    957-&gt;957:  <span style="background-color: white">      						* comp, src.m_vertexAttributes[isrcAttr], comp</span><br>    958-&gt;958:  <span style="background-color: white">      						* (srcPathIndexStart + offset), comp</span><br>    959-&gt;959:  <span style="background-color: white">      						* (srcPathSize - offset), bForward, comp, comp</span><br>    960-&gt;960:  <span style="background-color: white">      						* (oldPointCount + offset));</span><br>      961-&gt;N:  <span style="background-color: white">      			} else {</span><br>      962-&gt;N:  <span style="background-color: white">      				// Need to make room for the attributes, so we copy default</span><br>      963-&gt;N:  <span style="background-color: white">      				// values in</span><br>      964-&gt;N:  <span style="background-color: white">      </span><br>    965-&gt;965:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>    966-&gt;966:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(pathIndexStart * comp, v,</span><br>    967-&gt;967:  <span style="background-color: white">      						comp * srcPathSize, comp * oldPointCount);</span><br>      968-&gt;N:  <span style="background-color: white">      			}</span><br>      969-&gt;N:  <span style="background-color: white">      		}</span><br>      970-&gt;N:  <span style="background-color: white">      </span><br>    971-&gt;971:  <span style="background-color: white">      		int newPointCount = oldPointCount + srcPathSize;</span><br>    972-&gt;972:  <span style="background-color: white">      		m_paths.add(newPointCount);</span><br>      973-&gt;N:  <span style="background-color: white">      </span><br>    974-&gt;974:  <span style="background-color: white">      		for (int ipath = oldPathCount; ipath &gt;= pathIndex + 1; ipath--) {</span><br>    975-&gt;975:  <span style="background-color: white">      			int iend = m_paths.read(ipath - 1);</span><br>    976-&gt;976:  <span style="background-color: white">      			m_paths.write(ipath, iend + srcPathSize);</span><br>      977-&gt;N:  <span style="background-color: white">      		}</span><br>      978-&gt;N:  <span style="background-color: white">      </span><br>      979-&gt;N:  <span style="background-color: white">      		// ========================== todo: NonLinearSegments =================</span><br>    980-&gt;980:  <span style="background-color: white">      		if (src.hasNonLinearSegments(srcPathIndex)) {</span><br>      981-&gt;N:  <span style="background-color: white">      </span><br>      982-&gt;N:  <span style="background-color: white">      		}</span><br>      983-&gt;N:  <span style="background-color: white">      </span><br>    984-&gt;984:  <span style="background-color: white">      		m_pathFlags.add((byte) 0);</span><br>      985-&gt;N:  <span style="background-color: white">      </span><br>      986-&gt;N:  <span style="background-color: white">      		// _ASSERT(m_pathFlags.size() == m_paths.size());</span><br>      987-&gt;N:  <span style="background-color: white">      </span><br>    988-&gt;988:  <span style="background-color: white">      		for (int ipath = oldPathCount - 1; ipath &gt;= pathIndex + 1; ipath--) {</span><br>    989-&gt;989:  <span style="background-color: white">      			byte flags = m_pathFlags.read(ipath);</span><br>    990-&gt;990:  <span style="background-color: white">      			flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>    991-&gt;991:  <span style="background-color: white">      			m_pathFlags.write(ipath + 1, flags);</span><br>      992-&gt;N:  <span style="background-color: white">      		}</span><br>      993-&gt;N:  <span style="background-color: white">      </span><br>    994-&gt;994:  <span style="background-color: white">      		AttributeStreamOfInt8 srcPathFlags = src.getPathFlagsStreamRef();</span><br>    995-&gt;995:  <span style="background-color: white">      		byte flags = srcPathFlags.read(srcPathIndex);</span><br>    996-&gt;996:  <span style="background-color: white">      		flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>      997-&gt;N:  <span style="background-color: white">      </span><br>      998-&gt;N:  <span style="background-color: white">      		if (m_bPolygon)</span><br>    999-&gt;999:  <span style="background-color: white">      			flags |= (byte) PathFlags.enumClosed;</span><br>     1000-&gt;N:  <span style="background-color: white">      </span><br>  1001-&gt;1001:  <span style="background-color: white">      		m_pathFlags.write(pathIndex, flags);</span><br>     1002-&gt;N:  <span style="background-color: white">      	}</span><br>     1003-&gt;N:  <span style="background-color: white">      </span><br>  1004-&gt;1004:  <span style="background-color: white">      	public void insertPath(int pathIndex, Point2D[] points, int pointsOffset,</span><br>  1005-&gt;1005:  <span style="background-color: white">      			int count, boolean bForward) {</span><br>  1006-&gt;1006:  <span style="background-color: white">      		int oldPathCount = getPathCount();</span><br>  1007-&gt;1007:  <span style="background-color: white">      		if (pathIndex &gt; oldPathCount)</span><br>  1008-&gt;1008:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>     1009-&gt;N:  <span style="background-color: white">      </span><br>  1010-&gt;1010:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>  1011-&gt;1011:  <span style="background-color: white">      			pathIndex = oldPathCount;</span><br>     1012-&gt;N:  <span style="background-color: white">      </span><br>  1013-&gt;1013:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>     1014-&gt;N:  <span style="background-color: white">      </span><br>  1015-&gt;1015:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>     1016-&gt;N:  <span style="background-color: white">      </span><br>     1017-&gt;N:  <span style="background-color: white">      		// Copy all attribute values.</span><br>  1018-&gt;1018:  <span style="background-color: white">      		if (points != null) {</span><br>  1019-&gt;1019:  <span style="background-color: white">      			_resizeImpl(m_pointCount + count);</span><br>     1020-&gt;N:  <span style="background-color: white">      			_verifyAllStreams();</span><br>     1021-&gt;N:  <span style="background-color: white">      </span><br>  1022-&gt;1022:  <span style="background-color: white">      			int pathStart = pathIndex &lt; oldPathCount ? getPathStart(pathIndex)</span><br>  1023-&gt;1023:  <span style="background-color: white">      					: oldPointCount;</span><br>     1024-&gt;N:  <span style="background-color: white">      </span><br>  1025-&gt;1025:  <span style="background-color: white">      			for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>  1026-&gt;1026:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>     1027-&gt;N:  <span style="background-color: white">      </span><br>  1028-&gt;1028:  <span style="background-color: white">      				if (semantics == VertexDescription.Semantics.POSITION) {</span><br>     1029-&gt;N:  <span style="background-color: white">      					// copy range to make place for new vertices</span><br>  1030-&gt;1030:  <span style="background-color: white">      					m_vertexAttributes[iattr].writeRange(</span><br>  1031-&gt;1031:  <span style="background-color: white">      							2 * (pathStart + count),</span><br>  1032-&gt;1032:  <span style="background-color: white">      							2 * (oldPointCount - pathIndex),</span><br>  1033-&gt;1033:  <span style="background-color: white">      							m_vertexAttributes[iattr], 2 * pathStart, true, 2);</span><br>     1034-&gt;N:  <span style="background-color: white">      </span><br>  1035-&gt;1035:  <span style="background-color: white">      					AttributeStreamOfDbl position = (AttributeStreamOfDbl) (AttributeStreamBase) getAttributeStreamRef(semantics);</span><br>     1036-&gt;N:  <span style="background-color: white">      </span><br>  1037-&gt;1037:  <span style="background-color: white">      					int j = pathStart;</span><br>  1038-&gt;1038:  <span style="background-color: white">      					for (int i = 0; i &lt; count; i++, j++) {</span><br>  1039-&gt;1039:  <span style="background-color: white">      						int index = (bForward ? pointsOffset + i : pointsOffset</span><br>  1040-&gt;1040:  <span style="background-color: white">      								+ count - i - 1);</span><br>  1041-&gt;1041:  <span style="background-color: white">      						position.write(2 * j, points[index].x);</span><br>  1042-&gt;1042:  <span style="background-color: white">      						position.write(2 * j + 1, points[index].y);</span><br>     1043-&gt;N:  <span style="background-color: white">      					}</span><br>     1044-&gt;N:  <span style="background-color: white">      				} else {</span><br>     1045-&gt;N:  <span style="background-color: white">      					// Need to make room for the attributes, so we copy default</span><br>     1046-&gt;N:  <span style="background-color: white">      					// values in</span><br>     1047-&gt;N:  <span style="background-color: white">      </span><br>  1048-&gt;1048:  <span style="background-color: white">      					int comp = VertexDescription.getComponentCount(semantics);</span><br>  1049-&gt;1049:  <span style="background-color: white">      					double v = VertexDescription.getDefaultValue(semantics);</span><br>  1050-&gt;1050:  <span style="background-color: white">      					m_vertexAttributes[iattr].insertRange(pathStart * comp, v,</span><br>  1051-&gt;1051:  <span style="background-color: white">      							comp * count, comp * oldPointCount);</span><br>     1052-&gt;N:  <span style="background-color: white">      				}</span><br>     1053-&gt;N:  <span style="background-color: white">      			}</span><br>     1054-&gt;N:  <span style="background-color: white">      		} else {</span><br>     1055-&gt;N:  <span style="background-color: white">      			_verifyAllStreams();</span><br>     1056-&gt;N:  <span style="background-color: white">      		}</span><br>     1057-&gt;N:  <span style="background-color: white">      </span><br>  1058-&gt;1058:  <span style="background-color: white">      		m_paths.add(m_pointCount);</span><br>     1059-&gt;N:  <span style="background-color: white">      </span><br>  1060-&gt;1060:  <span style="background-color: white">      		for (int ipath = oldPathCount; ipath &gt;= pathIndex + 1; ipath--) {</span><br>  1061-&gt;1061:  <span style="background-color: white">      			int iend = m_paths.read(ipath - 1);</span><br>  1062-&gt;1062:  <span style="background-color: white">      			m_paths.write(ipath, iend + count);</span><br>     1063-&gt;N:  <span style="background-color: white">      		}</span><br>     1064-&gt;N:  <span style="background-color: white">      </span><br>  1065-&gt;1065:  <span style="background-color: white">      		m_pathFlags.add((byte) 0);</span><br>     1066-&gt;N:  <span style="background-color: white">      </span><br>     1067-&gt;N:  <span style="background-color: white">      		// _ASSERT(m_pathFlags.size() == m_paths.size());</span><br>     1068-&gt;N:  <span style="background-color: white">      </span><br>  1069-&gt;1069:  <span style="background-color: white">      		for (int ipath = oldPathCount - 1; ipath &gt;= pathIndex + 1; ipath--) {</span><br>  1070-&gt;1070:  <span style="background-color: white">      			byte flags = m_pathFlags.read(ipath);</span><br>  1071-&gt;1071:  <span style="background-color: white">      			flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>  1072-&gt;1072:  <span style="background-color: white">      			m_pathFlags.write(ipath + 1, flags);</span><br>     1073-&gt;N:  <span style="background-color: white">      		}</span><br>     1074-&gt;N:  <span style="background-color: white">      </span><br>     1075-&gt;N:  <span style="background-color: white">      		if (m_bPolygon)</span><br>  1076-&gt;1076:  <span style="background-color: white">      			m_pathFlags.write(pathIndex, (byte) PathFlags.enumClosed);</span><br>     1077-&gt;N:  <span style="background-color: white">      	}</span><br>     1078-&gt;N:  <span style="background-color: white">      </span><br>  1079-&gt;1079:  <span style="background-color: white">      	public void insertPoints(int pathIndex, int beforePointIndex,</span><br>  1080-&gt;1080:  <span style="background-color: white">      			MultiPathImpl src, int srcPathIndex, int srcPointIndexFrom,</span><br>  1081-&gt;1081:  <span style="background-color: white">      			int srcPointCount, boolean bForward) {</span><br>  1082-&gt;1082:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>  1083-&gt;1083:  <span style="background-color: white">      			pathIndex = getPathCount();</span><br>     1084-&gt;N:  <span style="background-color: white">      </span><br>  1085-&gt;1085:  <span style="background-color: white">      		if (srcPathIndex &lt; 0)</span><br>  1086-&gt;1086:  <span style="background-color: white">      			srcPathIndex = src.getPathCount() - 1;</span><br>     1087-&gt;N:  <span style="background-color: white">      </span><br>  1088-&gt;1088:  <span style="background-color: white">      		if (pathIndex &gt; getPathCount() || beforePointIndex &gt;= 0</span><br>  1089-&gt;1089:  <span style="background-color: white">      				&amp;&amp; beforePointIndex &gt; getPathSize(pathIndex)</span><br>  1090-&gt;1090:  <span style="background-color: white">      				|| srcPathIndex &gt;= src.getPathCount()</span><br>  1091-&gt;1091:  <span style="background-color: white">      				|| srcPointCount &gt; src.getPathSize(srcPathIndex))</span><br>  1092-&gt;1092:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>     1093-&gt;N:  <span style="background-color: white">      </span><br>  1094-&gt;1094:  <span style="background-color: white">      		if (srcPointCount == 0)</span><br>  1095-&gt;1095:  <span style="background-color: white">      			return;</span><br>     1096-&gt;N:  <span style="background-color: white">      </span><br>  1097-&gt;1097:  <span style="background-color: white">      		mergeVertexDescription(src.m_description);</span><br>     1098-&gt;N:  <span style="background-color: white">      </span><br>  1099-&gt;1099:  <span style="background-color: white">      		if (pathIndex == getPathCount())// adding a new path.</span><br>     1100-&gt;N:  <span style="background-color: white">      		{</span><br>  1101-&gt;1101:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>     1102-&gt;N:  <span style="background-color: white">      </span><br>  1103-&gt;1103:  <span style="background-color: white">      			byte flags = src.m_pathFlags.read(srcPathIndex);</span><br>  1104-&gt;1104:  <span style="background-color: white">      			flags &amp;= ~(byte) PathFlags.enumCalcMask;// remove calculated flags</span><br>     1105-&gt;N:  <span style="background-color: white">      </span><br>     1106-&gt;N:  <span style="background-color: white">      			if (!m_bPolygon)</span><br>  1107-&gt;1107:  <span style="background-color: white">      				m_pathFlags.add(flags);</span><br>     1108-&gt;N:  <span style="background-color: white">      			else</span><br>  1109-&gt;1109:  <span style="background-color: white">      				m_pathFlags.add((byte) (flags | PathFlags.enumClosed));</span><br>     1110-&gt;N:  <span style="background-color: white">      		}</span><br>     1111-&gt;N:  <span style="background-color: white">      </span><br>  1112-&gt;1112:  <span style="background-color: white">      		if (beforePointIndex &lt; 0)</span><br>  1113-&gt;1113:  <span style="background-color: white">      			beforePointIndex = getPathSize(pathIndex);</span><br>     1114-&gt;N:  <span style="background-color: white">      </span><br>  1115-&gt;1115:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>  1116-&gt;1116:  <span style="background-color: white">      		_resizeImpl(m_pointCount + srcPointCount);</span><br>     1117-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>  1118-&gt;1118:  <span style="background-color: white">      		src._verifyAllStreams();</span><br>     1119-&gt;N:  <span style="background-color: white">      </span><br>  1120-&gt;1120:  <span style="background-color: white">      		int pathStart = getPathStart(pathIndex);</span><br>  1121-&gt;1121:  <span style="background-color: white">      		int absoluteIndex = pathStart + beforePointIndex;</span><br>     1122-&gt;N:  <span style="background-color: white">      </span><br>  1123-&gt;1123:  <span style="background-color: white">      		if (srcPointCount &lt; 0)</span><br>  1124-&gt;1124:  <span style="background-color: white">      			srcPointCount = src.getPathSize(srcPathIndex);</span><br>     1125-&gt;N:  <span style="background-color: white">      </span><br>  1126-&gt;1126:  <span style="background-color: white">      		int srcPathStart = src.getPathStart(srcPathIndex);</span><br>  1127-&gt;1127:  <span style="background-color: white">      		int srcAbsoluteIndex = srcPathStart + srcPointCount;</span><br>     1128-&gt;N:  <span style="background-color: white">      </span><br>  1129-&gt;1129:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>  1130-&gt;1130:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>  1131-&gt;1131:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>     1132-&gt;N:  <span style="background-color: white">      </span><br>  1133-&gt;1133:  <span style="background-color: white">      			int isrcAttr = src.m_description.getAttributeIndex(semantics);</span><br>  1134-&gt;1134:  <span style="background-color: white">      			if (isrcAttr &lt; 0 || src.m_vertexAttributes[isrcAttr] == null) // The</span><br>     1135-&gt;N:  <span style="background-color: white">      																			// source</span><br>     1136-&gt;N:  <span style="background-color: white">      																			// does</span><br>     1137-&gt;N:  <span style="background-color: white">      																			// not</span><br>     1138-&gt;N:  <span style="background-color: white">      																			// have</span><br>     1139-&gt;N:  <span style="background-color: white">      																			// the</span><br>     1140-&gt;N:  <span style="background-color: white">      																			// attribute.</span><br>     1141-&gt;N:  <span style="background-color: white">      			{</span><br>  1142-&gt;1142:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>  1143-&gt;1143:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(comp * absoluteIndex, v,</span><br>  1144-&gt;1144:  <span style="background-color: white">      						srcAbsoluteIndex * comp, comp * oldPointCount);</span><br>  1145-&gt;1145:  <span style="background-color: white">      				continue;</span><br>     1146-&gt;N:  <span style="background-color: white">      			}</span><br>     1147-&gt;N:  <span style="background-color: white">      </span><br>     1148-&gt;N:  <span style="background-color: white">      			// add vertices to the given stream</span><br>  1149-&gt;1149:  <span style="background-color: white">      			m_vertexAttributes[iattr].insertRange(comp</span><br>  1150-&gt;1150:  <span style="background-color: white">      					* (pathStart + beforePointIndex),</span><br>  1151-&gt;1151:  <span style="background-color: white">      					src.m_vertexAttributes[isrcAttr], comp</span><br>  1152-&gt;1152:  <span style="background-color: white">      							* (srcPathStart + srcPointIndexFrom), srcPointCount</span><br>  1153-&gt;1153:  <span style="background-color: white">      							* comp, bForward, comp, comp * oldPointCount);</span><br>     1154-&gt;N:  <span style="background-color: white">      		}</span><br>     1155-&gt;N:  <span style="background-color: white">      </span><br>     1156-&gt;N:  <span style="background-color: white">      		if (hasNonLinearSegments()) {// TODO: probably a bug here when a new</span><br>     1157-&gt;N:  <span style="background-color: white">      										// path is added.</span><br>  1158-&gt;1158:  <span style="background-color: white">      			m_segmentFlags.writeRange((getPathStart(pathIndex)</span><br>  1159-&gt;1159:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount), (oldPointCount</span><br>  1160-&gt;1160:  <span style="background-color: white">      					- getPathStart(pathIndex) - beforePointIndex),</span><br>     1161-&gt;N:  <span style="background-color: white">      					m_segmentFlags,</span><br>  1162-&gt;1162:  <span style="background-color: white">      					(getPathStart(pathIndex) + beforePointIndex), true, 1);</span><br>  1163-&gt;1163:  <span style="background-color: white">      			m_segmentParamIndex.writeRange((getPathStart(pathIndex)</span><br>  1164-&gt;1164:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount), (oldPointCount</span><br>  1165-&gt;1165:  <span style="background-color: white">      					- getPathStart(pathIndex) - beforePointIndex),</span><br>     1166-&gt;N:  <span style="background-color: white">      					m_segmentParamIndex,</span><br>  1167-&gt;1167:  <span style="background-color: white">      					(getPathStart(pathIndex) + beforePointIndex), true, 1);</span><br>  1168-&gt;1168:  <span style="background-color: white">      			for (int i = getPathStart(pathIndex) + beforePointIndex, n = getPathStart(pathIndex)</span><br>  1169-&gt;1169:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount; i &lt; n; i++) {</span><br>  1170-&gt;1170:  <span style="background-color: white">      				m_segmentFlags.write(i, (byte) SegmentFlags.enumLineSeg);</span><br>  1171-&gt;1171:  <span style="background-color: white">      				m_segmentParamIndex.write(i, -1);</span><br>     1172-&gt;N:  <span style="background-color: white">      			}</span><br>     1173-&gt;N:  <span style="background-color: white">      		}</span><br>     1174-&gt;N:  <span style="background-color: white">      </span><br>  1175-&gt;1175:  <span style="background-color: white">      		if (src.hasNonLinearSegments(srcPathIndex)) {</span><br>     1176-&gt;N:  <span style="background-color: white">      			// TODO: implement me. For example as a while loop over all curves.</span><br>     1177-&gt;N:  <span style="background-color: white">      			// Replace, calling ReplaceSegment</span><br>  1178-&gt;1178:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>     1179-&gt;N:  <span style="background-color: white">      		}</span><br>     1180-&gt;N:  <span style="background-color: white">      </span><br>  1181-&gt;1181:  <span style="background-color: white">      		for (int ipath = pathIndex + 1, npaths = getPathCount(); ipath &lt;= npaths; ipath++) {</span><br>  1182-&gt;1182:  <span style="background-color: white">      			int num = m_paths.read(ipath);</span><br>  1183-&gt;1183:  <span style="background-color: white">      			m_paths.write(ipath, num + srcPointCount);</span><br>     1184-&gt;N:  <span style="background-color: white">      		}</span><br>     1185-&gt;N:  <span style="background-color: white">      	}</span><br>     1186-&gt;N:  <span style="background-color: white">      </span><br>  1187-&gt;1187:  <span style="background-color: white">      	public void insertPoints(int pathIndex, int beforePointIndex,</span><br>  1188-&gt;1188:  <span style="background-color: white">      			Point2D[] src, int srcPointIndexFrom, int srcPointCount,</span><br>  1189-&gt;1189:  <span style="background-color: white">      			boolean bForward) {</span><br>  1190-&gt;1190:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>  1191-&gt;1191:  <span style="background-color: white">      			pathIndex = getPathCount();</span><br>     1192-&gt;N:  <span style="background-color: white">      </span><br>  1193-&gt;1193:  <span style="background-color: white">      		if (pathIndex &gt; getPathCount()</span><br>  1194-&gt;1194:  <span style="background-color: white">      				|| beforePointIndex &gt; getPathSize(pathIndex)</span><br>  1195-&gt;1195:  <span style="background-color: white">      				|| srcPointIndexFrom &lt; 0 || srcPointCount &gt; src.length)</span><br>  1196-&gt;1196:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>     1197-&gt;N:  <span style="background-color: white">      </span><br>  1198-&gt;1198:  <span style="background-color: white">      		if (srcPointCount == 0)</span><br>  1199-&gt;1199:  <span style="background-color: white">      			return;</span><br>     1200-&gt;N:  <span style="background-color: white">      </span><br>  1201-&gt;1201:  <span style="background-color: white">      		if (pathIndex == getPathCount())// adding a new path.</span><br>     1202-&gt;N:  <span style="background-color: white">      		{</span><br>  1203-&gt;1203:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>     1204-&gt;N:  <span style="background-color: white">      </span><br>     1205-&gt;N:  <span style="background-color: white">      			if (!m_bPolygon)</span><br>  1206-&gt;1206:  <span style="background-color: white">      				m_pathFlags.add((byte) 0);</span><br>     1207-&gt;N:  <span style="background-color: white">      			else</span><br>  1208-&gt;1208:  <span style="background-color: white">      				m_pathFlags.add((byte) PathFlags.enumClosed);</span><br>     1209-&gt;N:  <span style="background-color: white">      		}</span><br>     1210-&gt;N:  <span style="background-color: white">      </span><br>  1211-&gt;1211:  <span style="background-color: white">      		if (beforePointIndex &lt; 0)</span><br>  1212-&gt;1212:  <span style="background-color: white">      			beforePointIndex = getPathSize(pathIndex);</span><br>     1213-&gt;N:  <span style="background-color: white">      </span><br>     1214-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>  1215-&gt;1215:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>  1216-&gt;1216:  <span style="background-color: white">      		_resizeImpl(m_pointCount + srcPointCount);</span><br>     1217-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>  1218-&gt;1218:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>  1219-&gt;1219:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>  1220-&gt;1220:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>     1221-&gt;N:  <span style="background-color: white">      			// copy range to make place for new vertices</span><br>  1222-&gt;1222:  <span style="background-color: white">      			m_vertexAttributes[iattr]</span><br>     1223-&gt;N:  <span style="background-color: white">      					.writeRange(</span><br>  1224-&gt;1224:  <span style="background-color: white">      							comp</span><br>  1225-&gt;1225:  <span style="background-color: white">      									* (getPathStart(pathIndex)</span><br>  1226-&gt;1226:  <span style="background-color: white">      											+ beforePointIndex + srcPointCount),</span><br>  1227-&gt;1227:  <span style="background-color: white">      							(oldPointCount - getPathStart(pathIndex) - beforePointIndex)</span><br>  1228-&gt;1228:  <span style="background-color: white">      									* comp,</span><br>  1229-&gt;1229:  <span style="background-color: white">      							m_vertexAttributes[iattr],</span><br>  1230-&gt;1230:  <span style="background-color: white">      							comp * (getPathStart(pathIndex) + beforePointIndex),</span><br>  1231-&gt;1231:  <span style="background-color: white">      							true, comp);</span><br>     1232-&gt;N:  <span style="background-color: white">      </span><br>  1233-&gt;1233:  <span style="background-color: white">      			if (iattr == 0) {</span><br>     1234-&gt;N:  <span style="background-color: white">      				// add vertices to the given stream</span><br>  1235-&gt;1235:  <span style="background-color: white">      				((AttributeStreamOfDbl) (AttributeStreamBase) m_vertexAttributes[iattr])</span><br>  1236-&gt;1236:  <span style="background-color: white">      						.writeRange(comp</span><br>  1237-&gt;1237:  <span style="background-color: white">      								* (getPathStart(pathIndex) + beforePointIndex),</span><br>  1238-&gt;1238:  <span style="background-color: white">      								srcPointCount, src, srcPointIndexFrom, bForward);</span><br>     1239-&gt;N:  <span style="background-color: white">      			} else {</span><br>  1240-&gt;1240:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>  1241-&gt;1241:  <span style="background-color: white">      				m_vertexAttributes[iattr].setRange(v,</span><br>  1242-&gt;1242:  <span style="background-color: white">      						(getPathStart(pathIndex) + beforePointIndex) * comp,</span><br>  1243-&gt;1243:  <span style="background-color: white">      						srcPointCount * comp);</span><br>     1244-&gt;N:  <span style="background-color: white">      			}</span><br>     1245-&gt;N:  <span style="background-color: white">      		}</span><br>     1246-&gt;N:  <span style="background-color: white">      </span><br>     1247-&gt;N:  <span style="background-color: white">      		if (hasNonLinearSegments()) {</span><br>  1248-&gt;1248:  <span style="background-color: white">      			m_segmentFlags.writeRange((getPathStart(pathIndex)</span><br>  1249-&gt;1249:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount), (oldPointCount</span><br>  1250-&gt;1250:  <span style="background-color: white">      					- getPathStart(pathIndex) - beforePointIndex),</span><br>     1251-&gt;N:  <span style="background-color: white">      					m_segmentFlags,</span><br>  1252-&gt;1252:  <span style="background-color: white">      					(getPathStart(pathIndex) + beforePointIndex), true, 1);</span><br>  1253-&gt;1253:  <span style="background-color: white">      			m_segmentParamIndex.writeRange((getPathStart(pathIndex)</span><br>  1254-&gt;1254:  <span style="background-color: white">      					+ beforePointIndex + srcPointCount), (oldPointCount</span><br>  1255-&gt;1255:  <span style="background-color: white">      					- getPathStart(pathIndex) - beforePointIndex),</span><br>     1256-&gt;N:  <span style="background-color: white">      					m_segmentParamIndex,</span><br>  1257-&gt;1257:  <span style="background-color: white">      					(getPathStart(pathIndex) + beforePointIndex), true, 1);</span><br>  1258-&gt;1258:  <span style="background-color: white">      			m_segmentFlags.setRange((byte) SegmentFlags.enumLineSeg,</span><br>  1259-&gt;1259:  <span style="background-color: white">      					getPathStart(pathIndex) + beforePointIndex, srcPointCount);</span><br>  1260-&gt;1260:  <span style="background-color: white">      			m_segmentParamIndex.setRange(-1, getPathStart(pathIndex)</span><br>  1261-&gt;1261:  <span style="background-color: white">      					+ beforePointIndex, srcPointCount);</span><br>     1262-&gt;N:  <span style="background-color: white">      		}</span><br>     1263-&gt;N:  <span style="background-color: white">      </span><br>  1264-&gt;1264:  <span style="background-color: white">      		for (int ipath = pathIndex + 1, npaths = getPathCount(); ipath &lt;= npaths; ipath++) {</span><br>  1265-&gt;1265:  <span style="background-color: white">      			m_paths.write(ipath, m_paths.read(ipath) + srcPointCount);</span><br>     1266-&gt;N:  <span style="background-color: white">      		}</span><br>     1267-&gt;N:  <span style="background-color: white">      	}</span><br>     1268-&gt;N:  <span style="background-color: white">      </span><br>  1269-&gt;1269:  <span style="background-color: white">      	public void insertPoint(int pathIndex, int beforePointIndex, Point2D pt) {</span><br>  1270-&gt;1270:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>     1271-&gt;N:  <span style="background-color: white">      </span><br>  1272-&gt;1272:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>  1273-&gt;1273:  <span style="background-color: white">      			pathIndex = getPathCount();</span><br>     1274-&gt;N:  <span style="background-color: white">      </span><br>  1275-&gt;1275:  <span style="background-color: white">      		if (pathIndex &gt;= pathCount || beforePointIndex &gt; getPathSize(pathIndex))</span><br>  1276-&gt;1276:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>     1277-&gt;N:  <span style="background-color: white">      </span><br>  1278-&gt;1278:  <span style="background-color: white">      		if (pathIndex == getPathCount())// adding a new path.</span><br>     1279-&gt;N:  <span style="background-color: white">      		{</span><br>  1280-&gt;1280:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>     1281-&gt;N:  <span style="background-color: white">      </span><br>     1282-&gt;N:  <span style="background-color: white">      			if (!m_bPolygon)</span><br>  1283-&gt;1283:  <span style="background-color: white">      				m_pathFlags.add((byte) 0);</span><br>     1284-&gt;N:  <span style="background-color: white">      			else</span><br>  1285-&gt;1285:  <span style="background-color: white">      				m_pathFlags.add((byte) PathFlags.enumClosed);</span><br>     1286-&gt;N:  <span style="background-color: white">      		}</span><br>     1287-&gt;N:  <span style="background-color: white">      </span><br>  1288-&gt;1288:  <span style="background-color: white">      		if (beforePointIndex &lt; 0)</span><br>  1289-&gt;1289:  <span style="background-color: white">      			beforePointIndex = getPathSize(pathIndex);</span><br>     1290-&gt;N:  <span style="background-color: white">      </span><br>  1291-&gt;1291:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>  1292-&gt;1292:  <span style="background-color: white">      		_resizeImpl(m_pointCount + 1);</span><br>     1293-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>     1294-&gt;N:  <span style="background-color: white">      </span><br>  1295-&gt;1295:  <span style="background-color: white">      		int pathStart = getPathStart(pathIndex);</span><br>     1296-&gt;N:  <span style="background-color: white">      </span><br>  1297-&gt;1297:  <span style="background-color: white">      		((AttributeStreamOfDbl) (AttributeStreamBase) m_vertexAttributes[0])</span><br>  1298-&gt;1298:  <span style="background-color: white">      				.insert(2 * (pathStart + beforePointIndex), pt,</span><br>  1299-&gt;1299:  <span style="background-color: white">      						2 * oldPointCount);</span><br>     1300-&gt;N:  <span style="background-color: white">      </span><br>  1301-&gt;1301:  <span style="background-color: white">      		for (int iattr = 1, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>  1302-&gt;1302:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>  1303-&gt;1303:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>     1304-&gt;N:  <span style="background-color: white">      </span><br>     1305-&gt;N:  <span style="background-color: white">      			// Need to make room for the attribute, so we copy a default value</span><br>     1306-&gt;N:  <span style="background-color: white">      			// in</span><br>  1307-&gt;1307:  <span style="background-color: white">      			double v = VertexDescription.getDefaultValue(semantics);</span><br>  1308-&gt;1308:  <span style="background-color: white">      			m_vertexAttributes[iattr].insertRange(comp</span><br>  1309-&gt;1309:  <span style="background-color: white">      					* (pathStart + beforePointIndex), v, comp, comp</span><br>  1310-&gt;1310:  <span style="background-color: white">      					* oldPointCount);</span><br>     1311-&gt;N:  <span style="background-color: white">      		}</span><br>     1312-&gt;N:  <span style="background-color: white">      </span><br>  1313-&gt;1313:  <span style="background-color: white">      		for (int ipath = pathIndex + 1, npaths = pathCount; ipath &lt;= npaths; ipath++) {</span><br>  1314-&gt;1314:  <span style="background-color: white">      			m_paths.write(ipath, m_paths.read(ipath) + 1);</span><br>     1315-&gt;N:  <span style="background-color: white">      		}</span><br>     1316-&gt;N:  <span style="background-color: white">      	}</span><br>     1317-&gt;N:  <span style="background-color: white">      </span><br>  1318-&gt;1318:  <span style="background-color: white">      	public void insertPoint(int pathIndex, int beforePointIndex, Point pt) {</span><br>  1319-&gt;1319:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>     1320-&gt;N:  <span style="background-color: white">      </span><br>  1321-&gt;1321:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>  1322-&gt;1322:  <span style="background-color: white">      			pathIndex = getPathCount();</span><br>     1323-&gt;N:  <span style="background-color: white">      </span><br>  1324-&gt;1324:  <span style="background-color: white">      		if (pathIndex &gt;= pathCount || beforePointIndex &gt; getPathSize(pathIndex))</span><br>  1325-&gt;1325:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>     1326-&gt;N:  <span style="background-color: white">      </span><br>  1327-&gt;1327:  <span style="background-color: white">      		if (pathIndex == getPathCount())// adding a new path.</span><br>     1328-&gt;N:  <span style="background-color: white">      		{</span><br>  1329-&gt;1329:  <span style="background-color: white">      			m_paths.add(m_pointCount);</span><br>     1330-&gt;N:  <span style="background-color: white">      </span><br>     1331-&gt;N:  <span style="background-color: white">      			if (!m_bPolygon)</span><br>  1332-&gt;1332:  <span style="background-color: white">      				m_pathFlags.add((byte) 0);</span><br>     1333-&gt;N:  <span style="background-color: white">      			else</span><br>  1334-&gt;1334:  <span style="background-color: white">      				m_pathFlags.add((byte) PathFlags.enumClosed);</span><br>     1335-&gt;N:  <span style="background-color: white">      		}</span><br>     1336-&gt;N:  <span style="background-color: white">      </span><br>  1337-&gt;1337:  <span style="background-color: white">      		if (beforePointIndex &lt; 0)</span><br>  1338-&gt;1338:  <span style="background-color: white">      			beforePointIndex = getPathSize(pathIndex);</span><br>     1339-&gt;N:  <span style="background-color: white">      </span><br>  1340-&gt;1340:  <span style="background-color: white">      		mergeVertexDescription(pt.getDescription());</span><br>  1341-&gt;1341:  <span style="background-color: white">      		int oldPointCount = m_pointCount;</span><br>  1342-&gt;1342:  <span style="background-color: white">      		_resizeImpl(m_pointCount + 1);</span><br>     1343-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>     1344-&gt;N:  <span style="background-color: white">      </span><br>  1345-&gt;1345:  <span style="background-color: white">      		int pathStart = getPathStart(pathIndex);</span><br>     1346-&gt;N:  <span style="background-color: white">      </span><br>  1347-&gt;1347:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>  1348-&gt;1348:  <span style="background-color: white">      			int semantics = m_description._getSemanticsImpl(iattr);</span><br>  1349-&gt;1349:  <span style="background-color: white">      			int comp = VertexDescription.getComponentCount(semantics);</span><br>     1350-&gt;N:  <span style="background-color: white">      </span><br>  1351-&gt;1351:  <span style="background-color: white">      			if (pt.hasAttribute(semantics)) {</span><br>  1352-&gt;1352:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertAttributes(comp</span><br>  1353-&gt;1353:  <span style="background-color: white">      						* (pathStart + beforePointIndex), pt, semantics, comp</span><br>  1354-&gt;1354:  <span style="background-color: white">      						* oldPointCount);</span><br>     1355-&gt;N:  <span style="background-color: white">      			} else {</span><br>     1356-&gt;N:  <span style="background-color: white">      				// Need to make room for the attribute, so we copy a default</span><br>     1357-&gt;N:  <span style="background-color: white">      				// value in</span><br>  1358-&gt;1358:  <span style="background-color: white">      				double v = VertexDescription.getDefaultValue(semantics);</span><br>  1359-&gt;1359:  <span style="background-color: white">      				m_vertexAttributes[iattr].insertRange(comp</span><br>  1360-&gt;1360:  <span style="background-color: white">      						* (pathStart + beforePointIndex), v, comp, comp</span><br>  1361-&gt;1361:  <span style="background-color: white">      						* oldPointCount);</span><br>     1362-&gt;N:  <span style="background-color: white">      			}</span><br>     1363-&gt;N:  <span style="background-color: white">      		}</span><br>     1364-&gt;N:  <span style="background-color: white">      </span><br>  1365-&gt;1365:  <span style="background-color: white">      		for (int ipath = pathIndex + 1, npaths = pathCount; ipath &lt;= npaths; ipath++) {</span><br>  1366-&gt;1366:  <span style="background-color: white">      			m_paths.write(ipath, m_paths.read(ipath) + 1);</span><br>     1367-&gt;N:  <span style="background-color: white">      		}</span><br>     1368-&gt;N:  <span style="background-color: white">      </span><br>  1369-&gt;1369:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>     1370-&gt;N:  <span style="background-color: white">      	}</span><br>     1371-&gt;N:  <span style="background-color: white">      </span><br>  1372-&gt;1372:  <span style="background-color: white">      	public void removePoint(int pathIndex, int pointIndex) {</span><br>  1373-&gt;1373:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>     1374-&gt;N:  <span style="background-color: white">      </span><br>  1375-&gt;1375:  <span style="background-color: white">      		if (pathIndex &lt; 0)</span><br>  1376-&gt;1376:  <span style="background-color: white">      			pathIndex = pathCount - 1;</span><br>     1377-&gt;N:  <span style="background-color: white">      </span><br>  1378-&gt;1378:  <span style="background-color: white">      		if (pathIndex &gt;= pathCount || pointIndex &gt;= getPathSize(pathIndex))</span><br>  1379-&gt;1379:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>     1380-&gt;N:  <span style="background-color: white">      </span><br>     1381-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>     1382-&gt;N:  <span style="background-color: white">      </span><br>  1383-&gt;1383:  <span style="background-color: white">      		int pathStart = getPathStart(pathIndex);</span><br>     1384-&gt;N:  <span style="background-color: white">      </span><br>  1385-&gt;1385:  <span style="background-color: white">      		if (pointIndex &lt; 0)</span><br>  1386-&gt;1386:  <span style="background-color: white">      			pointIndex = getPathSize(pathIndex) - 1;</span><br>     1387-&gt;N:  <span style="background-color: white">      </span><br>  1388-&gt;1388:  <span style="background-color: white">      		int absoluteIndex = pathStart + pointIndex;</span><br>     1389-&gt;N:  <span style="background-color: white">      </span><br>     1390-&gt;N:  <span style="background-color: white">      		// Remove the attribute values for the path</span><br>  1391-&gt;1391:  <span style="background-color: white">      		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</span><br>  1392-&gt;1392:  <span style="background-color: white">      			if (m_vertexAttributes[iattr] != null) {</span><br>  1393-&gt;1393:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(iattr);</span><br>  1394-&gt;1394:  <span style="background-color: white">      				int comp = VertexDescription.getComponentCount(semantics);</span><br>  1395-&gt;1395:  <span style="background-color: white">      				m_vertexAttributes[iattr].eraseRange(comp * absoluteIndex,</span><br>  1396-&gt;1396:  <span style="background-color: white">      						comp, comp * m_pointCount);</span><br>     1397-&gt;N:  <span style="background-color: white">      			}</span><br>     1398-&gt;N:  <span style="background-color: white">      		}</span><br>     1399-&gt;N:  <span style="background-color: white">      </span><br>  1400-&gt;1400:  <span style="background-color: white">      		for (int ipath = pathCount; ipath &gt;= pathIndex + 1; ipath--) {</span><br>  1401-&gt;1401:  <span style="background-color: white">      			int iend = m_paths.read(ipath);</span><br>  1402-&gt;1402:  <span style="background-color: white">      			m_paths.write(ipath, iend - 1);</span><br>     1403-&gt;N:  <span style="background-color: white">      		}</span><br>     1404-&gt;N:  <span style="background-color: white">      </span><br>  1405-&gt;1405:  <span style="background-color: white">      		m_pointCount--;</span><br>  1406-&gt;1406:  <span style="background-color: white">      		m_reservedPointCount--;</span><br>  1407-&gt;1407:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>     1408-&gt;N:  <span style="background-color: white">      	}</span><br>     1409-&gt;N:  <span style="background-color: white">      </span><br>  1410-&gt;1410:  <span style="background-color: white">      	public double calculatePathLength2D(int pathIndex) /* const */</span><br>     1411-&gt;N:  <span style="background-color: white">      	{</span><br>  1412-&gt;1412:  <span style="background-color: white">      		SegmentIteratorImpl segIter = querySegmentIteratorAtVertex(getPathStart(pathIndex));</span><br>     1413-&gt;N:  <span style="background-color: white">      </span><br>  1414-&gt;1414:  <span style="background-color: white">      		MathUtils.KahanSummator len = new MathUtils.KahanSummator(0);</span><br>  1415-&gt;1415:  <span style="background-color: white">      		while (segIter.hasNextSegment()) {</span><br>  1416-&gt;1416:  <span style="background-color: white">      			len.add(segIter.nextSegment().calculateLength2D());</span><br>     1417-&gt;N:  <span style="background-color: white">      		}</span><br>     1418-&gt;N:  <span style="background-color: white">      </span><br>  1419-&gt;1419:  <span style="background-color: white">      		return len.getResult();</span><br>     1420-&gt;N:  <span style="background-color: white">      	}</span><br>     1421-&gt;N:  <span style="background-color: white">      </span><br>  1422-&gt;1422:  <span style="background-color: white">      	double calculateSubLength2D(int from_path_index, int from_point_index,</span><br>  1423-&gt;1423:  <span style="background-color: white">      			int to_path_index, int to_point_index) {</span><br>  1424-&gt;1424:  <span style="background-color: white">      		int absolute_from_index = getPathStart(from_path_index)</span><br>  1425-&gt;1425:  <span style="background-color: white">      				+ from_point_index;</span><br>  1426-&gt;1426:  <span style="background-color: white">      		int absolute_to_index = getPathStart(to_path_index) + to_point_index;</span><br>     1427-&gt;N:  <span style="background-color: white">      </span><br>  1428-&gt;1428:  <span style="background-color: white">      		if (absolute_to_index &lt; absolute_from_index || absolute_from_index &lt; 0</span><br>  1429-&gt;1429:  <span style="background-color: white">      				|| absolute_to_index &gt; getPointCount() - 1)</span><br>  1430-&gt;1430:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>     1431-&gt;N:  <span style="background-color: white">      </span><br>  1432-&gt;1432:  <span style="background-color: white">      		SegmentIteratorImpl seg_iter = querySegmentIterator();</span><br>     1433-&gt;N:  <span style="background-color: white">      </span><br>  1434-&gt;1434:  <span style="background-color: white">      		double sub_length = 0.0;</span><br>     1435-&gt;N:  <span style="background-color: white">      </span><br>  1436-&gt;1436:  <span style="background-color: white">      		seg_iter.resetToVertex(absolute_from_index);</span><br>     1437-&gt;N:  <span style="background-color: white">      </span><br>     1438-&gt;N:  <span style="background-color: white">      		do {</span><br>  1439-&gt;1439:  <span style="background-color: white">      			while (seg_iter.hasNextSegment()) {</span><br>  1440-&gt;1440:  <span style="background-color: white">      				Segment segment = seg_iter.nextSegment();</span><br>     1441-&gt;N:  <span style="background-color: white">      </span><br>  1442-&gt;1442:  <span style="background-color: white">      				if (seg_iter.getStartPointIndex() == absolute_to_index)</span><br>  1443-&gt;1443:  <span style="background-color: white">      					break;</span><br>     1444-&gt;N:  <span style="background-color: white">      </span><br>  1445-&gt;1445:  <span style="background-color: white">      				double segment_length = segment.calculateLength2D();</span><br>  1446-&gt;1446:  <span style="background-color: white">      				sub_length += segment_length;</span><br>     1447-&gt;N:  <span style="background-color: white">      			}</span><br>     1448-&gt;N:  <span style="background-color: white">      </span><br>  1449-&gt;1449:  <span style="background-color: white">      			if (seg_iter.getStartPointIndex() == absolute_to_index)</span><br>  1450-&gt;1450:  <span style="background-color: white">      				break;</span><br>     1451-&gt;N:  <span style="background-color: white">      </span><br>  1452-&gt;1452:  <span style="background-color: white">      		} while (seg_iter.nextPath());</span><br>     1453-&gt;N:  <span style="background-color: white">      </span><br>  1454-&gt;1454:  <span style="background-color: white">      		return sub_length;</span><br>     1455-&gt;N:  <span style="background-color: white">      	}</span><br>     1456-&gt;N:  <span style="background-color: white">      </span><br>  1457-&gt;1457:  <span style="background-color: white">      	double calculateSubLength2D(int path_index, int from_point_index,</span><br>  1458-&gt;1458:  <span style="background-color: white">      			int to_point_index) {</span><br>  1459-&gt;1459:  <span style="background-color: white">      		int absolute_from_index = getPathStart(path_index) + from_point_index;</span><br>  1460-&gt;1460:  <span style="background-color: white">      		int absolute_to_index = getPathStart(path_index) + to_point_index;</span><br>     1461-&gt;N:  <span style="background-color: white">      </span><br>  1462-&gt;1462:  <span style="background-color: white">      		if (absolute_from_index &lt; 0 || absolute_to_index &gt; getPointCount() - 1)</span><br>  1463-&gt;1463:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>     1464-&gt;N:  <span style="background-color: white">      </span><br>  1465-&gt;1465:  <span style="background-color: white">      		SegmentIteratorImpl seg_iter = querySegmentIterator();</span><br>     1466-&gt;N:  <span style="background-color: white">      </span><br>  1467-&gt;1467:  <span style="background-color: white">      		if (absolute_from_index &gt; absolute_to_index) {</span><br>  1468-&gt;1468:  <span style="background-color: white">      			if (!isClosedPath(path_index))</span><br>     1469-&gt;N:  <span style="background-color: white">      				throw new IllegalArgumentException(</span><br>  1470-&gt;1470:  <span style="background-color: white">      						"cannot iterate across an open path");</span><br>     1471-&gt;N:  <span style="background-color: white">      </span><br>  1472-&gt;1472:  <span style="background-color: white">      			seg_iter.setCirculator(true);</span><br>     1473-&gt;N:  <span style="background-color: white">      		}</span><br>     1474-&gt;N:  <span style="background-color: white">      </span><br>  1475-&gt;1475:  <span style="background-color: white">      		double prev_length = 0.0;</span><br>  1476-&gt;1476:  <span style="background-color: white">      		double sub_length = 0.0;</span><br>     1477-&gt;N:  <span style="background-color: white">      </span><br>  1478-&gt;1478:  <span style="background-color: white">      		seg_iter.resetToVertex(absolute_from_index);</span><br>     1479-&gt;N:  <span style="background-color: white">      </span><br>     1480-&gt;N:  <span style="background-color: white">      		do {</span><br>  1481-&gt;1481:  <span style="background-color: white">      			assert (seg_iter.hasNextSegment());</span><br>  1482-&gt;1482:  <span style="background-color: white">      			sub_length += prev_length;</span><br>  1483-&gt;1483:  <span style="background-color: white">      			Segment segment = seg_iter.nextSegment();</span><br>  1484-&gt;1484:  <span style="background-color: white">      			prev_length = segment.calculateLength2D();</span><br>     1485-&gt;N:  <span style="background-color: white">      </span><br>  1486-&gt;1486:  <span style="background-color: white">      		} while (seg_iter.getStartPointIndex() != absolute_to_index);</span><br>     1487-&gt;N:  <span style="background-color: white">      </span><br>  1488-&gt;1488:  <span style="background-color: white">      		return sub_length;</span><br>     1489-&gt;N:  <span style="background-color: white">      	}</span><br>     1490-&gt;N:  <span style="background-color: white">      </span><br>  1491-&gt;1491:  <span style="background-color: white">      	@Override</span><br>  1492-&gt;1492:  <span style="background-color: white">      	public Geometry getBoundary() {</span><br>  1493-&gt;1493:  <span style="background-color: white">      		return Boundary.calculate(this, null);</span><br>     1494-&gt;N:  <span style="background-color: white">      	}</span><br>     1495-&gt;N:  <span style="background-color: white">      </span><br>     1496-&gt;N:  <span style="background-color: white">      	// TODO: Add code fore interpolation type (none and angular)</span><br>  1497-&gt;1497:  <span style="background-color: white">      	void interpolateAttributes(int from_path_index, int from_point_index,</span><br>  1498-&gt;1498:  <span style="background-color: white">      			int to_path_index, int to_point_index) {</span><br>  1499-&gt;1499:  <span style="background-color: white">      		for (int ipath = from_path_index; ipath &lt; to_path_index - 1; ipath++) {</span><br>  1500-&gt;1500:  <span style="background-color: white">      			if (isClosedPath(ipath))</span><br>     1501-&gt;N:  <span style="background-color: white">      				throw new IllegalArgumentException(</span><br>  1502-&gt;1502:  <span style="background-color: white">      						"cannot interpolate across closed paths");</span><br>     1503-&gt;N:  <span style="background-color: white">      		}</span><br>     1504-&gt;N:  <span style="background-color: white">      </span><br>  1505-&gt;1505:  <span style="background-color: white">      		int nattr = m_description.getAttributeCount();</span><br>     1506-&gt;N:  <span style="background-color: white">      </span><br>  1507-&gt;1507:  <span style="background-color: white">      		if (nattr == 1)</span><br>  1508-&gt;1508:  <span style="background-color: white">      			return; // only has position</span><br>     1509-&gt;N:  <span style="background-color: white">      </span><br>  1510-&gt;1510:  <span style="background-color: white">      		double sub_length = calculateSubLength2D(from_path_index,</span><br>  1511-&gt;1511:  <span style="background-color: white">      				from_point_index, to_path_index, to_point_index);</span><br>     1512-&gt;N:  <span style="background-color: white">      </span><br>  1513-&gt;1513:  <span style="background-color: white">      		if (sub_length == 0.0)</span><br>  1514-&gt;1514:  <span style="background-color: white">      			return;</span><br>     1515-&gt;N:  <span style="background-color: white">      </span><br>  1516-&gt;1516:  <span style="background-color: white">      		for (int iattr = 1; iattr &lt; nattr; iattr++) {</span><br>  1517-&gt;1517:  <span style="background-color: white">      			int semantics = m_description.getSemantics(iattr);</span><br>     1518-&gt;N:  <span style="background-color: white">      </span><br>  1519-&gt;1519:  <span style="background-color: white">      			int interpolation = VertexDescription.getInterpolation(semantics);</span><br>  1520-&gt;1520:  <span style="background-color: white">      			if (interpolation == VertexDescription.Interpolation.ANGULAR)</span><br>  1521-&gt;1521:  <span style="background-color: white">      				continue;</span><br>     1522-&gt;N:  <span style="background-color: white">      </span><br>  1523-&gt;1523:  <span style="background-color: white">      			int components = VertexDescription.getComponentCount(semantics);</span><br>     1524-&gt;N:  <span style="background-color: white">      </span><br>  1525-&gt;1525:  <span style="background-color: white">      			for (int ordinate = 0; ordinate &lt; components; ordinate++)</span><br>  1526-&gt;1526:  <span style="background-color: white">      				interpolateAttributes_(semantics, from_path_index,</span><br>  1527-&gt;1527:  <span style="background-color: white">      						from_point_index, to_path_index, to_point_index,</span><br>  1528-&gt;1528:  <span style="background-color: white">      						sub_length, ordinate);</span><br>     1529-&gt;N:  <span style="background-color: white">      		}</span><br>     1530-&gt;N:  <span style="background-color: white">      	}</span><br>     1531-&gt;N:  <span style="background-color: white">      </span><br>     1532-&gt;N:  <span style="background-color: white">      	// TODO: Add code for interpolation type (none and angular)</span><br>  1533-&gt;1533:  <span style="background-color: white">      	void interpolateAttributesForSemantics(int semantics, int from_path_index,</span><br>  1534-&gt;1534:  <span style="background-color: white">      			int from_point_index, int to_path_index, int to_point_index) {</span><br>  1535-&gt;1535:  <span style="background-color: white">      		if (semantics == VertexDescription.Semantics.POSITION)</span><br>  1536-&gt;1536:  <span style="background-color: white">      			return;</span><br>     1537-&gt;N:  <span style="background-color: white">      </span><br>  1538-&gt;1538:  <span style="background-color: white">      		if (!hasAttribute(semantics))</span><br>     1539-&gt;N:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>  1540-&gt;1540:  <span style="background-color: white">      					"does not have the given attribute");</span><br>     1541-&gt;N:  <span style="background-color: white">      </span><br>  1542-&gt;1542:  <span style="background-color: white">      		int interpolation = VertexDescription.getInterpolation(semantics);</span><br>  1543-&gt;1543:  <span style="background-color: white">      		if (interpolation == VertexDescription.Interpolation.ANGULAR)</span><br>     1544-&gt;N:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>  1545-&gt;1545:  <span style="background-color: white">      					"not implemented for the given semantics");</span><br>     1546-&gt;N:  <span style="background-color: white">      </span><br>  1547-&gt;1547:  <span style="background-color: white">      		for (int ipath = from_path_index; ipath &lt; to_path_index - 1; ipath++) {</span><br>  1548-&gt;1548:  <span style="background-color: white">      			if (isClosedPath(ipath))</span><br>     1549-&gt;N:  <span style="background-color: white">      				throw new IllegalArgumentException(</span><br>  1550-&gt;1550:  <span style="background-color: white">      						"cannot interpolate across closed paths");</span><br>     1551-&gt;N:  <span style="background-color: white">      		}</span><br>     1552-&gt;N:  <span style="background-color: white">      </span><br>  1553-&gt;1553:  <span style="background-color: white">      		double sub_length = calculateSubLength2D(from_path_index,</span><br>  1554-&gt;1554:  <span style="background-color: white">      				from_point_index, to_path_index, to_point_index);</span><br>     1555-&gt;N:  <span style="background-color: white">      </span><br>  1556-&gt;1556:  <span style="background-color: white">      		if (sub_length == 0.0)</span><br>  1557-&gt;1557:  <span style="background-color: white">      			return;</span><br>     1558-&gt;N:  <span style="background-color: white">      </span><br>  1559-&gt;1559:  <span style="background-color: white">      		int components = VertexDescription.getComponentCount(semantics);</span><br>     1560-&gt;N:  <span style="background-color: white">      </span><br>  1561-&gt;1561:  <span style="background-color: white">      		for (int ordinate = 0; ordinate &lt; components; ordinate++)</span><br>  1562-&gt;1562:  <span style="background-color: white">      			interpolateAttributes_(semantics, from_path_index,</span><br>  1563-&gt;1563:  <span style="background-color: white">      					from_point_index, to_path_index, to_point_index,</span><br>  1564-&gt;1564:  <span style="background-color: white">      					sub_length, ordinate);</span><br>     1565-&gt;N:  <span style="background-color: white">      	}</span><br>     1566-&gt;N:  <span style="background-color: white">      </span><br>  1567-&gt;1567:  <span style="background-color: white">      	void interpolateAttributes(int path_index, int from_point_index,</span><br>  1568-&gt;1568:  <span style="background-color: white">      			int to_point_index) {</span><br>  1569-&gt;1569:  <span style="background-color: white">      		int nattr = m_description.getAttributeCount();</span><br>     1570-&gt;N:  <span style="background-color: white">      </span><br>  1571-&gt;1571:  <span style="background-color: white">      		if (nattr == 1)</span><br>  1572-&gt;1572:  <span style="background-color: white">      			return; // only has position</span><br>     1573-&gt;N:  <span style="background-color: white">      </span><br>  1574-&gt;1574:  <span style="background-color: white">      		double sub_length = calculateSubLength2D(path_index, from_point_index,</span><br>  1575-&gt;1575:  <span style="background-color: white">      				to_point_index);</span><br>     1576-&gt;N:  <span style="background-color: white">      </span><br>  1577-&gt;1577:  <span style="background-color: white">      		if (sub_length == 0.0)</span><br>  1578-&gt;1578:  <span style="background-color: white">      			return;</span><br>     1579-&gt;N:  <span style="background-color: white">      </span><br>  1580-&gt;1580:  <span style="background-color: white">      		for (int iattr = 1; iattr &lt; nattr; iattr++) {</span><br>  1581-&gt;1581:  <span style="background-color: white">      			int semantics = m_description.getSemantics(iattr);</span><br>     1582-&gt;N:  <span style="background-color: white">      </span><br>  1583-&gt;1583:  <span style="background-color: white">      			int interpolation = VertexDescription.getInterpolation(semantics);</span><br>  1584-&gt;1584:  <span style="background-color: white">      			if (interpolation == VertexDescription.Interpolation.ANGULAR)</span><br>  1585-&gt;1585:  <span style="background-color: white">      				continue;</span><br>     1586-&gt;N:  <span style="background-color: white">      </span><br>  1587-&gt;1587:  <span style="background-color: white">      			int components = VertexDescription.getComponentCount(semantics);</span><br>     1588-&gt;N:  <span style="background-color: white">      </span><br>  1589-&gt;1589:  <span style="background-color: white">      			for (int ordinate = 0; ordinate &lt; components; ordinate++)</span><br>  1590-&gt;1590:  <span style="background-color: white">      				interpolateAttributes_(semantics, path_index, from_point_index,</span><br>  1591-&gt;1591:  <span style="background-color: white">      						to_point_index, sub_length, ordinate);</span><br>     1592-&gt;N:  <span style="background-color: white">      		}</span><br>     1593-&gt;N:  <span style="background-color: white">      	}</span><br>     1594-&gt;N:  <span style="background-color: white">      </span><br>  1595-&gt;1595:  <span style="background-color: white">      	void interpolateAttributesForSemantics(int semantics, int path_index,</span><br>  1596-&gt;1596:  <span style="background-color: white">      			int from_point_index, int to_point_index) {</span><br>  1597-&gt;1597:  <span style="background-color: white">      		if (semantics == VertexDescription.Semantics.POSITION)</span><br>  1598-&gt;1598:  <span style="background-color: white">      			return;</span><br>     1599-&gt;N:  <span style="background-color: white">      </span><br>  1600-&gt;1600:  <span style="background-color: white">      		if (!hasAttribute(semantics))</span><br>     1601-&gt;N:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>  1602-&gt;1602:  <span style="background-color: white">      					"does not have the given attribute");</span><br>     1603-&gt;N:  <span style="background-color: white">      </span><br>  1604-&gt;1604:  <span style="background-color: white">      		int interpolation = VertexDescription.getInterpolation(semantics);</span><br>  1605-&gt;1605:  <span style="background-color: white">      		if (interpolation == VertexDescription.Interpolation.ANGULAR)</span><br>     1606-&gt;N:  <span style="background-color: white">      			throw new IllegalArgumentException(</span><br>  1607-&gt;1607:  <span style="background-color: white">      					"not implemented for the given semantics");</span><br>     1608-&gt;N:  <span style="background-color: white">      </span><br>  1609-&gt;1609:  <span style="background-color: white">      		double sub_length = calculateSubLength2D(path_index, from_point_index,</span><br>  1610-&gt;1610:  <span style="background-color: white">      				to_point_index);</span><br>     1611-&gt;N:  <span style="background-color: white">      </span><br>  1612-&gt;1612:  <span style="background-color: white">      		if (sub_length == 0.0)</span><br>  1613-&gt;1613:  <span style="background-color: white">      			return;</span><br>     1614-&gt;N:  <span style="background-color: white">      </span><br>  1615-&gt;1615:  <span style="background-color: white">      		int components = VertexDescription.getComponentCount(semantics);</span><br>     1616-&gt;N:  <span style="background-color: white">      </span><br>  1617-&gt;1617:  <span style="background-color: white">      		for (int ordinate = 0; ordinate &lt; components; ordinate++)</span><br>  1618-&gt;1618:  <span style="background-color: white">      			interpolateAttributes_(semantics, path_index, from_point_index,</span><br>  1619-&gt;1619:  <span style="background-color: white">      					to_point_index, sub_length, ordinate);</span><br>     1620-&gt;N:  <span style="background-color: white">      	}</span><br>     1621-&gt;N:  <span style="background-color: white">      </span><br>     1622-&gt;N:  <span style="background-color: white">      	// TODO: Add code fore interpolation type (none and angular)</span><br>  1623-&gt;1623:  <span style="background-color: white">      	void interpolateAttributes_(int semantics, int from_path_index,</span><br>  1624-&gt;1624:  <span style="background-color: white">      			int from_point_index, int to_path_index, int to_point_index,</span><br>  1625-&gt;1625:  <span style="background-color: white">      			double sub_length, int ordinate) {</span><br>  1626-&gt;1626:  <span style="background-color: white">      		SegmentIteratorImpl seg_iter = querySegmentIterator();</span><br>     1627-&gt;N:  <span style="background-color: white">      </span><br>  1628-&gt;1628:  <span style="background-color: white">      		int absolute_from_index = getPathStart(from_path_index)</span><br>  1629-&gt;1629:  <span style="background-color: white">      				+ from_point_index;</span><br>  1630-&gt;1630:  <span style="background-color: white">      		int absolute_to_index = getPathStart(to_path_index) + to_point_index;</span><br>     1631-&gt;N:  <span style="background-color: white">      </span><br>  1632-&gt;1632:  <span style="background-color: white">      		double from_attribute = getAttributeAsDbl(semantics,</span><br>  1633-&gt;1633:  <span style="background-color: white">      				absolute_from_index, ordinate);</span><br>  1634-&gt;1634:  <span style="background-color: white">      		double to_attribute = getAttributeAsDbl(semantics, absolute_to_index,</span><br>  1635-&gt;1635:  <span style="background-color: white">      				ordinate);</span><br>  1636-&gt;1636:  <span style="background-color: white">      		double interpolated_attribute = from_attribute;</span><br>  1637-&gt;1637:  <span style="background-color: white">      		double cumulative_length = 0.0;</span><br>     1638-&gt;N:  <span style="background-color: white">      </span><br>  1639-&gt;1639:  <span style="background-color: white">      		seg_iter.resetToVertex(absolute_from_index);</span><br>     1640-&gt;N:  <span style="background-color: white">      </span><br>     1641-&gt;N:  <span style="background-color: white">      		do {</span><br>  1642-&gt;1642:  <span style="background-color: white">      			if (seg_iter.hasNextSegment()) {</span><br>  1643-&gt;1643:  <span style="background-color: white">      				seg_iter.nextSegment();</span><br>     1644-&gt;N:  <span style="background-color: white">      </span><br>  1645-&gt;1645:  <span style="background-color: white">      				if (seg_iter.getStartPointIndex() == absolute_to_index)</span><br>  1646-&gt;1646:  <span style="background-color: white">      					return;</span><br>     1647-&gt;N:  <span style="background-color: white">      </span><br>  1648-&gt;1648:  <span style="background-color: white">      				setAttribute(semantics, seg_iter.getStartPointIndex(),</span><br>  1649-&gt;1649:  <span style="background-color: white">      						ordinate, interpolated_attribute);</span><br>     1650-&gt;N:  <span style="background-color: white">      </span><br>  1651-&gt;1651:  <span style="background-color: white">      				seg_iter.previousSegment();</span><br>     1652-&gt;N:  <span style="background-color: white">      </span><br>     1653-&gt;N:  <span style="background-color: white">      				do {</span><br>  1654-&gt;1654:  <span style="background-color: white">      					Segment segment = seg_iter.nextSegment();</span><br>     1655-&gt;N:  <span style="background-color: white">      </span><br>  1656-&gt;1656:  <span style="background-color: white">      					if (seg_iter.getEndPointIndex() == absolute_to_index)</span><br>  1657-&gt;1657:  <span style="background-color: white">      						return;</span><br>     1658-&gt;N:  <span style="background-color: white">      </span><br>  1659-&gt;1659:  <span style="background-color: white">      					double segment_length = segment.calculateLength2D();</span><br>  1660-&gt;1660:  <span style="background-color: white">      					cumulative_length += segment_length;</span><br>  1661-&gt;1661:  <span style="background-color: white">      					double t = cumulative_length / sub_length;</span><br>  1662-&gt;1662:  <span style="background-color: white">      					interpolated_attribute = MathUtils.lerp(from_attribute,  to_attribute, t);</span><br>     1663-&gt;N:  <span style="background-color: white">      </span><br>  1664-&gt;1664:  <span style="background-color: white">      					if (!seg_iter.isClosingSegment())</span><br>  1665-&gt;1665:  <span style="background-color: white">      						setAttribute(semantics, seg_iter.getEndPointIndex(),</span><br>  1666-&gt;1666:  <span style="background-color: white">      								ordinate, interpolated_attribute);</span><br>     1667-&gt;N:  <span style="background-color: white">      </span><br>  1668-&gt;1668:  <span style="background-color: white">      				} while (seg_iter.hasNextSegment());</span><br>     1669-&gt;N:  <span style="background-color: white">      			}</span><br>     1670-&gt;N:  <span style="background-color: white">      </span><br>  1671-&gt;1671:  <span style="background-color: white">      		} while (seg_iter.nextPath());</span><br>     1672-&gt;N:  <span style="background-color: white">      	}</span><br>     1673-&gt;N:  <span style="background-color: white">      </span><br>  1674-&gt;1674:  <span style="background-color: white">      	void interpolateAttributes_(int semantics, int path_index,</span><br>  1675-&gt;1675:  <span style="background-color: white">      			int from_point_index, int to_point_index, double sub_length,</span><br>  1676-&gt;1676:  <span style="background-color: white">      			int ordinate) {</span><br>     1677-&gt;N:  <span style="background-color: white">      		assert (m_bPolygon);</span><br>  1678-&gt;1678:  <span style="background-color: white">      		SegmentIteratorImpl seg_iter = querySegmentIterator();</span><br>     1679-&gt;N:  <span style="background-color: white">      </span><br>  1680-&gt;1680:  <span style="background-color: white">      		int absolute_from_index = getPathStart(path_index) + from_point_index;</span><br>  1681-&gt;1681:  <span style="background-color: white">      		int absolute_to_index = getPathStart(path_index) + to_point_index;</span><br>     1682-&gt;N:  <span style="background-color: white">      </span><br>  1683-&gt;1683:  <span style="background-color: white">      		if (absolute_to_index == absolute_from_index)</span><br>  1684-&gt;1684:  <span style="background-color: white">      			return;</span><br>     1685-&gt;N:  <span style="background-color: white">      </span><br>  1686-&gt;1686:  <span style="background-color: white">      		double from_attribute = getAttributeAsDbl(semantics,</span><br>  1687-&gt;1687:  <span style="background-color: white">      				absolute_from_index, ordinate);</span><br>  1688-&gt;1688:  <span style="background-color: white">      		double to_attribute = getAttributeAsDbl(semantics, absolute_to_index,</span><br>  1689-&gt;1689:  <span style="background-color: white">      				ordinate);</span><br>  1690-&gt;1690:  <span style="background-color: white">      		double cumulative_length = 0.0;</span><br>     1691-&gt;N:  <span style="background-color: white">      </span><br>  1692-&gt;1692:  <span style="background-color: white">      		seg_iter.resetToVertex(absolute_from_index);</span><br>  1693-&gt;1693:  <span style="background-color: white">      		seg_iter.setCirculator(true);</span><br>     1694-&gt;N:  <span style="background-color: white">      </span><br>  1695-&gt;1695:  <span style="background-color: white">      		double prev_interpolated_attribute = from_attribute;</span><br>     1696-&gt;N:  <span style="background-color: white">      </span><br>     1697-&gt;N:  <span style="background-color: white">      		do {</span><br>  1698-&gt;1698:  <span style="background-color: white">      			Segment segment = seg_iter.nextSegment();</span><br>  1699-&gt;1699:  <span style="background-color: white">      			setAttribute(semantics, seg_iter.getStartPointIndex(), ordinate,</span><br>  1700-&gt;1700:  <span style="background-color: white">      					prev_interpolated_attribute);</span><br>     1701-&gt;N:  <span style="background-color: white">      </span><br>  1702-&gt;1702:  <span style="background-color: white">      			double segment_length = segment.calculateLength2D();</span><br>  1703-&gt;1703:  <span style="background-color: white">      			cumulative_length += segment_length;</span><br>  1704-&gt;1704:  <span style="background-color: white">      			double t = cumulative_length / sub_length;</span><br>  1705-&gt;1705:  <span style="background-color: white">      			prev_interpolated_attribute = MathUtils.lerp(from_attribute, to_attribute, t);</span><br>     1706-&gt;N:  <span style="background-color: white">      </span><br>  1707-&gt;1707:  <span style="background-color: white">      		} while (seg_iter.getEndPointIndex() != absolute_to_index);</span><br>     1708-&gt;N:  <span style="background-color: white">      	}</span><br>     1709-&gt;N:  <span style="background-color: white">      </span><br>  1710-&gt;1710:  <span style="background-color: white">      	@Override</span><br>  1711-&gt;1711:  <span style="background-color: white">      	public void setEmpty() {</span><br>  1712-&gt;1712:  <span style="background-color: white">      		m_curveParamwritePoint = 0;</span><br>  1713-&gt;1713:  <span style="background-color: white">      		m_bPathStarted = false;</span><br>  1714-&gt;1714:  <span style="background-color: white">      		m_paths = null;</span><br>  1715-&gt;1715:  <span style="background-color: white">      		m_pathFlags = null;</span><br>  1716-&gt;1716:  <span style="background-color: white">      		m_segmentParamIndex = null;</span><br>  1717-&gt;1717:  <span style="background-color: white">      		m_segmentFlags = null;</span><br>  1718-&gt;1718:  <span style="background-color: white">      		m_segmentParams = null;</span><br>     1719-&gt;N:  <span style="background-color: white">      		_setEmptyImpl();</span><br>     1720-&gt;N:  <span style="background-color: white">      	}</span><br>     1721-&gt;N:  <span style="background-color: white">      </span><br>  1722-&gt;1722:  <span style="background-color: white">      	@Override</span><br>  1723-&gt;1723:  <span style="background-color: white">      	public void applyTransformation(Transformation2D transform) {</span><br>  1724-&gt;1724:  <span style="background-color: white">      		applyTransformation(transform, -1);</span><br>     1725-&gt;N:  <span style="background-color: white">      	}</span><br>     1726-&gt;N:  <span style="background-color: white">      </span><br>  1727-&gt;1727:  <span style="background-color: white">      	public void applyTransformation(Transformation2D transform, int pathIndex) {</span><br>     1728-&gt;N:  <span style="background-color: white">      		if (isEmpty())</span><br>  1729-&gt;1729:  <span style="background-color: white">      			return;</span><br>     1730-&gt;N:  <span style="background-color: white">      </span><br>  1731-&gt;1731:  <span style="background-color: white">      		if (transform.isIdentity())</span><br>  1732-&gt;1732:  <span style="background-color: white">      			return;</span><br>     1733-&gt;N:  <span style="background-color: white">      </span><br>     1734-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>  1735-&gt;1735:  <span style="background-color: white">      		AttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];</span><br>  1736-&gt;1736:  <span style="background-color: white">      		Point2D ptStart = new Point2D();</span><br>  1737-&gt;1737:  <span style="background-color: white">      		Point2D ptControl = new Point2D();</span><br>     1738-&gt;N:  <span style="background-color: white">      </span><br>  1739-&gt;1739:  <span style="background-color: white">      		boolean bHasNonLinear;</span><br>  1740-&gt;1740:  <span style="background-color: white">      		int fistIdx;</span><br>  1741-&gt;1741:  <span style="background-color: white">      		int lastIdx;</span><br>  1742-&gt;1742:  <span style="background-color: white">      		if (pathIndex &lt; 0) {</span><br>  1743-&gt;1743:  <span style="background-color: white">      			bHasNonLinear = hasNonLinearSegments();</span><br>  1744-&gt;1744:  <span style="background-color: white">      			fistIdx = 0;</span><br>  1745-&gt;1745:  <span style="background-color: white">      			lastIdx = m_pointCount;</span><br>     1746-&gt;N:  <span style="background-color: white">      		} else {</span><br>  1747-&gt;1747:  <span style="background-color: white">      			bHasNonLinear = hasNonLinearSegments(pathIndex);</span><br>  1748-&gt;1748:  <span style="background-color: white">      			fistIdx = getPathStart(pathIndex);</span><br>  1749-&gt;1749:  <span style="background-color: white">      			lastIdx = getPathEnd(pathIndex);</span><br>     1750-&gt;N:  <span style="background-color: white">      		}</span><br>     1751-&gt;N:  <span style="background-color: white">      </span><br>  1752-&gt;1752:  <span style="background-color: white">      		for (int ipoint = fistIdx; ipoint &lt; lastIdx; ipoint++) {</span><br>  1753-&gt;1753:  <span style="background-color: white">      			ptStart.x = points.read(ipoint * 2);</span><br>  1754-&gt;1754:  <span style="background-color: white">      			ptStart.y = points.read(ipoint * 2 + 1);</span><br>     1755-&gt;N:  <span style="background-color: white">      </span><br>  1756-&gt;1756:  <span style="background-color: white">      			if (bHasNonLinear) {</span><br>  1757-&gt;1757:  <span style="background-color: white">      				int segIndex = m_segmentParamIndex.read(ipoint);</span><br>  1758-&gt;1758:  <span style="background-color: white">      				if (segIndex &gt;= 0) {</span><br>  1759-&gt;1759:  <span style="background-color: white">      					int segmentType = (int) m_segmentFlags.read(ipoint);</span><br>  1760-&gt;1760:  <span style="background-color: white">      					int type = segmentType &amp; SegmentFlags.enumSegmentMask;</span><br>  1761-&gt;1761:  <span style="background-color: white">      					switch (type) {</span><br>     1762-&gt;N:  <span style="background-color: white">      					case SegmentFlags.enumBezierSeg: {</span><br>  1763-&gt;1763:  <span style="background-color: white">      						ptControl.x = m_segmentParams.read(segIndex);</span><br>  1764-&gt;1764:  <span style="background-color: white">      						ptControl.y = m_segmentParams.read(segIndex + 1);</span><br>  1765-&gt;1765:  <span style="background-color: white">      						transform.transform(ptControl, ptControl);</span><br>  1766-&gt;1766:  <span style="background-color: white">      						m_segmentParams.write(segIndex, ptControl.x);</span><br>  1767-&gt;1767:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 1, ptControl.y);</span><br>     1768-&gt;N:  <span style="background-color: white">      </span><br>  1769-&gt;1769:  <span style="background-color: white">      						ptControl.x = m_segmentParams.read(segIndex + 3);</span><br>  1770-&gt;1770:  <span style="background-color: white">      						ptControl.y = m_segmentParams.read(segIndex + 4);</span><br>  1771-&gt;1771:  <span style="background-color: white">      						transform.transform(ptControl, ptControl);</span><br>  1772-&gt;1772:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 3, ptControl.x);</span><br>  1773-&gt;1773:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 4, ptControl.y);</span><br>     1774-&gt;N:  <span style="background-color: white">      					}</span><br>  1775-&gt;1775:  <span style="background-color: white">      						break;</span><br>     1776-&gt;N:  <span style="background-color: white">      					case SegmentFlags.enumArcSeg:</span><br>  1777-&gt;1777:  <span style="background-color: white">      						throw GeometryException.GeometryInternalError();</span><br>     1778-&gt;N:  <span style="background-color: white">      </span><br>     1779-&gt;N:  <span style="background-color: white">      					}</span><br>     1780-&gt;N:  <span style="background-color: white">      				}</span><br>     1781-&gt;N:  <span style="background-color: white">      			}</span><br>     1782-&gt;N:  <span style="background-color: white">      </span><br>  1783-&gt;1783:  <span style="background-color: white">      			transform.transform(ptStart, ptStart);</span><br>  1784-&gt;1784:  <span style="background-color: white">      			points.write(ipoint * 2, ptStart.x);</span><br>  1785-&gt;1785:  <span style="background-color: white">      			points.write(ipoint * 2 + 1, ptStart.y);</span><br>     1786-&gt;N:  <span style="background-color: white">      		}</span><br>     1787-&gt;N:  <span style="background-color: white">      </span><br>  1788-&gt;1788:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>     1789-&gt;N:  <span style="background-color: white">      		// REFACTOR: reset the exact envelope only and transform the loose</span><br>     1790-&gt;N:  <span style="background-color: white">      		// envelope</span><br>     1791-&gt;N:  <span style="background-color: white">      	}</span><br>     1792-&gt;N:  <span style="background-color: white">      </span><br>  1793-&gt;1793:  <span style="background-color: white">      	@Override</span><br>  1794-&gt;1794:  <span style="background-color: white">      	public void applyTransformation(Transformation3D transform) {</span><br>     1795-&gt;N:  <span style="background-color: white">      		if (isEmpty())</span><br>  1796-&gt;1796:  <span style="background-color: white">      			return;</span><br>     1797-&gt;N:  <span style="background-color: white">      </span><br>  1798-&gt;1798:  <span style="background-color: white">      		addAttribute(VertexDescription.Semantics.Z);</span><br>     1799-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>  1800-&gt;1800:  <span style="background-color: white">      		AttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];</span><br>  1801-&gt;1801:  <span style="background-color: white">      		AttributeStreamOfDbl zs = (AttributeStreamOfDbl) m_vertexAttributes[1];</span><br>  1802-&gt;1802:  <span style="background-color: white">      		Point3D ptStart = new Point3D();</span><br>  1803-&gt;1803:  <span style="background-color: white">      		Point3D ptControl = new Point3D();</span><br>  1804-&gt;1804:  <span style="background-color: white">      		boolean bHasNonLinear = hasNonLinearSegments();</span><br>  1805-&gt;1805:  <span style="background-color: white">      		for (int ipoint = 0; ipoint &lt; m_pointCount; ipoint++) {</span><br>  1806-&gt;1806:  <span style="background-color: white">      			ptStart.x = points.read(ipoint * 2);</span><br>  1807-&gt;1807:  <span style="background-color: white">      			ptStart.y = points.read(ipoint * 2 + 1);</span><br>  1808-&gt;1808:  <span style="background-color: white">      			ptStart.z = zs.read(ipoint);</span><br>     1809-&gt;N:  <span style="background-color: white">      </span><br>  1810-&gt;1810:  <span style="background-color: white">      			if (bHasNonLinear) {</span><br>  1811-&gt;1811:  <span style="background-color: white">      				int segIndex = m_segmentParamIndex.read(ipoint);</span><br>  1812-&gt;1812:  <span style="background-color: white">      				if (segIndex &gt;= 0) {</span><br>  1813-&gt;1813:  <span style="background-color: white">      					int segmentType = (int) m_segmentFlags.read(ipoint);</span><br>  1814-&gt;1814:  <span style="background-color: white">      					int type = segmentType &amp; (int) SegmentFlags.enumSegmentMask;</span><br>  1815-&gt;1815:  <span style="background-color: white">      					switch (type) {</span><br>     1816-&gt;N:  <span style="background-color: white">      					case SegmentFlags.enumBezierSeg: {</span><br>  1817-&gt;1817:  <span style="background-color: white">      						ptControl.x = m_segmentParams.read(segIndex);</span><br>  1818-&gt;1818:  <span style="background-color: white">      						ptControl.y = m_segmentParams.read(segIndex + 1);</span><br>  1819-&gt;1819:  <span style="background-color: white">      						ptControl.z = m_segmentParams.read(segIndex + 2);</span><br>  1820-&gt;1820:  <span style="background-color: white">      						ptControl = transform.transform(ptControl);</span><br>  1821-&gt;1821:  <span style="background-color: white">      						m_segmentParams.write(segIndex, ptControl.x);</span><br>  1822-&gt;1822:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 1, ptControl.y);</span><br>  1823-&gt;1823:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 1, ptControl.z);</span><br>     1824-&gt;N:  <span style="background-color: white">      </span><br>  1825-&gt;1825:  <span style="background-color: white">      						ptControl.x = m_segmentParams.read(segIndex + 3);</span><br>  1826-&gt;1826:  <span style="background-color: white">      						ptControl.y = m_segmentParams.read(segIndex + 4);</span><br>  1827-&gt;1827:  <span style="background-color: white">      						ptControl.z = m_segmentParams.read(segIndex + 5);</span><br>  1828-&gt;1828:  <span style="background-color: white">      						ptControl = transform.transform(ptControl);</span><br>  1829-&gt;1829:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 3, ptControl.x);</span><br>  1830-&gt;1830:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 4, ptControl.y);</span><br>  1831-&gt;1831:  <span style="background-color: white">      						m_segmentParams.write(segIndex + 5, ptControl.z);</span><br>     1832-&gt;N:  <span style="background-color: white">      					}</span><br>  1833-&gt;1833:  <span style="background-color: white">      						break;</span><br>     1834-&gt;N:  <span style="background-color: white">      					case SegmentFlags.enumArcSeg:</span><br>  1835-&gt;1835:  <span style="background-color: white">      						throw GeometryException.GeometryInternalError();</span><br>     1836-&gt;N:  <span style="background-color: white">      </span><br>     1837-&gt;N:  <span style="background-color: white">      					}</span><br>     1838-&gt;N:  <span style="background-color: white">      				}</span><br>     1839-&gt;N:  <span style="background-color: white">      			}</span><br>     1840-&gt;N:  <span style="background-color: white">      </span><br>  1841-&gt;1841:  <span style="background-color: white">      			ptStart = transform.transform(ptStart);</span><br>  1842-&gt;1842:  <span style="background-color: white">      			points.write(ipoint * 2, ptStart.x);</span><br>  1843-&gt;1843:  <span style="background-color: white">      			points.write(ipoint * 2 + 1, ptStart.y);</span><br>  1844-&gt;1844:  <span style="background-color: white">      			zs.write(ipoint, ptStart.z);</span><br>     1845-&gt;N:  <span style="background-color: white">      		}</span><br>     1846-&gt;N:  <span style="background-color: white">      </span><br>     1847-&gt;N:  <span style="background-color: white">      		// REFACTOR: reset the exact envelope only and transform the loose</span><br>     1848-&gt;N:  <span style="background-color: white">      		// envelope</span><br>     1849-&gt;N:  <span style="background-color: white">      </span><br>  1850-&gt;1850:  <span style="background-color: white">      		notifyModified(DirtyFlags.DirtyCoordinates);</span><br>     1851-&gt;N:  <span style="background-color: white">      	}</span><br>     1852-&gt;N:  <span style="background-color: white">      </span><br>  1853-&gt;1853:  <span style="background-color: cyan">      	@Override</span><br>  1854-&gt;1854:  <span style="background-color: white">      	protected void _verifyStreamsImpl() {</span><br>  1855-&gt;1855:  <span style="background-color: cyan">      		if (m_paths == null) {</span><br>  1856-&gt;1856:  <span style="background-color: white">      			m_paths = (AttributeStreamOfInt32) AttributeStreamBase</span><br>  1857-&gt;1857:  <span style="background-color: white">      					.createIndexStream(1, 0);</span><br>  1858-&gt;1858:  <span style="background-color: white">      			m_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase</span><br>  1859-&gt;1859:  <span style="background-color: white">      					.createByteStream(1, (byte) 0);</span><br>     1860-&gt;N:  <span style="background-color: white">      		}</span><br>     1861-&gt;N:  <span style="background-color: white">      </span><br>  1862-&gt;1862:  <span style="background-color: cyan">      		if (m_segmentFlags != null) {</span><br>  1863-&gt;1863:  <span style="background-color: white">      			m_segmentFlags.resize(m_reservedPointCount,</span><br>  1864-&gt;1864:  <span style="background-color: white">      					(byte) SegmentFlags.enumLineSeg);</span><br>  1865-&gt;1865:  <span style="background-color: white">      			m_segmentParamIndex.resize(m_reservedPointCount, -1);</span><br>     1866-&gt;N:  <span style="background-color: white">      		}</span><br>     1867-&gt;N:  <span style="background-color: white">      	}</span><br>     1868-&gt;N:  <span style="background-color: white">      </span><br>  1869-&gt;1869:  <span style="background-color: white">      	@Override</span><br>  1870-&gt;1870:  <span style="background-color: white">      	void _copyToImpl(MultiVertexGeometryImpl dst) {</span><br>  1871-&gt;1871:  <span style="background-color: white">      		MultiPathImpl dstPoly = (MultiPathImpl) dst;</span><br>  1872-&gt;1872:  <span style="background-color: white">      		dstPoly.m_bPathStarted = false;</span><br>  1873-&gt;1873:  <span style="background-color: white">      		dstPoly.m_curveParamwritePoint = m_curveParamwritePoint;</span><br>  1874-&gt;1874:  <span style="background-color: white">      		dstPoly.m_fill_rule = m_fill_rule;</span><br>     1875-&gt;N:  <span style="background-color: white">      		</span><br>  1876-&gt;1876:  <span style="background-color: white">      		if (m_paths != null)</span><br>  1877-&gt;1877:  <span style="background-color: white">      			dstPoly.m_paths = new AttributeStreamOfInt32(m_paths);</span><br>     1878-&gt;N:  <span style="background-color: white">      		else</span><br>  1879-&gt;1879:  <span style="background-color: white">      			dstPoly.m_paths = null;</span><br>     1880-&gt;N:  <span style="background-color: white">      </span><br>  1881-&gt;1881:  <span style="background-color: white">      		if (m_pathFlags != null)</span><br>  1882-&gt;1882:  <span style="background-color: white">      			dstPoly.m_pathFlags = new AttributeStreamOfInt8(m_pathFlags);</span><br>     1883-&gt;N:  <span style="background-color: white">      		else</span><br>  1884-&gt;1884:  <span style="background-color: white">      			dstPoly.m_pathFlags = null;</span><br>     1885-&gt;N:  <span style="background-color: white">      </span><br>  1886-&gt;1886:  <span style="background-color: white">      		if (m_segmentParamIndex != null)</span><br>  1887-&gt;1887:  <span style="background-color: white">      			dstPoly.m_segmentParamIndex = new AttributeStreamOfInt32(</span><br>     1888-&gt;N:  <span style="background-color: white">      					m_segmentParamIndex);</span><br>     1889-&gt;N:  <span style="background-color: white">      		else</span><br>  1890-&gt;1890:  <span style="background-color: white">      			dstPoly.m_segmentParamIndex = null;</span><br>     1891-&gt;N:  <span style="background-color: white">      </span><br>  1892-&gt;1892:  <span style="background-color: white">      		if (m_segmentFlags != null)</span><br>  1893-&gt;1893:  <span style="background-color: white">      			dstPoly.m_segmentFlags = new AttributeStreamOfInt8(m_segmentFlags);</span><br>     1894-&gt;N:  <span style="background-color: white">      		else</span><br>  1895-&gt;1895:  <span style="background-color: white">      			dstPoly.m_segmentFlags = null;</span><br>     1896-&gt;N:  <span style="background-color: white">      </span><br>  1897-&gt;1897:  <span style="background-color: white">      		if (m_segmentParams != null)</span><br>  1898-&gt;1898:  <span style="background-color: white">      			dstPoly.m_segmentParams = new AttributeStreamOfDbl(m_segmentParams);</span><br>     1899-&gt;N:  <span style="background-color: white">      		else</span><br>  1900-&gt;1900:  <span style="background-color: white">      			dstPoly.m_segmentParams = null;</span><br>     1901-&gt;N:  <span style="background-color: white">      </span><br>  1902-&gt;1902:  <span style="background-color: white">      		dstPoly.m_cachedLength2D = m_cachedLength2D;</span><br>  1903-&gt;1903:  <span style="background-color: white">      		dstPoly.m_cachedArea2D = m_cachedArea2D;</span><br>     1904-&gt;N:  <span style="background-color: white">      </span><br>  1905-&gt;1905:  <span style="background-color: white">      		if (!_hasDirtyFlag(DirtyFlags.DirtyRingAreas2D)) {</span><br>  1906-&gt;1906:  <span style="background-color: white">      			dstPoly.m_cachedRingAreas2D = (AttributeStreamOfDbl) m_cachedRingAreas2D;</span><br>     1907-&gt;N:  <span style="background-color: white">      		} else</span><br>  1908-&gt;1908:  <span style="background-color: white">      			dstPoly.m_cachedRingAreas2D = null;</span><br>     1909-&gt;N:  <span style="background-color: white">      </span><br>     1910-&gt;N:  <span style="background-color: white">      	}</span><br>     1911-&gt;N:  <span style="background-color: white">      </span><br>  1912-&gt;1912:  <span style="background-color: white">      	@Override</span><br>  1913-&gt;1913:  <span style="background-color: white">      	public double calculateLength2D() {</span><br>  1914-&gt;1914:  <span style="background-color: white">      		if (!_hasDirtyFlag(DirtyFlags.DirtyLength2D)) {</span><br>     1915-&gt;N:  <span style="background-color: white">      			return m_cachedLength2D;</span><br>     1916-&gt;N:  <span style="background-color: white">      		}</span><br>     1917-&gt;N:  <span style="background-color: white">      </span><br>  1918-&gt;1918:  <span style="background-color: white">      		SegmentIteratorImpl segIter = querySegmentIterator();</span><br>  1919-&gt;1919:  <span style="background-color: white">      		MathUtils.KahanSummator len = new MathUtils.KahanSummator(0);</span><br>  1920-&gt;1920:  <span style="background-color: white">      		while (segIter.nextPath()) {</span><br>  1921-&gt;1921:  <span style="background-color: white">      			while (segIter.hasNextSegment()) {</span><br>  1922-&gt;1922:  <span style="background-color: white">      				len.add(segIter.nextSegment().calculateLength2D());</span><br>     1923-&gt;N:  <span style="background-color: white">      			}</span><br>     1924-&gt;N:  <span style="background-color: white">      		}</span><br>     1925-&gt;N:  <span style="background-color: white">      </span><br>  1926-&gt;1926:  <span style="background-color: white">      		m_cachedLength2D = len.getResult();</span><br>  1927-&gt;1927:  <span style="background-color: white">      		_setDirtyFlag(DirtyFlags.DirtyLength2D, false);</span><br>     1928-&gt;N:  <span style="background-color: white">      </span><br>  1929-&gt;1929:  <span style="background-color: white">      		return len.getResult();</span><br>     1930-&gt;N:  <span style="background-color: white">      	}</span><br>     1931-&gt;N:  <span style="background-color: white">      </span><br>  1932-&gt;1932:  <span style="background-color: cyan">      	@Override</span><br>  1933-&gt;1933:  <span style="background-color: white">      	public boolean equals(Object other) {</span><br>  1934-&gt;1934:  <span style="background-color: cyan">      		if (other == this)</span><br>  1935-&gt;1935:  <span style="background-color: white">      			return true;</span><br>     1936-&gt;N:  <span style="background-color: white">      </span><br>  1937-&gt;1937:  <span style="background-color: cyan">      		if (!(other instanceof MultiPathImpl))</span><br>  1938-&gt;1938:  <span style="background-color: white">      			return false;</span><br>     1939-&gt;N:  <span style="background-color: white">      </span><br>  1940-&gt;1940:  <span style="background-color: cyan">      		if (!super.equals(other))</span><br>  1941-&gt;1941:  <span style="background-color: white">      			return false;</span><br>     1942-&gt;N:  <span style="background-color: white">      </span><br>  1943-&gt;1943:  <span style="background-color: cyan">      		MultiPathImpl otherMultiPath = (MultiPathImpl) other;</span><br>     1944-&gt;N:  <span style="background-color: white">      </span><br>  1945-&gt;1945:  <span style="background-color: cyan">      		int pathCount = getPathCount();</span><br>  1946-&gt;1946:  <span style="background-color: cyan">      		int pathCountOther = otherMultiPath.getPathCount();</span><br>     1947-&gt;N:  <span style="background-color: white">      </span><br>  1948-&gt;1948:  <span style="background-color: cyan">      		if (pathCount != pathCountOther)</span><br>  1949-&gt;1949:  <span style="background-color: white">      			return false;</span><br>     1950-&gt;N:  <span style="background-color: white">      </span><br>  1951-&gt;1951:  <span style="background-color: cyan">      		if (pathCount &gt; 0 &amp;&amp; m_paths != null</span><br>  1952-&gt;1952:  <span style="background-color: white">      				&amp;&amp; !m_paths.equals(otherMultiPath.m_paths, 0, pathCount + 1))</span><br>  1953-&gt;1953:  <span style="background-color: white">      			return false;</span><br>     1954-&gt;N:  <span style="background-color: white">      </span><br>  1955-&gt;1955:  <span style="background-color: cyan">      		if (m_fill_rule != otherMultiPath.m_fill_rule)</span><br>  1956-&gt;1956:  <span style="background-color: white">      			return false;</span><br>     1957-&gt;N:  <span style="background-color: white">      </span><br>     1958-&gt;N:  <span style="background-color: white">      		{</span><br>     1959-&gt;N:  <span style="background-color: white">      			// Note: OGC flags do not participate in the equals operation by</span><br>     1960-&gt;N:  <span style="background-color: white">      			// design.</span><br>     1961-&gt;N:  <span style="background-color: white">      			// Because for the polygon pathFlags will have all enum_closed set,</span><br>     1962-&gt;N:  <span style="background-color: white">      			// we do not need to compare this stream. Only for polyline.</span><br>     1963-&gt;N:  <span style="background-color: white">      			// Polyline does not have OGC flags set.</span><br>     1964-&gt;N:  <span style="background-color: white">      			if (!m_bPolygon) {</span><br>  1965-&gt;1965:  <span style="background-color: white">      				if (m_pathFlags != null</span><br>  1966-&gt;1966:  <span style="background-color: white">      						&amp;&amp; !m_pathFlags.equals(otherMultiPath.m_pathFlags, 0,</span><br>  1967-&gt;1967:  <span style="background-color: white">      								pathCount))</span><br>  1968-&gt;1968:  <span style="background-color: white">      					return false;</span><br>     1969-&gt;N:  <span style="background-color: white">      			}</span><br>     1970-&gt;N:  <span style="background-color: white">      		}</span><br>     1971-&gt;N:  <span style="background-color: white">      	      </span><br>  1972-&gt;1972:  <span style="background-color: cyan">      		return super.equals(other);</span><br>     1973-&gt;N:  <span style="background-color: white">      	}</span><br>     1974-&gt;N:  <span style="background-color: white">      </span><br>     1975-&gt;N:  <span style="background-color: white">      	/**</span><br>     1976-&gt;N:  <span style="background-color: white">      	 * Returns a SegmentIterator that set to a specific vertex of the</span><br>     1977-&gt;N:  <span style="background-color: white">      	 * MultiPathImpl. The call to NextSegment will return the segment that</span><br>     1978-&gt;N:  <span style="background-color: white">      	 * starts at the vertex. Call to PreviousSegment will return the segment</span><br>     1979-&gt;N:  <span style="background-color: white">      	 * that starts at the previous vertex.</span><br>     1980-&gt;N:  <span style="background-color: white">      	 */</span><br>  1981-&gt;1981:  <span style="background-color: white">      	public SegmentIteratorImpl querySegmentIteratorAtVertex(int startVertexIndex) {</span><br>  1982-&gt;1982:  <span style="background-color: white">      		if (startVertexIndex &lt; 0 || startVertexIndex &gt;= getPointCount())</span><br>  1983-&gt;1983:  <span style="background-color: white">      			throw new IndexOutOfBoundsException();</span><br>     1984-&gt;N:  <span style="background-color: white">      </span><br>  1985-&gt;1985:  <span style="background-color: white">      		SegmentIteratorImpl iter = new SegmentIteratorImpl(this,</span><br>  1986-&gt;1986:  <span style="background-color: white">      				startVertexIndex);</span><br>  1987-&gt;1987:  <span style="background-color: white">      		return iter;</span><br>     1988-&gt;N:  <span style="background-color: white">      	}</span><br>     1989-&gt;N:  <span style="background-color: white">      </span><br>     1990-&gt;N:  <span style="background-color: white">      	// void QuerySegmentIterator(int fromVertex, SegmentIterator iterator);</span><br>  1991-&gt;1991:  <span style="background-color: cyan">      	public SegmentIteratorImpl querySegmentIterator() {</span><br>     1992-&gt;N:  <span style="background-color: white">      		return new SegmentIteratorImpl(this);</span><br>     1993-&gt;N:  <span style="background-color: white">      	}</span><br>     1994-&gt;N:  <span style="background-color: white">      </span><br>  1995-&gt;1995:  <span style="background-color: white">      	@Override</span><br>  1996-&gt;1996:  <span style="background-color: white">      	public void _updateXYImpl(boolean bExact) {</span><br>  1997-&gt;1997:  <span style="background-color: white">      		super._updateXYImpl(bExact);</span><br>  1998-&gt;1998:  <span style="background-color: white">      		boolean bHasCurves = hasNonLinearSegments();</span><br>  1999-&gt;1999:  <span style="background-color: white">      		if (bHasCurves) {</span><br>  2000-&gt;2000:  <span style="background-color: white">      			SegmentIteratorImpl segIter = querySegmentIterator();</span><br>  2001-&gt;2001:  <span style="background-color: white">      			while (segIter.nextPath()) {</span><br>  2002-&gt;2002:  <span style="background-color: white">      				while (segIter.hasNextSegment()) {</span><br>  2003-&gt;2003:  <span style="background-color: white">      					Segment curve = segIter.nextCurve();</span><br>  2004-&gt;2004:  <span style="background-color: white">      					if (curve != null) {</span><br>  2005-&gt;2005:  <span style="background-color: white">      						Envelope2D env2D = new Envelope2D();</span><br>  2006-&gt;2006:  <span style="background-color: white">      						curve.queryEnvelope2D(env2D);</span><br>  2007-&gt;2007:  <span style="background-color: white">      						m_envelope.merge(env2D);</span><br>     2008-&gt;N:  <span style="background-color: white">      					} else</span><br>  2009-&gt;2009:  <span style="background-color: white">      						break;</span><br>     2010-&gt;N:  <span style="background-color: white">      				}</span><br>     2011-&gt;N:  <span style="background-color: white">      			}</span><br>     2012-&gt;N:  <span style="background-color: white">      		}</span><br>     2013-&gt;N:  <span style="background-color: white">      	}</span><br>     2014-&gt;N:  <span style="background-color: white">      </span><br>  2015-&gt;2015:  <span style="background-color: white">      	@Override</span><br>  2016-&gt;2016:  <span style="background-color: white">      	void calculateEnvelope2D(Envelope2D env, boolean bExact) {</span><br>  2017-&gt;2017:  <span style="background-color: white">      		super.calculateEnvelope2D(env, bExact);</span><br>  2018-&gt;2018:  <span style="background-color: white">      		boolean bHasCurves = hasNonLinearSegments();</span><br>  2019-&gt;2019:  <span style="background-color: white">      		if (bHasCurves) {</span><br>  2020-&gt;2020:  <span style="background-color: white">      			SegmentIteratorImpl segIter = querySegmentIterator();</span><br>  2021-&gt;2021:  <span style="background-color: white">      			while (segIter.nextPath()) {</span><br>  2022-&gt;2022:  <span style="background-color: white">      				while (segIter.hasNextSegment()) {</span><br>  2023-&gt;2023:  <span style="background-color: white">      					Segment curve = segIter.nextCurve();</span><br>  2024-&gt;2024:  <span style="background-color: white">      					if (curve != null) {</span><br>  2025-&gt;2025:  <span style="background-color: white">      						Envelope2D env2D = new Envelope2D();</span><br>  2026-&gt;2026:  <span style="background-color: white">      						curve.queryEnvelope2D(env2D);</span><br>  2027-&gt;2027:  <span style="background-color: white">      						env.merge(env2D);</span><br>     2028-&gt;N:  <span style="background-color: white">      					} else</span><br>  2029-&gt;2029:  <span style="background-color: white">      						break;</span><br>     2030-&gt;N:  <span style="background-color: white">      				}</span><br>     2031-&gt;N:  <span style="background-color: white">      			}</span><br>     2032-&gt;N:  <span style="background-color: white">      		}</span><br>     2033-&gt;N:  <span style="background-color: white">      	}</span><br>     2034-&gt;N:  <span style="background-color: white">      </span><br>  2035-&gt;2035:  <span style="background-color: cyan">      	@Override</span><br>  2036-&gt;2036:  <span style="background-color: white">      	public void _notifyModifiedAllImpl() {</span><br>  2037-&gt;2037:  <span style="background-color: cyan">      		if (m_paths == null || m_paths.size() == 0)// if (m_paths == null ||</span><br>     2038-&gt;N:  <span style="background-color: white">      													// !m_paths.size())</span><br>  2039-&gt;2039:  <span style="background-color: white">      			m_pointCount = 0;</span><br>     2040-&gt;N:  <span style="background-color: white">      		else</span><br>  2041-&gt;2041:  <span style="background-color: cyan">      			m_pointCount = m_paths.read(m_paths.size() - 1);</span><br>     2042-&gt;N:  <span style="background-color: white">      	}</span><br>     2043-&gt;N:  <span style="background-color: white">      </span><br>  2044-&gt;2044:  <span style="background-color: white">      	@Override</span><br>  2045-&gt;2045:  <span style="background-color: white">      	public double calculateArea2D() {</span><br>     2046-&gt;N:  <span style="background-color: white">      		if (!m_bPolygon)</span><br>  2047-&gt;2047:  <span style="background-color: white">      			return 0.0;</span><br>     2048-&gt;N:  <span style="background-color: white">      </span><br>     2049-&gt;N:  <span style="background-color: white">      		_updateRingAreas2D();</span><br>     2050-&gt;N:  <span style="background-color: white">      </span><br>     2051-&gt;N:  <span style="background-color: white">      		return m_cachedArea2D;</span><br>     2052-&gt;N:  <span style="background-color: white">      	}</span><br>     2053-&gt;N:  <span style="background-color: white">      </span><br>     2054-&gt;N:  <span style="background-color: white">      	/**</span><br>     2055-&gt;N:  <span style="background-color: white">      	 * Returns True if the ring is an exterior ring. Valid only for simple</span><br>     2056-&gt;N:  <span style="background-color: white">      	 * polygons.</span><br>     2057-&gt;N:  <span style="background-color: white">      	 */</span><br>  2058-&gt;2058:  <span style="background-color: white">      	public boolean isExteriorRing(int ringIndex) {</span><br>     2059-&gt;N:  <span style="background-color: white">      		if (!m_bPolygon)</span><br>  2060-&gt;2060:  <span style="background-color: white">      			return false;</span><br>     2061-&gt;N:  <span style="background-color: white">      </span><br>  2062-&gt;2062:  <span style="background-color: white">      		if (!_hasDirtyFlag(DirtyFlags.DirtyOGCFlags))</span><br>  2063-&gt;2063:  <span style="background-color: white">      			return (m_pathFlags.read(ringIndex) &amp; (byte) PathFlags.enumOGCStartPolygon) != 0;</span><br>     2064-&gt;N:  <span style="background-color: white">      </span><br>     2065-&gt;N:  <span style="background-color: white">      		_updateRingAreas2D();</span><br>  2066-&gt;2066:  <span style="background-color: white">      		return m_cachedRingAreas2D.read(ringIndex) &gt; 0;</span><br>     2067-&gt;N:  <span style="background-color: white">      		// Should we make a function called _UpdateHasNonLinearSegmentsFlags and</span><br>     2068-&gt;N:  <span style="background-color: white">      		// call it here?</span><br>     2069-&gt;N:  <span style="background-color: white">      	}</span><br>     2070-&gt;N:  <span style="background-color: white">      </span><br>  2071-&gt;2071:  <span style="background-color: cyan">      	public double calculateRingArea2D(int pathIndex) {</span><br>     2072-&gt;N:  <span style="background-color: white">      		if (!m_bPolygon)</span><br>  2073-&gt;2073:  <span style="background-color: white">      			return 0.0;</span><br>     2074-&gt;N:  <span style="background-color: white">      </span><br>     2075-&gt;N:  <span style="background-color: white">      		_updateRingAreas2D();</span><br>     2076-&gt;N:  <span style="background-color: white">      </span><br>  2077-&gt;2077:  <span style="background-color: cyan">      		return m_cachedRingAreas2D.read(pathIndex);</span><br>     2078-&gt;N:  <span style="background-color: white">      	}</span><br>     2079-&gt;N:  <span style="background-color: white">      </span><br>  2080-&gt;2080:  <span style="background-color: cyan">      	public void _updateRingAreas2D() {</span><br>  2081-&gt;2081:  <span style="background-color: cyan">      		if (_hasDirtyFlag(DirtyFlags.DirtyRingAreas2D)) {</span><br>  2082-&gt;2082:  <span style="background-color: cyan">      			int pathCount = getPathCount();</span><br>     2083-&gt;N:  <span style="background-color: white">      </span><br>  2084-&gt;2084:  <span style="background-color: cyan">      			if (m_cachedRingAreas2D == null)</span><br>  2085-&gt;2085:  <span style="background-color: cyan">      				m_cachedRingAreas2D = new AttributeStreamOfDbl(pathCount);</span><br>  2086-&gt;2086:  <span style="background-color: white">      			else if (m_cachedRingAreas2D.size() != pathCount)</span><br>  2087-&gt;2087:  <span style="background-color: white">      				m_cachedRingAreas2D.resize(pathCount);</span><br>     2088-&gt;N:  <span style="background-color: white">      </span><br>  2089-&gt;2089:  <span style="background-color: cyan">      			MathUtils.KahanSummator totalArea = new MathUtils.KahanSummator(0);</span><br>  2090-&gt;2090:  <span style="background-color: cyan">      			MathUtils.KahanSummator pathArea = new MathUtils.KahanSummator(0);</span><br>  2091-&gt;2091:  <span style="background-color: cyan">      			Point2D pt = new Point2D();</span><br>  2092-&gt;2092:  <span style="background-color: cyan">      			int ipath = 0;</span><br>  2093-&gt;2093:  <span style="background-color: cyan">      			SegmentIteratorImpl segIter = querySegmentIterator();</span><br>  2094-&gt;2094:  <span style="background-color: cyan">      			while (segIter.nextPath()) {</span><br>  2095-&gt;2095:  <span style="background-color: cyan">      				pathArea.reset();</span><br>  2096-&gt;2096:  <span style="background-color: cyan">      				getXY(getPathStart(segIter.getPathIndex()), pt);// get the area</span><br>     2097-&gt;N:  <span style="background-color: white">      																// calculation</span><br>     2098-&gt;N:  <span style="background-color: white">      																// origin to be</span><br>     2099-&gt;N:  <span style="background-color: white">      																// the origin of</span><br>     2100-&gt;N:  <span style="background-color: white">      																// the ring.</span><br>  2101-&gt;2101:  <span style="background-color: cyan">      				while (segIter.hasNextSegment()) {</span><br>  2102-&gt;2102:  <span style="background-color: cyan">      					pathArea.add(segIter.nextSegment()._calculateArea2DHelper(</span><br>  2103-&gt;2103:  <span style="background-color: white">      							pt.x, pt.y));</span><br>     2104-&gt;N:  <span style="background-color: white">      				}</span><br>     2105-&gt;N:  <span style="background-color: white">      </span><br>  2106-&gt;2106:  <span style="background-color: cyan">      				totalArea.add(pathArea.getResult());</span><br>     2107-&gt;N:  <span style="background-color: white">      </span><br>  2108-&gt;2108:  <span style="background-color: cyan">      				int i = ipath++;</span><br>  2109-&gt;2109:  <span style="background-color: cyan">      				m_cachedRingAreas2D.write(i, pathArea.getResult());</span><br>     2110-&gt;N:  <span style="background-color: white">      			}</span><br>     2111-&gt;N:  <span style="background-color: white">      </span><br>  2112-&gt;2112:  <span style="background-color: cyan">      			m_cachedArea2D = totalArea.getResult();</span><br>  2113-&gt;2113:  <span style="background-color: cyan">      			_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, false);</span><br>     2114-&gt;N:  <span style="background-color: white">      		}</span><br>     2115-&gt;N:  <span style="background-color: white">      	}</span><br>     2116-&gt;N:  <span style="background-color: white">      </span><br>  2117-&gt;2117:  <span style="background-color: cyan">      	int getOGCPolygonCount() {</span><br>     2118-&gt;N:  <span style="background-color: white">      		if (!m_bPolygon)</span><br>  2119-&gt;2119:  <span style="background-color: white">      			return 0;</span><br>     2120-&gt;N:  <span style="background-color: white">      </span><br>     2121-&gt;N:  <span style="background-color: white">      		_updateOGCFlags();</span><br>     2122-&gt;N:  <span style="background-color: white">      </span><br>  2123-&gt;2123:  <span style="background-color: cyan">      		int polygonCount = 0;</span><br>  2124-&gt;2124:  <span style="background-color: cyan">      		int partCount = getPathCount();</span><br>  2125-&gt;2125:  <span style="background-color: cyan">      		for (int ipart = 0; ipart &lt; partCount; ipart++) {</span><br>  2126-&gt;2126:  <span style="background-color: cyan">      			if (((int) m_pathFlags.read(ipart) &amp; (int) PathFlags.enumOGCStartPolygon) != 0)</span><br>  2127-&gt;2127:  <span style="background-color: cyan">      				polygonCount++;</span><br>     2128-&gt;N:  <span style="background-color: white">      		}</span><br>     2129-&gt;N:  <span style="background-color: white">      </span><br>  2130-&gt;2130:  <span style="background-color: cyan">      		return polygonCount;</span><br>     2131-&gt;N:  <span style="background-color: white">      	}</span><br>     2132-&gt;N:  <span style="background-color: white">      </span><br>     2133-&gt;U:  <span style="background-color: yellow">      	protected void _updateOGCFlags() {</span><br>     2134-&gt;U:  <span style="background-color: yellow">      		if (_hasDirtyFlag(DirtyFlags.DirtyOGCFlags)) {</span><br>     2135-&gt;U:  <span style="background-color: yellow">      			_updateRingAreas2D();</span><br>     2136-&gt;U:  <span style="background-color: yellow">      			_updateOGCFlagsHelper();</span><br>     2137-&gt;U:  <span style="background-color: yellow">      			_setDirtyFlag(DirtyFlags.DirtyOGCFlags, false);</span><br>     2138-&gt;U:  <span style="background-color: yellow">      		}</span><br>     2139-&gt;U:  <span style="background-color: yellow">      	}</span><br>     2140-&gt;N:  <span style="background-color: white">      	</span><br>     2141-&gt;U:  <span style="background-color: yellow">      	private void _updateOGCFlagsHelper() {</span><br>     2142-&gt;U:  <span style="background-color: yellow">      		int pathCount = getPathCount();</span><br>     2143-&gt;U:  <span style="background-color: yellow">      		if (pathCount &gt; 0 &amp;&amp; (m_pathFlags == null || m_pathFlags.size() &lt; pathCount))</span><br>     2144-&gt;U:  <span style="background-color: yellow">      			m_pathFlags = (AttributeStreamOfInt8) AttributeStreamBase.createByteStream(pathCount + 1);</span><br>     2145-&gt;U:  <span style="background-color: yellow">      </span><br>     2146-&gt;U:  <span style="background-color: yellow">      		// firstSign is the sign of first ring.</span><br>     2147-&gt;U:  <span style="background-color: yellow">      		// a first ring with non zero area defines the</span><br>     2148-&gt;U:  <span style="background-color: yellow">      		// value. First zero area rings are written out as enumOGCStartPolygon.</span><br>     2149-&gt;U:  <span style="background-color: yellow">      		int firstSign = 0;</span><br>     2150-&gt;U:  <span style="background-color: yellow">      		for (int ipath = 0; ipath &lt; pathCount; ipath++) {</span><br>     2151-&gt;U:  <span style="background-color: yellow">      			double area = m_cachedRingAreas2D.read(ipath);</span><br>     2152-&gt;U:  <span style="background-color: yellow">      			if (firstSign == 0) {</span><br>     2153-&gt;U:  <span style="background-color: yellow">      				// if the first ring is inverted we assume that the</span><br>     2154-&gt;U:  <span style="background-color: yellow">      				// whole polygon is inverted.</span><br>     2155-&gt;U:  <span style="background-color: yellow">      				firstSign = MathUtils.sign(area);</span><br>     2156-&gt;U:  <span style="background-color: yellow">      			}</span><br>     2157-&gt;U:  <span style="background-color: yellow">      </span><br>     2158-&gt;U:  <span style="background-color: yellow">      			if (area * firstSign &gt; 0.0 || firstSign == 0)</span><br>     2159-&gt;U:  <span style="background-color: yellow">      				m_pathFlags.setBits(ipath, (byte) PathFlags.enumOGCStartPolygon);</span><br>     2160-&gt;U:  <span style="background-color: yellow">      			else</span><br>     2161-&gt;U:  <span style="background-color: yellow">      				m_pathFlags.clearBits(ipath, (byte) PathFlags.enumOGCStartPolygon);</span><br>     2162-&gt;U:  <span style="background-color: yellow">      		}</span><br>     2163-&gt;U:  <span style="background-color: yellow">      	}</span><br>     2164-&gt;N:  <span style="background-color: white">      </span><br>  2165-&gt;2158:  <span style="background-color: white">      	public int getPathIndexFromPointIndex(int pointIndex) {</span><br>  2166-&gt;2159:  <span style="background-color: white">      		int positionHint = m_currentPathIndex;// in case of multithreading</span><br>     2167-&gt;N:  <span style="background-color: white">      												// thiswould simply produce an</span><br>     2168-&gt;N:  <span style="background-color: white">      												// invalid value</span><br>  2169-&gt;2162:  <span style="background-color: white">      		int pathCount = getPathCount();</span><br>     2170-&gt;N:  <span style="background-color: white">      </span><br>     2171-&gt;N:  <span style="background-color: white">      		// Try using the hint position first to get the path index.</span><br>  2172-&gt;2165:  <span style="background-color: white">      		if (positionHint &gt;= 0 &amp;&amp; positionHint &lt; pathCount) {</span><br>  2173-&gt;2166:  <span style="background-color: white">      			if (pointIndex &lt; getPathEnd(positionHint)) {</span><br>  2174-&gt;2167:  <span style="background-color: white">      				if (pointIndex &gt;= getPathStart(positionHint))</span><br>  2175-&gt;2168:  <span style="background-color: white">      					return positionHint;</span><br>  2176-&gt;2169:  <span style="background-color: white">      				positionHint--;</span><br>     2177-&gt;N:  <span style="background-color: white">      			} else {</span><br>  2178-&gt;2171:  <span style="background-color: white">      				positionHint++;</span><br>     2179-&gt;N:  <span style="background-color: white">      			}</span><br>     2180-&gt;N:  <span style="background-color: white">      </span><br>  2181-&gt;2174:  <span style="background-color: white">      			if (positionHint &gt;= 0 &amp;&amp; positionHint &lt; pathCount) {</span><br>  2182-&gt;2175:  <span style="background-color: white">      				if (pointIndex &gt;= getPathStart(positionHint)</span><br>  2183-&gt;2176:  <span style="background-color: white">      						&amp;&amp; pointIndex &lt; getPathEnd(positionHint)) {</span><br>  2184-&gt;2177:  <span style="background-color: white">      					m_currentPathIndex = positionHint;</span><br>  2185-&gt;2178:  <span style="background-color: white">      					return positionHint;</span><br>     2186-&gt;N:  <span style="background-color: white">      				}</span><br>     2187-&gt;N:  <span style="background-color: white">      			}</span><br>     2188-&gt;N:  <span style="background-color: white">      		}</span><br>     2189-&gt;N:  <span style="background-color: white">      </span><br>  2190-&gt;2183:  <span style="background-color: white">      		if (pathCount &lt; 5) {// TODO: time the performance to choose when to use</span><br>     2191-&gt;N:  <span style="background-color: white">      							// linear search.</span><br>  2192-&gt;2185:  <span style="background-color: white">      			for (int i = 0; i &lt; pathCount; i++) {</span><br>  2193-&gt;2186:  <span style="background-color: white">      				if (pointIndex &lt; getPathEnd(i)) {</span><br>  2194-&gt;2187:  <span style="background-color: white">      					m_currentPathIndex = i;</span><br>  2195-&gt;2188:  <span style="background-color: white">      					return i;</span><br>     2196-&gt;N:  <span style="background-color: white">      				}</span><br>     2197-&gt;N:  <span style="background-color: white">      			}</span><br>  2198-&gt;2191:  <span style="background-color: white">      			throw new GeometryException("corrupted geometry");</span><br>     2199-&gt;N:  <span style="background-color: white">      		}</span><br>     2200-&gt;N:  <span style="background-color: white">      </span><br>     2201-&gt;N:  <span style="background-color: white">      		// Do binary search:</span><br>  2202-&gt;2195:  <span style="background-color: white">      		int minPathIndex = 0;</span><br>  2203-&gt;2196:  <span style="background-color: white">      		int maxPathIndex = pathCount - 1;</span><br>  2204-&gt;2197:  <span style="background-color: white">      		while (maxPathIndex &gt; minPathIndex) {</span><br>  2205-&gt;2198:  <span style="background-color: white">      			int mid = minPathIndex + ((maxPathIndex - minPathIndex) &gt;&gt; 1);</span><br>  2206-&gt;2199:  <span style="background-color: white">      			int pathStart = getPathStart(mid);</span><br>  2207-&gt;2200:  <span style="background-color: white">      			if (pointIndex &lt; pathStart)</span><br>  2208-&gt;2201:  <span style="background-color: white">      				maxPathIndex = mid - 1;</span><br>     2209-&gt;N:  <span style="background-color: white">      			else {</span><br>  2210-&gt;2203:  <span style="background-color: white">      				int pathEnd = getPathEnd(mid);</span><br>  2211-&gt;2204:  <span style="background-color: white">      				if (pointIndex &gt;= pathEnd)</span><br>  2212-&gt;2205:  <span style="background-color: white">      					minPathIndex = mid + 1;</span><br>     2213-&gt;N:  <span style="background-color: white">      				else {</span><br>  2214-&gt;2207:  <span style="background-color: white">      					m_currentPathIndex = mid;</span><br>  2215-&gt;2208:  <span style="background-color: white">      					return mid;</span><br>     2216-&gt;N:  <span style="background-color: white">      				}</span><br>     2217-&gt;N:  <span style="background-color: white">      			}</span><br>     2218-&gt;N:  <span style="background-color: white">      		}</span><br>     2219-&gt;N:  <span style="background-color: white">      </span><br>  2220-&gt;2213:  <span style="background-color: white">      		m_currentPathIndex = minPathIndex;</span><br>  2221-&gt;2214:  <span style="background-color: white">      		return minPathIndex;</span><br>     2222-&gt;N:  <span style="background-color: white">      	}</span><br>     2223-&gt;N:  <span style="background-color: white">      </span><br>  2224-&gt;2217:  <span style="background-color: cyan">      	int getHighestPointIndex(int path_index) {</span><br>  2225-&gt;2218:  <span style="background-color: cyan">      		assert (path_index &gt;= 0 &amp;&amp; path_index &lt; getPathCount());</span><br>     2226-&gt;N:  <span style="background-color: white">      </span><br>  2227-&gt;2220:  <span style="background-color: cyan">      		AttributeStreamOfDbl position = (AttributeStreamOfDbl) (getAttributeStreamRef(VertexDescription.Semantics.POSITION));</span><br>  2228-&gt;2221:  <span style="background-color: cyan">      		AttributeStreamOfInt32 paths = (AttributeStreamOfInt32) (getPathStreamRef());</span><br>     2229-&gt;N:  <span style="background-color: white">      </span><br>  2230-&gt;2223:  <span style="background-color: cyan">      		int path_end = getPathEnd(path_index);</span><br>  2231-&gt;2224:  <span style="background-color: cyan">      		int path_start = getPathStart(path_index);</span><br>  2232-&gt;2225:  <span style="background-color: cyan">      		int max_index = -1;</span><br>  2233-&gt;2226:  <span style="background-color: cyan">      		Point2D max_point = new Point2D(), pt = new Point2D();</span><br>  2234-&gt;2227:  <span style="background-color: cyan">      		max_point.y = NumberUtils.negativeInf();</span><br>  2235-&gt;2228:  <span style="background-color: cyan">      		max_point.x = NumberUtils.negativeInf();</span><br>     2236-&gt;N:  <span style="background-color: white">      </span><br>  2237-&gt;2230:  <span style="background-color: cyan">      		for (int i = path_start + 0; i &lt; path_end; i++) {</span><br>  2238-&gt;2231:  <span style="background-color: cyan">      			position.read(2 * i, pt);</span><br>  2239-&gt;2232:  <span style="background-color: cyan">      			if (max_point.compare(pt) == -1) {</span><br>  2240-&gt;2233:  <span style="background-color: cyan">      				max_index = i;</span><br>  2241-&gt;2234:  <span style="background-color: cyan">      				max_point.setCoords(pt);</span><br>     2242-&gt;N:  <span style="background-color: white">      			}</span><br>     2243-&gt;N:  <span style="background-color: white">      		}</span><br>     2244-&gt;N:  <span style="background-color: white">      </span><br>  2245-&gt;2238:  <span style="background-color: cyan">      		return max_index;</span><br>     2246-&gt;N:  <span style="background-color: white">      	}</span><br>     2247-&gt;N:  <span style="background-color: white">      </span><br>     2248-&gt;N:  <span style="background-color: white">      	/**</span><br>     2249-&gt;N:  <span style="background-color: white">      	 * Returns total segment count in the MultiPathImpl.</span><br>     2250-&gt;N:  <span style="background-color: white">      	 */</span><br>  2251-&gt;2244:  <span style="background-color: white">      	public int getSegmentCount() {</span><br>  2252-&gt;2245:  <span style="background-color: white">      		int segCount = getPointCount();</span><br>     2253-&gt;N:  <span style="background-color: white">      		if (!m_bPolygon) {</span><br>  2254-&gt;2247:  <span style="background-color: white">      			segCount -= getPathCount();</span><br>  2255-&gt;2248:  <span style="background-color: white">      			for (int i = 0, n = getPathCount(); i &lt; n; i++)</span><br>  2256-&gt;2249:  <span style="background-color: white">      				if (isClosedPath(i))</span><br>  2257-&gt;2250:  <span style="background-color: white">      					segCount++;</span><br>     2258-&gt;N:  <span style="background-color: white">      		}</span><br>     2259-&gt;N:  <span style="background-color: white">      </span><br>  2260-&gt;2253:  <span style="background-color: white">      		return segCount;</span><br>     2261-&gt;N:  <span style="background-color: white">      	}</span><br>     2262-&gt;N:  <span style="background-color: white">      </span><br>  2263-&gt;2256:  <span style="background-color: white">      	public int getSegmentCount(int path_index) {</span><br>  2264-&gt;2257:  <span style="background-color: white">      		int segCount = getPathSize(path_index);</span><br>  2265-&gt;2258:  <span style="background-color: white">      		if (!isClosedPath(path_index))</span><br>  2266-&gt;2259:  <span style="background-color: white">      			segCount--;</span><br>  2267-&gt;2260:  <span style="background-color: white">      		return segCount;</span><br>     2268-&gt;N:  <span style="background-color: white">      	}</span><br>     2269-&gt;N:  <span style="background-color: white">      </span><br>     2270-&gt;N:  <span style="background-color: white">      	// HEADER defintions</span><br>  2271-&gt;2264:  <span style="background-color: white">      	@Override</span><br>  2272-&gt;2265:  <span style="background-color: white">      	public Geometry createInstance() {</span><br>     2273-&gt;N:  <span style="background-color: white">      		return new MultiPathImpl(m_bPolygon, getDescription());</span><br>     2274-&gt;N:  <span style="background-color: white">      	}</span><br>     2275-&gt;N:  <span style="background-color: white">      </span><br>  2276-&gt;2269:  <span style="background-color: white">      	@Override</span><br>  2277-&gt;2270:  <span style="background-color: white">      	public int getDimension() {</span><br>  2278-&gt;2271:  <span style="background-color: white">      		return m_bPolygon ? 2 : 1;</span><br>     2279-&gt;N:  <span style="background-color: white">      	}</span><br>     2280-&gt;N:  <span style="background-color: white">      </span><br>  2281-&gt;2274:  <span style="background-color: white">      	@Override</span><br>  2282-&gt;2275:  <span style="background-color: white">      	public Geometry.Type getType() {</span><br>     2283-&gt;N:  <span style="background-color: white">      		return m_bPolygon ? Type.Polygon : Type.Polyline;</span><br>     2284-&gt;N:  <span style="background-color: white">      	}</span><br>     2285-&gt;N:  <span style="background-color: white">      </span><br>     2286-&gt;N:  <span style="background-color: white">      	/**</span><br>     2287-&gt;N:  <span style="background-color: white">      	 * Returns True if the class is envelope. THis is not an exact method. Only</span><br>     2288-&gt;N:  <span style="background-color: white">      	 * addEnvelope makes this true.</span><br>     2289-&gt;N:  <span style="background-color: white">      	 */</span><br>  2290-&gt;2283:  <span style="background-color: white">      	public boolean isEnvelope() {</span><br>  2291-&gt;2284:  <span style="background-color: white">      		return !_hasDirtyFlag(DirtyFlags.DirtyIsEnvelope);</span><br>     2292-&gt;N:  <span style="background-color: white">      	}</span><br>     2293-&gt;N:  <span style="background-color: white">      </span><br>     2294-&gt;N:  <span style="background-color: white">      	/**</span><br>     2295-&gt;N:  <span style="background-color: white">      	 * Returns a reference to the AttributeStream of MultiPathImpl parts</span><br>     2296-&gt;N:  <span style="background-color: white">      	 * (Paths).</span><br>     2297-&gt;N:  <span style="background-color: white">      	 * </span><br>     2298-&gt;N:  <span style="background-color: white">      	 * For the non empty MultiPathImpl, that stream contains start points of the</span><br>     2299-&gt;N:  <span style="background-color: white">      	 * MultiPathImpl curves. In addition, the last element is the total point</span><br>     2300-&gt;N:  <span style="background-color: white">      	 * count. The number of vertices in a given part is parts[i + 1] - parts[i].</span><br>     2301-&gt;N:  <span style="background-color: white">      	 */</span><br>  2302-&gt;2295:  <span style="background-color: cyan">      	public AttributeStreamOfInt32 getPathStreamRef() {</span><br>     2303-&gt;N:  <span style="background-color: white">      		throwIfEmpty();</span><br>     2304-&gt;N:  <span style="background-color: white">      		return m_paths;</span><br>     2305-&gt;N:  <span style="background-color: white">      	}</span><br>     2306-&gt;N:  <span style="background-color: white">      </span><br>     2307-&gt;N:  <span style="background-color: white">      	/**</span><br>     2308-&gt;N:  <span style="background-color: white">      	 * sets a reference to an AttributeStream of MultiPathImpl paths (Paths).</span><br>     2309-&gt;N:  <span style="background-color: white">      	 */</span><br>  2310-&gt;2303:  <span style="background-color: cyan">      	public void setPathStreamRef(AttributeStreamOfInt32 paths) {</span><br>  2311-&gt;2304:  <span style="background-color: cyan">      		m_paths = paths;</span><br>  2312-&gt;2305:  <span style="background-color: cyan">      		notifyModified(DirtyFlags.DirtyAll);</span><br>     2313-&gt;N:  <span style="background-color: white">      	}</span><br>     2314-&gt;N:  <span style="background-color: white">      </span><br>     2315-&gt;N:  <span style="background-color: white">      	/**</span><br>     2316-&gt;N:  <span style="background-color: white">      	 * Returns a reference to the AttributeStream of Segment flags (SegmentFlags</span><br>     2317-&gt;N:  <span style="background-color: white">      	 * flags). Can be NULL when no non-linear segments are present.</span><br>     2318-&gt;N:  <span style="background-color: white">      	 * </span><br>     2319-&gt;N:  <span style="background-color: white">      	 * Segment flags indicate what kind of segment originates (starts) on the</span><br>     2320-&gt;N:  <span style="background-color: white">      	 * given point. The last vertices of open Path parts has enumNone flag.</span><br>     2321-&gt;N:  <span style="background-color: white">      	 */</span><br>  2322-&gt;2315:  <span style="background-color: cyan">      	public AttributeStreamOfInt8 getSegmentFlagsStreamRef() {</span><br>     2323-&gt;N:  <span style="background-color: white">      		throwIfEmpty();</span><br>     2324-&gt;N:  <span style="background-color: white">      		return m_segmentFlags;</span><br>     2325-&gt;N:  <span style="background-color: white">      	}</span><br>     2326-&gt;N:  <span style="background-color: white">      </span><br>     2327-&gt;N:  <span style="background-color: white">      	/**</span><br>     2328-&gt;N:  <span style="background-color: white">      	 * Returns a reference to the AttributeStream of Path flags (PathFlags</span><br>     2329-&gt;N:  <span style="background-color: white">      	 * flags).</span><br>     2330-&gt;N:  <span style="background-color: white">      	 * </span><br>     2331-&gt;N:  <span style="background-color: white">      	 * Each start point of a path has a flag set to indicate if the Path is open</span><br>     2332-&gt;N:  <span style="background-color: white">      	 * or closed.</span><br>     2333-&gt;N:  <span style="background-color: white">      	 */</span><br>  2334-&gt;2327:  <span style="background-color: cyan">      	public AttributeStreamOfInt8 getPathFlagsStreamRef() {</span><br>     2335-&gt;N:  <span style="background-color: white">      		throwIfEmpty();</span><br>     2336-&gt;N:  <span style="background-color: white">      		return m_pathFlags;</span><br>     2337-&gt;N:  <span style="background-color: white">      	}</span><br>     2338-&gt;N:  <span style="background-color: white">      </span><br>     2339-&gt;N:  <span style="background-color: white">      	/**</span><br>     2340-&gt;N:  <span style="background-color: white">      	 * sets a reference to an AttributeStream of Path flags (PathFlags flags).</span><br>     2341-&gt;N:  <span style="background-color: white">      	 */</span><br>  2342-&gt;2335:  <span style="background-color: cyan">      	public void setPathFlagsStreamRef(AttributeStreamOfInt8 pathFlags) {</span><br>  2343-&gt;2336:  <span style="background-color: cyan">      		m_pathFlags = pathFlags;</span><br>  2344-&gt;2337:  <span style="background-color: cyan">      		notifyModified(DirtyFlags.DirtyAll);</span><br>     2345-&gt;N:  <span style="background-color: white">      	}</span><br>     2346-&gt;N:  <span style="background-color: white">      </span><br>  2347-&gt;2340:  <span style="background-color: white">      	public AttributeStreamOfInt32 getSegmentIndexStreamRef() {</span><br>     2348-&gt;N:  <span style="background-color: white">      		throwIfEmpty();</span><br>     2349-&gt;N:  <span style="background-color: white">      		return m_segmentParamIndex;</span><br>     2350-&gt;N:  <span style="background-color: white">      	}</span><br>     2351-&gt;N:  <span style="background-color: white">      </span><br>  2352-&gt;2345:  <span style="background-color: white">      	public AttributeStreamOfDbl getSegmentDataStreamRef() {</span><br>     2353-&gt;N:  <span style="background-color: white">      		throwIfEmpty();</span><br>     2354-&gt;N:  <span style="background-color: white">      		return m_segmentParams;</span><br>     2355-&gt;N:  <span style="background-color: white">      	}</span><br>     2356-&gt;N:  <span style="background-color: white">      </span><br>  2357-&gt;2350:  <span style="background-color: cyan">      	public int getPathCount() {</span><br>  2358-&gt;2351:  <span style="background-color: cyan">      		return (m_paths != null) ? m_paths.size() - 1 : 0;</span><br>     2359-&gt;N:  <span style="background-color: white">      	}</span><br>     2360-&gt;N:  <span style="background-color: white">      </span><br>  2361-&gt;2354:  <span style="background-color: cyan">      	public int getPathEnd(int partIndex) {</span><br>  2362-&gt;2355:  <span style="background-color: cyan">      		return m_paths.read(partIndex + 1);</span><br>     2363-&gt;N:  <span style="background-color: white">      	}</span><br>     2364-&gt;N:  <span style="background-color: white">      </span><br>  2365-&gt;2358:  <span style="background-color: cyan">      	public int getPathSize(int partIndex) {</span><br>  2366-&gt;2359:  <span style="background-color: cyan">      		return m_paths.read(partIndex + 1) - m_paths.read(partIndex);</span><br>     2367-&gt;N:  <span style="background-color: white">      	}</span><br>     2368-&gt;N:  <span style="background-color: white">      </span><br>  2369-&gt;2362:  <span style="background-color: cyan">      	public int getPathStart(int partIndex) {</span><br>  2370-&gt;2363:  <span style="background-color: cyan">      		return m_paths.read(partIndex);</span><br>     2371-&gt;N:  <span style="background-color: white">      	}</span><br>     2372-&gt;N:  <span style="background-color: white">      </span><br>  2373-&gt;2366:  <span style="background-color: white">      	@Override</span><br>  2374-&gt;2367:  <span style="background-color: white">      	public Object _getImpl() {</span><br>     2375-&gt;N:  <span style="background-color: white">      		return this;</span><br>     2376-&gt;N:  <span style="background-color: white">      	}</span><br>     2377-&gt;N:  <span style="background-color: white">      </span><br>  2378-&gt;2371:  <span style="background-color: cyan">      	public void setDirtyOGCFlags(boolean bYesNo) {</span><br>  2379-&gt;2372:  <span style="background-color: cyan">      		_setDirtyFlag(DirtyFlags.DirtyOGCFlags, bYesNo);</span><br>     2380-&gt;N:  <span style="background-color: white">      	}</span><br>     2381-&gt;N:  <span style="background-color: white">      </span><br>  2382-&gt;2375:  <span style="background-color: white">      	public boolean hasDirtyOGCStartFlags() {</span><br>  2383-&gt;2376:  <span style="background-color: white">      		return _hasDirtyFlag(DirtyFlags.DirtyOGCFlags);</span><br>     2384-&gt;N:  <span style="background-color: white">      	}</span><br>     2385-&gt;N:  <span style="background-color: white">      </span><br>  2386-&gt;2379:  <span style="background-color: white">      	public void setDirtyRingAreas2D(boolean bYesNo) {</span><br>  2387-&gt;2380:  <span style="background-color: white">      		_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, bYesNo);</span><br>     2388-&gt;N:  <span style="background-color: white">      	}</span><br>     2389-&gt;N:  <span style="background-color: white">      </span><br>  2390-&gt;2383:  <span style="background-color: white">      	public boolean hasDirtyRingAreas2D() {</span><br>  2391-&gt;2384:  <span style="background-color: white">      		return _hasDirtyFlag(DirtyFlags.DirtyRingAreas2D);</span><br>     2392-&gt;N:  <span style="background-color: white">      	}</span><br>     2393-&gt;N:  <span style="background-color: white">      </span><br>  2394-&gt;2387:  <span style="background-color: white">      	public void setRingAreasStreamRef(AttributeStreamOfDbl ringAreas) {</span><br>  2395-&gt;2388:  <span style="background-color: white">      		m_cachedRingAreas2D = ringAreas;</span><br>  2396-&gt;2389:  <span style="background-color: white">      		_setDirtyFlag(DirtyFlags.DirtyRingAreas2D, false);</span><br>     2397-&gt;N:  <span style="background-color: white">      	}</span><br>     2398-&gt;N:  <span style="background-color: white">      </span><br>     2399-&gt;N:  <span style="background-color: white">      	// HEADER defintions</span><br>     2400-&gt;N:  <span style="background-color: white">      </span><br>     2401-&gt;N:  <span style="background-color: white">      	// // TODO check this against current implementation in native</span><br>     2402-&gt;N:  <span style="background-color: white">      	// public void notifyModified(int flags)</span><br>     2403-&gt;N:  <span style="background-color: white">      	// {</span><br>     2404-&gt;N:  <span style="background-color: white">      	// if(flags == DirtyFlags.DirtyAll)</span><br>     2405-&gt;N:  <span style="background-color: white">      	// {</span><br>     2406-&gt;N:  <span style="background-color: white">      	// m_reservedPointCount = -1;</span><br>     2407-&gt;N:  <span style="background-color: white">      	// _notifyModifiedAllImpl();</span><br>     2408-&gt;N:  <span style="background-color: white">      	// }</span><br>     2409-&gt;N:  <span style="background-color: white">      	// m_flagsMask |= flags;</span><br>     2410-&gt;N:  <span style="background-color: white">      	// _clearAccelerators();</span><br>     2411-&gt;N:  <span style="background-color: white">      	//</span><br>     2412-&gt;N:  <span style="background-color: white">      	//</span><br>     2413-&gt;N:  <span style="background-color: white">      	// // ROHIT's implementation</span><br>     2414-&gt;N:  <span style="background-color: white">      	// // if (m_paths == null || 0 == m_paths.size())</span><br>     2415-&gt;N:  <span style="background-color: white">      	// // m_pointCount = 0;</span><br>     2416-&gt;N:  <span style="background-color: white">      	// // else</span><br>     2417-&gt;N:  <span style="background-color: white">      	// // m_pointCount = m_paths.read(m_paths.size() - 1);</span><br>     2418-&gt;N:  <span style="background-color: white">      	// //</span><br>     2419-&gt;N:  <span style="background-color: white">      	// // super.notifyModified(flags);</span><br>     2420-&gt;N:  <span style="background-color: white">      	// }</span><br>     2421-&gt;N:  <span style="background-color: white">      </span><br>  2422-&gt;2415:  <span style="background-color: white">      	@Override</span><br>  2423-&gt;2416:  <span style="background-color: white">      	public boolean _buildRasterizedGeometryAccelerator(double toleranceXY,</span><br>  2424-&gt;2417:  <span style="background-color: white">      			GeometryAccelerationDegree accelDegree) {</span><br>  2425-&gt;2418:  <span style="background-color: white">      		if (m_accelerators == null)// (!m_accelerators)</span><br>     2426-&gt;N:  <span style="background-color: white">      		{</span><br>  2427-&gt;2420:  <span style="background-color: white">      			m_accelerators = new GeometryAccelerators();</span><br>     2428-&gt;N:  <span style="background-color: white">      		}</span><br>     2429-&gt;N:  <span style="background-color: white">      </span><br>  2430-&gt;2423:  <span style="background-color: white">      		int rasterSize = RasterizedGeometry2D</span><br>  2431-&gt;2424:  <span style="background-color: white">      				.rasterSizeFromAccelerationDegree(accelDegree);</span><br>  2432-&gt;2425:  <span style="background-color: white">      		RasterizedGeometry2D rgeom = m_accelerators.getRasterizedGeometry();</span><br>  2433-&gt;2426:  <span style="background-color: white">      		if (rgeom != null) {</span><br>  2434-&gt;2427:  <span style="background-color: white">      			if (rgeom.getToleranceXY() &lt; toleranceXY</span><br>  2435-&gt;2428:  <span style="background-color: white">      					|| rasterSize &gt; rgeom.getRasterSize()) {</span><br>  2436-&gt;2429:  <span style="background-color: white">      				m_accelerators._setRasterizedGeometry(null);</span><br>     2437-&gt;N:  <span style="background-color: white">      			} else</span><br>  2438-&gt;2431:  <span style="background-color: white">      				return true;</span><br>     2439-&gt;N:  <span style="background-color: white">      		}</span><br>     2440-&gt;N:  <span style="background-color: white">      </span><br>  2441-&gt;2434:  <span style="background-color: white">      		rgeom = RasterizedGeometry2D.create(this, toleranceXY, rasterSize);</span><br>  2442-&gt;2435:  <span style="background-color: white">      		m_accelerators._setRasterizedGeometry(rgeom);</span><br>     2443-&gt;N:  <span style="background-color: white">      		//rgeom.dbgSaveToBitmap("c:/temp/ddd.bmp");</span><br>  2444-&gt;2437:  <span style="background-color: white">      		return true;</span><br>     2445-&gt;N:  <span style="background-color: white">      	}</span><br>     2446-&gt;N:  <span style="background-color: white">      </span><br>  2447-&gt;2440:  <span style="background-color: white">      	@Override</span><br>  2448-&gt;2441:  <span style="background-color: white">      	public int hashCode() {</span><br>  2449-&gt;2442:  <span style="background-color: white">      		int hashCode = super.hashCode();</span><br>     2450-&gt;N:  <span style="background-color: white">      </span><br>     2451-&gt;N:  <span style="background-color: white">      		if (!isEmptyImpl()) {</span><br>  2452-&gt;2445:  <span style="background-color: white">      			int pathCount = getPathCount();</span><br>     2453-&gt;N:  <span style="background-color: white">      </span><br>  2454-&gt;2447:  <span style="background-color: white">      			if (m_paths != null)</span><br>  2455-&gt;2448:  <span style="background-color: white">      				m_paths.calculateHashImpl(hashCode, 0, pathCount + 1);</span><br>     2456-&gt;N:  <span style="background-color: white">      </span><br>  2457-&gt;2450:  <span style="background-color: white">      			if (m_pathFlags != null)</span><br>  2458-&gt;2451:  <span style="background-color: white">      				m_pathFlags.calculateHashImpl(hashCode, 0, pathCount);</span><br>     2459-&gt;N:  <span style="background-color: white">      		}</span><br>     2460-&gt;N:  <span style="background-color: white">      </span><br>  2461-&gt;2454:  <span style="background-color: white">      		return hashCode;</span><br>     2462-&gt;N:  <span style="background-color: white">      	}</span><br>     2463-&gt;N:  <span style="background-color: white">      </span><br>  2464-&gt;2457:  <span style="background-color: white">      	public byte getSegmentFlags(int ivertex) {</span><br>  2465-&gt;2458:  <span style="background-color: white">      		if (m_segmentFlags != null)</span><br>  2466-&gt;2459:  <span style="background-color: white">      			return m_segmentFlags.read(ivertex);</span><br>     2467-&gt;N:  <span style="background-color: white">      		else</span><br>     2468-&gt;N:  <span style="background-color: white">      			return (byte) SegmentFlags.enumLineSeg;</span><br>     2469-&gt;N:  <span style="background-color: white">      	}</span><br>     2470-&gt;N:  <span style="background-color: white">      </span><br>  2471-&gt;2464:  <span style="background-color: white">      	public void getSegment(int startVertexIndex, SegmentBuffer segBuffer,</span><br>  2472-&gt;2465:  <span style="background-color: white">      			boolean bStripAttributes) {</span><br>  2473-&gt;2466:  <span style="background-color: white">      		int ipath = getPathIndexFromPointIndex(startVertexIndex);</span><br>  2474-&gt;2467:  <span style="background-color: white">      		if (startVertexIndex == getPathEnd(ipath) - 1 &amp;&amp; !isClosedPath(ipath))</span><br>  2475-&gt;2468:  <span style="background-color: white">      			throw new GeometryException("index out of bounds");</span><br>     2476-&gt;N:  <span style="background-color: white">      </span><br>     2477-&gt;N:  <span style="background-color: white">      		_verifyAllStreams();</span><br>  2478-&gt;2471:  <span style="background-color: white">      		AttributeStreamOfInt8 segFlagStream = getSegmentFlagsStreamRef();</span><br>  2479-&gt;2472:  <span style="background-color: white">      		int segFlag = SegmentFlags.enumLineSeg;</span><br>  2480-&gt;2473:  <span style="background-color: white">      		if (segFlagStream != null)</span><br>  2481-&gt;2474:  <span style="background-color: white">      			segFlag = segFlagStream.read(startVertexIndex)</span><br>     2482-&gt;N:  <span style="background-color: white">      					&amp; SegmentFlags.enumSegmentMask;</span><br>     2483-&gt;N:  <span style="background-color: white">      </span><br>  2484-&gt;2477:  <span style="background-color: white">      		switch (segFlag) {</span><br>     2485-&gt;N:  <span style="background-color: white">      		case SegmentFlags.enumLineSeg:</span><br>  2486-&gt;2479:  <span style="background-color: white">      			segBuffer.createLine();</span><br>  2487-&gt;2480:  <span style="background-color: white">      			break;</span><br>     2488-&gt;N:  <span style="background-color: white">      		case SegmentFlags.enumBezierSeg:</span><br>  2489-&gt;2482:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>     2490-&gt;N:  <span style="background-color: white">      		case SegmentFlags.enumArcSeg:</span><br>  2491-&gt;2484:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>     2492-&gt;N:  <span style="background-color: white">      		default:</span><br>  2493-&gt;2486:  <span style="background-color: white">      			throw GeometryException.GeometryInternalError();</span><br>     2494-&gt;N:  <span style="background-color: white">      		}</span><br>     2495-&gt;N:  <span style="background-color: white">      </span><br>  2496-&gt;2489:  <span style="background-color: white">      		Segment currentSegment = segBuffer.get();</span><br>  2497-&gt;2490:  <span style="background-color: white">      		if (!bStripAttributes)</span><br>  2498-&gt;2491:  <span style="background-color: white">      			currentSegment.assignVertexDescription(m_description);</span><br>     2499-&gt;N:  <span style="background-color: white">      		else</span><br>  2500-&gt;2493:  <span style="background-color: white">      			currentSegment</span><br>  2501-&gt;2494:  <span style="background-color: white">      					.assignVertexDescription(VertexDescriptionDesignerImpl</span><br>     2502-&gt;N:  <span style="background-color: white">      							.getDefaultDescriptor2D());</span><br>     2503-&gt;N:  <span style="background-color: white">      </span><br>  2504-&gt;2497:  <span style="background-color: white">      		int endVertexIndex;</span><br>  2505-&gt;2498:  <span style="background-color: white">      		if (startVertexIndex == getPathEnd(ipath) - 1 &amp;&amp; isClosedPath(ipath)) {</span><br>  2506-&gt;2499:  <span style="background-color: white">      			endVertexIndex = getPathStart(ipath);</span><br>     2507-&gt;N:  <span style="background-color: white">      		} else</span><br>  2508-&gt;2501:  <span style="background-color: white">      			endVertexIndex = startVertexIndex + 1;</span><br>     2509-&gt;N:  <span style="background-color: white">      </span><br>  2510-&gt;2503:  <span style="background-color: white">      		Point2D pt = new Point2D();</span><br>  2511-&gt;2504:  <span style="background-color: white">      		getXY(startVertexIndex, pt);</span><br>  2512-&gt;2505:  <span style="background-color: white">      		currentSegment.setStartXY(pt);</span><br>  2513-&gt;2506:  <span style="background-color: white">      		getXY(endVertexIndex, pt);</span><br>  2514-&gt;2507:  <span style="background-color: white">      		currentSegment.setEndXY(pt);</span><br>     2515-&gt;N:  <span style="background-color: white">      </span><br>  2516-&gt;2509:  <span style="background-color: white">      		if (!bStripAttributes) {</span><br>  2517-&gt;2510:  <span style="background-color: white">      			for (int i = 1, nattr = m_description.getAttributeCount(); i &lt; nattr; i++) {</span><br>  2518-&gt;2511:  <span style="background-color: white">      				int semantics = m_description._getSemanticsImpl(i);</span><br>  2519-&gt;2512:  <span style="background-color: white">      				int ncomp = VertexDescription.getComponentCount(semantics);</span><br>  2520-&gt;2513:  <span style="background-color: white">      				for (int ord = 0; ord &lt; ncomp; ord++) {</span><br>  2521-&gt;2514:  <span style="background-color: white">      					double vs = getAttributeAsDbl(semantics, startVertexIndex,</span><br>  2522-&gt;2515:  <span style="background-color: white">      							ord);</span><br>  2523-&gt;2516:  <span style="background-color: white">      					currentSegment.setStartAttribute(semantics, ord, vs);</span><br>  2524-&gt;2517:  <span style="background-color: white">      					double ve = getAttributeAsDbl(semantics, endVertexIndex,</span><br>  2525-&gt;2518:  <span style="background-color: white">      							ord);</span><br>  2526-&gt;2519:  <span style="background-color: white">      					currentSegment.setEndAttribute(semantics, ord, ve);</span><br>     2527-&gt;N:  <span style="background-color: white">      				}</span><br>     2528-&gt;N:  <span style="background-color: white">      			}</span><br>     2529-&gt;N:  <span style="background-color: white">      		}</span><br>     2530-&gt;N:  <span style="background-color: white">      	}</span><br>     2531-&gt;N:  <span style="background-color: white">      </span><br>  2532-&gt;2525:  <span style="background-color: white">      	void queryPathEnvelope2D(int path_index, Envelope2D envelope) {</span><br>  2533-&gt;2526:  <span style="background-color: white">      		if (path_index &gt;= getPathCount())</span><br>  2534-&gt;2527:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>     2535-&gt;N:  <span style="background-color: white">      </span><br>     2536-&gt;N:  <span style="background-color: white">      		if (isEmpty()) {</span><br>  2537-&gt;2530:  <span style="background-color: white">      			envelope.setEmpty();</span><br>  2538-&gt;2531:  <span style="background-color: white">      			return;</span><br>     2539-&gt;N:  <span style="background-color: white">      		}</span><br>     2540-&gt;N:  <span style="background-color: white">      </span><br>  2541-&gt;2534:  <span style="background-color: white">      		if (hasNonLinearSegments(path_index)) {</span><br>  2542-&gt;2535:  <span style="background-color: white">      			throw new GeometryException("not implemented");</span><br>     2543-&gt;N:  <span style="background-color: white">      		} else {</span><br>  2544-&gt;2537:  <span style="background-color: white">      			AttributeStreamOfDbl stream = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);</span><br>  2545-&gt;2538:  <span style="background-color: white">      			Point2D pt = new Point2D();</span><br>  2546-&gt;2539:  <span style="background-color: white">      			Envelope2D env = new Envelope2D();</span><br>  2547-&gt;2540:  <span style="background-color: white">      			env.setEmpty();</span><br>  2548-&gt;2541:  <span style="background-color: white">      			for (int i = getPathStart(path_index), iend = getPathEnd(path_index); i &lt; iend; i++) {</span><br>  2549-&gt;2542:  <span style="background-color: white">      				stream.read(2 * i, pt);</span><br>  2550-&gt;2543:  <span style="background-color: white">      				env.merge(pt);</span><br>     2551-&gt;N:  <span style="background-color: white">      			}</span><br>  2552-&gt;2545:  <span style="background-color: white">      			envelope.setCoords(env);</span><br>     2553-&gt;N:  <span style="background-color: white">      		}</span><br>     2554-&gt;N:  <span style="background-color: white">      	}</span><br>     2555-&gt;N:  <span style="background-color: white">      </span><br>  2556-&gt;2549:  <span style="background-color: white">      	public void queryLoosePathEnvelope2D(int path_index, Envelope2D envelope) {</span><br>  2557-&gt;2550:  <span style="background-color: white">      		if (path_index &gt;= getPathCount())</span><br>  2558-&gt;2551:  <span style="background-color: white">      			throw new IllegalArgumentException();</span><br>     2559-&gt;N:  <span style="background-color: white">      </span><br>     2560-&gt;N:  <span style="background-color: white">      		if (isEmpty()) {</span><br>  2561-&gt;2554:  <span style="background-color: white">      			envelope.setEmpty();</span><br>  2562-&gt;2555:  <span style="background-color: white">      			return;</span><br>     2563-&gt;N:  <span style="background-color: white">      		}</span><br>     2564-&gt;N:  <span style="background-color: white">      </span><br>  2565-&gt;2558:  <span style="background-color: white">      		if (hasNonLinearSegments(path_index)) {</span><br>  2566-&gt;2559:  <span style="background-color: white">      			throw new GeometryException("not implemented");</span><br>     2567-&gt;N:  <span style="background-color: white">      		} else {</span><br>  2568-&gt;2561:  <span style="background-color: white">      			AttributeStreamOfDbl stream = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);</span><br>  2569-&gt;2562:  <span style="background-color: white">      			Point2D pt = new Point2D();</span><br>  2570-&gt;2563:  <span style="background-color: white">      			Envelope2D env = new Envelope2D();</span><br>  2571-&gt;2564:  <span style="background-color: white">      			env.setEmpty();</span><br>  2572-&gt;2565:  <span style="background-color: white">      			for (int i = getPathStart(path_index), iend = getPathEnd(path_index); i &lt; iend; i++) {</span><br>  2573-&gt;2566:  <span style="background-color: white">      				stream.read(2 * i, pt);</span><br>  2574-&gt;2567:  <span style="background-color: white">      				env.merge(pt);</span><br>     2575-&gt;N:  <span style="background-color: white">      			}</span><br>  2576-&gt;2569:  <span style="background-color: white">      			envelope.setCoords(env);</span><br>     2577-&gt;N:  <span style="background-color: white">      		}</span><br>     2578-&gt;N:  <span style="background-color: white">      	}</span><br>     2579-&gt;N:  <span style="background-color: white">      	</span><br>  2580-&gt;2573:  <span style="background-color: white">      	@Override</span><br>  2581-&gt;2574:  <span style="background-color: white">      	public boolean _buildQuadTreeAccelerator(GeometryAccelerationDegree d) {</span><br>  2582-&gt;2575:  <span style="background-color: white">      		if (m_accelerators == null)// (!m_accelerators)</span><br>     2583-&gt;N:  <span style="background-color: white">      		{</span><br>  2584-&gt;2577:  <span style="background-color: white">      			m_accelerators = new GeometryAccelerators();</span><br>     2585-&gt;N:  <span style="background-color: white">      		}</span><br>     2586-&gt;N:  <span style="background-color: white">      </span><br>  2587-&gt;2580:  <span style="background-color: white">      		if (d == GeometryAccelerationDegree.enumMild || getPointCount() &lt; 16)</span><br>  2588-&gt;2581:  <span style="background-color: white">      			return false;</span><br>     2589-&gt;N:  <span style="background-color: white">      </span><br>  2590-&gt;2583:  <span style="background-color: white">      		QuadTreeImpl quad_tree_impl = InternalUtils.buildQuadTree(this);</span><br>  2591-&gt;2584:  <span style="background-color: white">      		m_accelerators._setQuadTree(quad_tree_impl);</span><br>     2592-&gt;N:  <span style="background-color: white">      </span><br>  2593-&gt;2586:  <span style="background-color: white">      		return true;</span><br>     2594-&gt;N:  <span style="background-color: white">      	}</span><br>     2595-&gt;N:  <span style="background-color: white">      </span><br>  2596-&gt;2589:  <span style="background-color: white">      	boolean _buildQuadTreeForPathsAccelerator(GeometryAccelerationDegree degree) {</span><br>  2597-&gt;2590:  <span style="background-color: white">      		if (m_accelerators == null) {</span><br>  2598-&gt;2591:  <span style="background-color: white">      			m_accelerators = new GeometryAccelerators();</span><br>     2599-&gt;N:  <span style="background-color: white">      		}</span><br>     2600-&gt;N:  <span style="background-color: white">      </span><br>     2601-&gt;N:  <span style="background-color: white">      		// TODO: when less than two envelopes - no need to this.</span><br>     2602-&gt;N:  <span style="background-color: white">      </span><br>  2603-&gt;2596:  <span style="background-color: white">      		if (m_accelerators.getQuadTreeForPaths() != null)</span><br>  2604-&gt;2597:  <span style="background-color: white">      			return true;</span><br>     2605-&gt;N:  <span style="background-color: white">      </span><br>  2606-&gt;2599:  <span style="background-color: white">      		m_accelerators._setQuadTreeForPaths(null);</span><br>  2607-&gt;2600:  <span style="background-color: white">      		QuadTreeImpl quad_tree_impl = InternalUtils.buildQuadTreeForPaths(this);</span><br>  2608-&gt;2601:  <span style="background-color: white">      		m_accelerators._setQuadTreeForPaths(quad_tree_impl);</span><br>     2609-&gt;N:  <span style="background-color: white">      </span><br>  2610-&gt;2603:  <span style="background-color: white">      		return true;</span><br>     2611-&gt;N:  <span style="background-color: white">      	}</span><br>     2612-&gt;N:  <span style="background-color: white">      </span><br>  2613-&gt;2606:  <span style="background-color: white">      	void setFillRule(int rule) {</span><br>     2614-&gt;N:  <span style="background-color: white">      		assert (m_bPolygon);</span><br>  2615-&gt;2608:  <span style="background-color: white">      		m_fill_rule = rule;</span><br>     2616-&gt;N:  <span style="background-color: white">      	}</span><br>     2617-&gt;N:  <span style="background-color: white">      </span><br>  2618-&gt;2611:  <span style="background-color: white">      	int getFillRule() {</span><br>     2619-&gt;N:  <span style="background-color: white">      		return m_fill_rule;</span><br>     2620-&gt;N:  <span style="background-color: white">      	}</span><br>     2621-&gt;N:  <span style="background-color: white">      </span><br>  2622-&gt;2615:  <span style="background-color: white">      	void clearDirtyOGCFlags() { </span><br>  2623-&gt;2616:  <span style="background-color: white">      		_setDirtyFlag(DirtyFlags.DirtyOGCFlags, false);</span><br>     2624-&gt;N:  <span style="background-color: white">      	}</span><br>     2625-&gt;N:  <span style="background-color: white">      }</span><br>     2626-&gt;N:  <span style="background-color: white">      </span><br></pre> </code> 
   </div> 
  </div>  
 </body>
</html>